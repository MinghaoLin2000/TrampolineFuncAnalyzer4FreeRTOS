/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/mpu_demo.hvStartMPUDemo__MPU_DEMO_H__void_param_listc_linkage/* __MPU_DEMO_H__ *//**
 * @brief Creates all the tasks for MPU demo.
 *
 * The MPU demo creates 2 unprivileged tasks - One of which has Read Only access
 * to a shared memory region while the other has Read Write access. The task
 * with Read Only access then tries to write to the shared memory which results
 * in a Memory fault. The fault handler examines that it is the fault generated
 * by the task with Read Only access and if so, it recovers from the fault
 * greacefully by moving the Program Counter to the next instruction to the one
 * which generated the fault. If any other memory access violation occurs, the
 * fault handler will get stuck in an infinite loop.
 *//*
 * FreeRTOS V202212.00
 * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * https://www.FreeRTOS.org
 * https://github.com/FreeRTOS
 *
 *//Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/Users/mac/Downloads/FreeRTOS/Demo/Users/mac/Downloads/FreeRTOS/Users/mac/Downloads/Users/mac/Users/compiled as c1/Users/mac/Downloads/FreeRTOS/Source/include/FreeRTOS.h/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h2/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/lib/gcc/arm-none-eabi/10.3.1/include/stdint.h3/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/stdint.h4/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/machine/_default_types.h5/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/features.h6/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/_newlib_version.h7/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/_intsup.h8/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/_stdint.h9/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/FreeRTOSConfig.h10/Users/mac/Downloads/FreeRTOS/Source/include/projdefs.h11/Users/mac/Downloads/FreeRTOS/Source/include/portable.h12/Users/mac/Downloads/FreeRTOS/Source/include/deprecated_definitions.h13/Users/mac/Downloads/FreeRTOS/Source/portable/GCC/ARM_CM3_MPU/portmacro.h14/Users/mac/Downloads/FreeRTOS/Source/include/mpu_wrappers.h15/Users/mac/Downloads/FreeRTOS/Source/include/task.h16/Users/mac/Downloads/FreeRTOS/Source/include/list.h17/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/app_main.h1819/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/stdio.h20/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/_ansi.h21/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/newlib.h22/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/config.h23/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/machine/ieeefp.h24/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/cdefs.h252627/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/lib/gcc/arm-none-eabi/10.3.1/include/stdarg.h28/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/reent.h2930/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/_types.h3132/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/machine/_types.h33/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/lock.h34/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/types.h35/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/machine/endian.h36/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/machine/_endian.h37/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/select.h38/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/_sigset.h39/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/_timeval.h40/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/timespec.h41/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/_timespec.h42/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/_pthreadtypes.h43/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/sched.h44/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/machine/types.h45/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/stdio.h46/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/app_main.c<stdio.h>"mpu_demo.h""app_main.h""task.h""FreeRTOS.h"vApplicationGetTimerTaskMemoryStaticTask_t *xSTATIC_TCB *StaticTask_t **xSTATIC_TCB **StackType_t *unsigned long *StackType_t **unsigned long **uint32_t *xTimerTaskTCBstaticStackType_t[256]unsigned long[256]256configTIMER_TASK_STACK_DEPTHuxTimerTaskStackvApplicationGetIdleTaskMemoryxIdleTaskTCBconfigMINIMAL_STACK_SIZEuxIdleTaskStackvApplicationMallocFailedHookconst charconst char *char *const char *__restrict__..(*)(..)Application Malloc Failed Hook called
"Application Malloc Failed Hook called\n"char[39]vApplicationStackOverflowHookStack Overflow Hook called
"Stack Overflow Hook called\n"char[28]app_mainReturned from vTaskStartScheduler something bad had happened
"Returned from vTaskStartScheduler something bad had happened\n"char[62]/*-----------------------------------------------------------*//* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.
     * Note that, as the array is necessarily of type StackType_t,
     * configMINIMAL_STACK_SIZE is specified in words, not bytes. *//* Pass out the array that will be used as the Timer task's stack. *//* Pass out a pointer to the StaticTask_t structure in which the Timer
     * task's state will be stored. *//* If the buffers to be provided to the Timer task are declared inside this
 * function then they must be declared static - otherwise they will be allocated on
 * the stack and so not exists after this function exits. *//* configUSE_STATIC_ALLOCATION and configUSE_TIMERS are both set to 1, so the
 * application must provide an implementation of vApplicationGetTimerTaskMemory()
 * to provide the memory that is used by the Timer service task. *//* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
     * Note that, as the array is necessarily of type StackType_t,
     * configMINIMAL_STACK_SIZE is specified in words, not bytes. *//* Pass out the array that will be used as the Idle task's stack. *//* Pass out a pointer to the StaticTask_t structure in which the Idle task's
     * state will be stored. *//* If the buffers to be provided to the Idle task are declared inside this
 * function then they must be declared static - otherwise they will be allocated on
 * the stack and so not exists after this function exits. *//* configUSE_STATIC_ALLOCATION is set to 1, so the application must provide an
 * implementation of vApplicationGetIdleTaskMemory() to provide the memory that is
 * used by the Idle task. *//* If configUSE_MALLOC_FAILED_HOOK is set to 1 then this function will
    *  be called automatically if a call to pvPortMalloc() fails.  pvPortMalloc()
    *  is called automatically when a task, queue or semaphore is created. *//* If configCHECK_FOR_STACK_OVERFLOW is set to either 1 or 2 then this
     * function will automatically get called if a task overflows its stack. *//* Should not get here. *//* Start the scheduler. *//* Start the MPU demo. *//* Demo includes. *//* App includes. *//* Scheduler includes. */ppxTimerTaskTCBBufferppxTimerTaskStackBufferpulTimerTaskStackSizeppxIdleTaskTCBBufferppxIdleTaskStackBufferpulIdleTaskStackSizepxTaskpcTaskNameerrorunknownvoiddecltype(nullptr)boolwchar_tchar8_tchar16_tchar32_tcharunsigned charsigned charshortunsigned shortsigned shortintunsigned intsigned intlongunsigned longsigned longlong longunsigned long longsigned long long__int128unsigned __int128signed __int128_Float16floatdoublelong double__float128_Decimal32_Decimal64_Decimal128_Float32_Float32x_Float64_Float64x_Float128_Float128x_Complex _Float16_Complex float_Complex double_Complex long double_Complex __float128_Imaginary float_Imaginary double_Imaginary long doubleauto__superpublicprotectedprivatepurevirtualdeclared_virtualinlineexplicitconstvolatilerestrictatomicfinaloverrideoptionalis_constexpris_constevalis_thread_localdeclared_constexprdeclared_constinitnoreturn&&&externregister__blocknearfarsealedabstract__interfaceunaligneddllimportdllexportthreadnakedmicrosoft_inlineforceinlineselectanynothrownovtablenoinlinenoalias__ptr32__ptr64__sptr__uptrvarargsimplicit_inthas_trailing_return_type__NEWLIB_PATCHLEVEL__0__NEWLIB_MINOR____NEWLIB___NEWLIB_VERSION"4.1.0"_NEWLIB_VERSION_H__/* !_NEWLIB_VERSION_H__ *//* Version macros for internal and downstream use. *//* _newlib_version.h.  Generated from _newlib_version.hin by configure.  *//Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10<_newlib_version.h>__SSP_FORTIFY_LEVEL__XSI_VISIBLE__SVID_VISIBLE__POSIX_VISIBLE200809__MISC_VISIBLE__LARGEFILE_VISIBLE__ISO_C_VISIBLE2011__GNU_VISIBLE__BSD_VISIBLE__ATFILE_VISIBLE_ATFILE_SOURCE_POSIX_C_SOURCE200809L_POSIX_SOURCE_DEFAULT_SOURCE__GNUC_PREREQ__(ma,mi)__GNUC_PREREQ(ma, mi)__GNUC_PREREQ(maj,min)((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))_SYS_FEATURES_H__cplusplus__GNUC_PREREQdefined __GNUC__ && defined __GNUC_MINOR___GNU_SOURCEdefined(_BSD_SOURCE) || defined(_SVID_SOURCE) || \defined(_DEFAULT_SOURCE)!defined(_POSIX_SOURCE) && !defined(_POSIX_C_SOURCE) && \!defined(_XOPEN_SOURCE) || (_XOPEN_SOURCE - 0) >= 700(_XOPEN_SOURCE - 0) >= 600(_XOPEN_SOURCE - 0) >= 500(_XOPEN_SOURCE - 0) < 500defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200809defined(_ISOC11_SOURCE) || \defined(_ISOC99_SOURCE) || (_POSIX_C_SOURCE - 0) >= 200112L || \defined(_LARGEFILE_SOURCE) || (_XOPEN_SOURCE - 0) >= 500(_POSIX_C_SOURCE - 0) >= 200809L(_POSIX_C_SOURCE - 0) >= 200112L(_POSIX_C_SOURCE - 0) >= 199506L(_POSIX_C_SOURCE - 0) >= 199309L(_POSIX_C_SOURCE - 0) >= 2 || defined(_XOPEN_SOURCE)defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE)(_XOPEN_SOURCE - 0) >= 700defined(_XOPEN_SOURCE) && defined(_XOPEN_SOURCE_EXTENDED)defined(_XOPEN_SOURCE)_FORTIFY_SOURCE > 0 && !defined(__cplusplus) && !defined(__lint__) && \_FORTIFY_SOURCE > 1__rtems____XMK____svr4____CYGWIN____POSIX_VISIBLE >= 200809__POSIX_VISIBLE >= 200112__POSIX_VISIBLE >= 199506__POSIX_VISIBLE >= 199309__POSIX_VISIBLE >= 199209__XSI_VISIBLE >= 4__POSIX_VISIBLE >= 2__LP64____GNUC_MINOR____GNUC____OPTIMIZE____STDC_VERSION__201710L/* _SYS_FEATURES_H *//* __CYGWIN__ *//*
 * newlib's wide char conversion functions were updated on
 *	2019-01-12
 * to UNICODE version:
 *	11.0.0 released 2018-06-05
 *//* __XSI_VISIBLE *//* #define _XOPEN_UNIX				    -1 *//* #define _XOPEN_STREAMS			    -1 *//* #define _XOPEN_REALTIME_THREADS		    -1 *//* #define _XOPEN_REALTIME			    -1 *//* #define _XOPEN_LEGACY			    -1 *//* __POSIX_VISIBLE >= 2 *//* #define _POSIX2_PBS_TRACK			    -1 *//* #define _POSIX2_PBS_MESSAGE			    -1 *//* #define _POSIX2_PBS_LOCATE			    -1 *//* #define _POSIX2_PBS_CHECKPOINT		    -1 *//* #define _POSIX2_PBS_ACCOUNTING		    -1 *//* #define _POSIX2_PBS				    -1 *//* #define _POSIX2_LOCALEDEF			    -1 *//* #define _POSIX2_FORT_RUN			    -1 *//* #define _POSIX2_FORT_DEV			    -1 *//* #define _POSIX_TYPED_MEMORY_OBJECTS		    -1 *//* #define _POSIX_TRACE_LOG			    -1 *//* #define _POSIX_TRACE_INHERIT			    -1 *//* #define _POSIX_TRACE_EVENT_FILTER		    -1 *//* #define _POSIX_TRACE				    -1 *//* #define _POSIX_THREAD_SPORADIC_SERVER	    -1 *//* #define _POSIX_THREAD_PRIO_PROTECT		    -1 *//* #define _POSIX_THREAD_PRIO_INHERIT		    -1 *//* #define _POSIX_SPORADIC_SERVER		    -1 *//* #define _POSIX_PRIORITIZED_IO		    -1 *//* #define _POSIX_MEMLOCK			    -1 *//* XMK loosely adheres to POSIX -- 1003.1 *//* POSIX 1003.26-2003 defined device control method *//* UNIX98 added some new pthread mutex attributes *//* P1003.4b/D8 defines the constants below this comment. *//* In P1003.1b but defined by drafts at least as early as P1003.1c/D10  *//* RTEMS adheres to POSIX -- 1003.1b with some features from annexes.  *//*
 * The following private macros are used throughout the headers to control
 * which symbols should be exposed.  They are for internal use only, as
 * indicated by the leading double underscore, and must never be used outside
 * of these headers.
 *
 * __POSIX_VISIBLE
 * 	any version of POSIX.1; enabled by default, or with _POSIX_SOURCE,
 * 	any value of _POSIX_C_SOURCE, or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 2
 * 	POSIX.2-1992; enabled by default, with _POSIX_C_SOURCE >= 2,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 199309
 * 	POSIX.1b-1993; enabled by default, with _POSIX_C_SOURCE >= 199309L,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 199506
 * 	POSIX.1c-1995; enabled by default, with _POSIX_C_SOURCE >= 199506L,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 200112
 * 	POSIX.1-2001; enabled by default, with _POSIX_C_SOURCE >= 200112L,
 * 	or _XOPEN_SOURCE >= 600.
 *
 * __POSIX_VISIBLE >= 200809
 * 	POSIX.1-2008; enabled by default, with _POSIX_C_SOURCE >= 200809L,
 * 	or _XOPEN_SOURCE >= 700.
 *
 * __XSI_VISIBLE
 *	XPG4 XSI extensions; enabled with any version of _XOPEN_SOURCE.
 *
 * __XSI_VISIBLE >= 4
 *	SUSv1 XSI extensions; enabled with both _XOPEN_SOURCE and
 * 	_XOPEN_SOURCE_EXTENDED together.
 *
 * __XSI_VISIBLE >= 500
 *	SUSv2 XSI extensions; enabled with _XOPEN_SOURCE >= 500.
 *
 * __XSI_VISIBLE >= 600
 *	SUSv3 XSI extensions; enabled with _XOPEN_SOURCE >= 600.
 *
 * __XSI_VISIBLE >= 700
 *	SUSv4 XSI extensions; enabled with _XOPEN_SOURCE >= 700.
 *
 * __ISO_C_VISIBLE >= 1999
 * 	ISO C99; enabled with gcc -std=c99 or newer (on by default since GCC 5),
 * 	any version of C++, or with _ISOC99_SOURCE, _POSIX_C_SOURCE >= 200112L,
 * 	or _XOPEN_SOURCE >= 600.
 *
 * __ISO_C_VISIBLE >= 2011
 * 	ISO C11; enabled with gcc -std=c11 or newer (on by default since GCC 5),
 * 	g++ -std=c++11 or newer (on by default since GCC 6), or with
 * 	_ISOC11_SOURCE.
 *
 * __ATFILE_VISIBLE
 *	"at" functions; enabled by default, with _ATFILE_SOURCE,
 * 	_POSIX_C_SOURCE >= 200809L, or _XOPEN_SOURCE >= 700.
 *
 * __LARGEFILE_VISIBLE
 *	fseeko, ftello; enabled with _LARGEFILE_SOURCE or _XOPEN_SOURCE >= 500.
 *
 * __BSD_VISIBLE
 * 	BSD extensions; enabled by default, or with _BSD_SOURCE.
 *
 * __SVID_VISIBLE
 * 	SVr4 extensions; enabled by default, or with _SVID_SOURCE.
 *
 * __MISC_VISIBLE
 * 	Extensions found in both BSD and SVr4 (shorthand for
 * 	(__BSD_VISIBLE || __SVID_VISIBLE)), or newlib-specific
 * 	extensions; enabled by default.
 *
 * __GNU_VISIBLE
 * 	GNU extensions; enabled with _GNU_SOURCE.
 *
 * __SSP_FORTIFY_LEVEL
 * 	Object Size Checking; defined to 0 (off), 1, or 2.
 *
 * In all cases above, "enabled by default" means either by defining
 * _DEFAULT_SOURCE, or by not defining any of the public feature test macros.
 *//* _GNU_SOURCE *//*
 * Feature test macros control which symbols are exposed by the system
 * headers.  Any of these must be defined before including any headers.
 *
 * __STRICT_ANSI__ (defined by gcc -ansi, -std=c90, -std=c99, or -std=c11)
 *	ISO C
 *
 * _POSIX_SOURCE (deprecated by _POSIX_C_SOURCE=1)
 * _POSIX_C_SOURCE >= 1
 * 	POSIX.1-1990
 *
 * _POSIX_C_SOURCE >= 2
 * 	POSIX.2-1992
 *
 * _POSIX_C_SOURCE >= 199309L
 * 	POSIX.1b-1993 Real-time extensions
 *
 * _POSIX_C_SOURCE >= 199506L
 * 	POSIX.1c-1995 Threads extensions
 *
 * _POSIX_C_SOURCE >= 200112L
 * 	POSIX.1-2001 and C99
 *
 * _POSIX_C_SOURCE >= 200809L
 * 	POSIX.1-2008
 *
 * _XOPEN_SOURCE
 *	POSIX.1-1990 and XPG4
 *
 * _XOPEN_SOURCE_EXTENDED
 *	SUSv1 (POSIX.2-1992 plus XPG4v2)
 *
 * _XOPEN_SOURCE >= 500
 *	SUSv2 (POSIX.1c-1995 plus XSI)
 *
 * _XOPEN_SOURCE >= 600
 *	SUSv3 (POSIX.1-2001 plus XSI) and C99
 *
 * _XOPEN_SOURCE >= 700
 *	SUSv4 (POSIX.1-2008 plus XSI)
 *
 * _ISOC99_SOURCE or gcc -std=c99 or g++
 * 	ISO C99
 *
 * _ISOC11_SOURCE or gcc -std=c11 or g++ -std=c++11
 * 	ISO C11
 *
 * _ATFILE_SOURCE (implied by _POSIX_C_SOURCE >= 200809L)
 *	"at" functions
 *
 * _LARGEFILE_SOURCE (deprecated by _XOPEN_SOURCE >= 500)
 *	fseeko, ftello
 *
 * _GNU_SOURCE
 * 	All of the above plus GNU extensions
 *
 * _BSD_SOURCE (deprecated by _DEFAULT_SOURCE)
 * _SVID_SOURCE (deprecated by _DEFAULT_SOURCE)
 * _DEFAULT_SOURCE (or none of the above)
 * 	POSIX-1.2008 with BSD and SVr4 extensions
 *
 * _FORTIFY_SOURCE = 1 or 2
 * 	Object Size Checking function wrappers
 *//* Version with trailing underscores for BSD compatibility. *//* __GNUC_PREREQ *//* Macro to test version of GCC.  Returns 0 for non-GCC or too old GCC. *//*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 *//Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys<sys/features.h>__uintptr_t__intptr_t__uintmax_t__intmax_t__uint_least64_t__int_least64_t__uint_least32_t__int_least32_t__uint_least16_t__int_least16_t__uint_least8_t__int_least8_t__uint64_t__int64_t__uint32_t__int32_t__uint16_t__int16_t__uint8_t__int8_t__EXP___int_least64_t_defined___int_least32_t_defined___int_least16_t_defined___int_least8_t_defined___int64_t_defined___int32_t_defined___int16_t_defined___int8_t_defined__have_long32__have_longlong64__EXP(x)__ ## x ## ___MACHINE__DEFAULT_TYPES_H__GNUC_PREREQ (3, 3)( defined(__LONG_LONG_MAX__) && (__LONG_LONG_MAX__ > 0x7fffffff) ) \__EXP(LONG_MAX) > 0x7fffffff__EXP(LONG_MAX) == 0x7fffffff && !defined(__SPU__)__INT8_TYPE____UINT8_TYPE____EXP(SCHAR_MAX) == 0x7f__INT16_TYPE____UINT16_TYPE____EXP(INT_MAX) == 0x7fff__EXP(SHRT_MAX) == 0x7fff__EXP(SCHAR_MAX) == 0x7fff__INT32_TYPE____UINT32_TYPE____EXP(INT_MAX) == 0x7fffffffL__EXP(LONG_MAX) == 0x7fffffffL__EXP(SHRT_MAX) == 0x7fffffffL__EXP(SCHAR_MAX) == 0x7fffffffL__INT64_TYPE____UINT64_TYPE__defined(__LONG_LONG_MAX__) && (__LONG_LONG_MAX__ > 0x7fffffff)defined(LLONG_MAX) && (LLONG_MAX > 0x7fffffff)__EXP(INT_MAX) > 0x7fffffff__INT_LEAST8_TYPE____UINT_LEAST8_TYPE__defined(___int8_t_defined)defined(___int16_t_defined)defined(___int32_t_defined)defined(___int64_t_defined)__INT_LEAST16_TYPE____UINT_LEAST16_TYPE____INT_LEAST32_TYPE____UINT_LEAST32_TYPE____INT_LEAST64_TYPE____UINT_LEAST64_TYPE__defined(__INTMAX_TYPE__)defined(__UINTMAX_TYPE__)__INTPTR_TYPE____UINTPTR_TYPE__defined(__PTRDIFF_TYPE__)__UINTMAX_TYPE__long long unsigned int__INTMAX_TYPE__long long intlong unsigned intlong intshort unsigned intshort int__LONG_MAX__0x7fffffffLLONG_MAX__LONG_LONG_MAX__0x7fffffffffffffffLL/* _MACHINE__DEFAULT_TYPES_H *//* POSIX mandates LLONG_MAX in <limits.h> *//* GCC has __LONG_LONG_MAX__ *//* Check if "long" is 64bit or 32bit wide *//* Modern GCCs provide __LONG_LONG_MAX__, SUSv3 wants LLONG_MAX *//* Check if "long long" is 64bit wide *//* Fall back to POSIX versions from <limits.h> *//* GCC >= 3.3.0 has __<val>__ implicitly defined. *//*
 * Guess on types by examining *_MIN / *_MAX defines.
 *//*
 *  $Id$
 *//Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/machineunsignedsigned__LEAST64"ll"__LEAST32"l"__LEAST16"h"__LEAST8"hh"__FAST64__FAST32__FAST16__FAST8__INT64__INT32__INT16__INT8_INT32_EQ_LONG_INTPTR_EQ_INT+4+2__int20____int20+1+0__STDINT_EXP(x)_SYS__INTSUP_H__GNUC_PREREQ (3, 2)push_macro("signed")push_macro("unsigned")push_macro("char")push_macro("short")push_macro("__int20")push_macro("__int20__")push_macro("int")push_macro("long")(__INTPTR_TYPE__ == 8 || __INTPTR_TYPE__ == 10)(__INTPTR_TYPE__ == 4 || __INTPTR_TYPE__ == 6)__INTPTR_TYPE__ == 2(__INTPTR_TYPE__ == 1 || __INTPTR_TYPE__ == 3)(__INT32_TYPE__ == 4 || __INT32_TYPE__ == 6)__INT32_TYPE__ == 2(__INT8_TYPE__ == 0)(__INT8_TYPE__ == 1 || __INT8_TYPE__ == 3)(__INT8_TYPE__ == 2)(__INT8_TYPE__ == 4 || __INT8_TYPE__ == 6)(__INT8_TYPE__ == 8 || __INT8_TYPE__ == 10)(__INT16_TYPE__ == 1 || __INT16_TYPE__ == 3)(__INT16_TYPE__ == 2)(__INT16_TYPE__ == 4 || __INT16_TYPE__ == 6)(__INT16_TYPE__ == 8 || __INT16_TYPE__ == 10)(__INT32_TYPE__ == 2)(__INT32_TYPE__ == 8 || __INT32_TYPE__ == 10)(__INT64_TYPE__ == 2)(__INT64_TYPE__ == 4 || __INT64_TYPE__ == 6)(__INT64_TYPE__ == 8 || __INT64_TYPE__ == 10)(__INT_FAST8_TYPE__ == 0)(__INT_FAST8_TYPE__ == 1 || __INT_FAST8_TYPE__ == 3)(__INT_FAST8_TYPE__ == 2)(__INT_FAST8_TYPE__ == 4 || __INT_FAST8_TYPE__ == 6)(__INT_FAST8_TYPE__ == 8 || __INT_FAST8_TYPE__ == 10)(__INT_FAST16_TYPE__ == 1 || __INT_FAST16_TYPE__ == 3)(__INT_FAST16_TYPE__ == 2)(__INT_FAST16_TYPE__ == 4 || __INT_FAST16_TYPE__ == 6)(__INT_FAST16_TYPE__ == 8 || __INT_FAST16_TYPE__ == 10)(__INT_FAST32_TYPE__ == 2)(__INT_FAST32_TYPE__ == 4 || __INT_FAST32_TYPE__ == 6)(__INT_FAST32_TYPE__ == 8 || __INT_FAST32_TYPE__ == 10)(__INT_FAST64_TYPE__ == 2)(__INT_FAST64_TYPE__ == 4 || __INT_FAST64_TYPE__ == 6)(__INT_FAST64_TYPE__ == 8 || __INT_FAST64_TYPE__ == 10)(__INT_LEAST8_TYPE__ == 0)(__INT_LEAST8_TYPE__ == 1 || __INT_LEAST8_TYPE__ == 3)(__INT_LEAST8_TYPE__ == 2)(__INT_LEAST8_TYPE__ == 4 || __INT_LEAST8_TYPE__ == 6)(__INT_LEAST8_TYPE__ == 8 || __INT_LEAST8_TYPE__ == 10)(__INT_LEAST16_TYPE__ == 1 || __INT_LEAST16_TYPE__ == 3)(__INT_LEAST16_TYPE__ == 2)(__INT_LEAST16_TYPE__ == 4 || __INT_LEAST16_TYPE__ == 6)(__INT_LEAST16_TYPE__ == 8 || __INT_LEAST16_TYPE__ == 10)(__INT_LEAST32_TYPE__ == 2)(__INT_LEAST32_TYPE__ == 4 || __INT_LEAST32_TYPE__ == 6)(__INT_LEAST32_TYPE__ == 8 || __INT_LEAST32_TYPE__ == 10)(__INT_LEAST64_TYPE__ == 2)(__INT_LEAST64_TYPE__ == 4 || __INT_LEAST64_TYPE__ == 6)(__INT_LEAST64_TYPE__ == 8 || __INT_LEAST64_TYPE__ == 10)pop_macro("signed")pop_macro("unsigned")pop_macro("char")pop_macro("short")pop_macro("__int20")pop_macro("__int20__")pop_macro("int")pop_macro("long")__INT_FAST64_TYPE____INT_FAST32_TYPE____INT_FAST16_TYPE____INT_FAST8_TYPE__/* _SYS__INTSUP_H *//* Nothing to define because int32_t is safe to print as an int. *//* Note - the tests for _INTPTR_EQ_INT and _INTPTR_EQ_SHORT are currently
   redundant as the values are not used.  But one day they may be needed
   and so the tests remain.  *//* Determine how intptr_t and intN_t fastN_t and leastN_t are defined by gcc
   for this target.  This is used to determine the correct printf() constant in
   inttypes.h and other  constants in stdint.h.
   So we end up with
   ?(signed|unsigned) char == 0
   ?(signed|unsigned) short == 1
   ?(signed|unsigned) int == 2
   ?(signed|unsigned) short int == 3
   ?(signed|unsigned) long == 4
   ?(signed|unsigned) long int == 6
   ?(signed|unsigned) long long == 8
   ?(signed|unsigned) long long int == 10
 *//* gcc > 3.2 implicitly defines the values we are interested *//*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */<machine/_default_types.h>uintptr_tintptr_tuintmax_tintmax_tuint64_tint64_tuint32_tint32_tuint16_tint16_tuint8_tint8_t_UINTPTR_T_DECLARED_INTPTR_T_DECLARED_UINTMAX_T_DECLARED_INTMAX_T_DECLARED__int64_t_defined_UINT64_T_DECLARED_INT64_T_DECLARED__int32_t_defined_UINT32_T_DECLARED_INT32_T_DECLARED__int16_t_defined_UINT16_T_DECLARED_INT16_T_DECLARED__int8_t_defined_UINT8_T_DECLARED_INT8_T_DECLARED_SYS__STDINT_H/* _SYS__STDINT_H *//* ___int64_t_defined *//* ___int32_t_defined *//* ___int16_t_defined *//* ___int8_t_defined */<sys/_stdint.h><sys/_intsup.h>uint_fast64_tint_fast64_tuint_fast32_tint_fast32_tuint_fast16_tint_fast16_tuint_fast8_tint_fast8_tuint_least64_tint_least64_tuint_least32_tint_least32_tuint_least16_tint_least16_tuint_least8_tint_least8_tUINTMAX_C(x)__UINTMAX_C(x)INTMAX_C(x)__INTMAX_C(x)UINT64_C(x)__UINT64_C(x)INT64_C(x)__INT64_C(x)UINT32_C(x)__UINT32_C(x)INT32_C(x)__INT32_C(x)UINT16_C(x)__UINT16_C(x)INT16_C(x)__INT16_C(x)UINT8_C(x)__UINT8_C(x)INT8_C(x)__INT8_C(x)WINT_MIN(__WINT_MIN__)WINT_MAX(__WINT_MAX__)WCHAR_MAX(__WCHAR_MAX__)WCHAR_MIN(__WCHAR_MIN__)PTRDIFF_MIN(-PTRDIFF_MAX - 1)PTRDIFF_MAX(__PTRDIFF_MAX__)SIG_ATOMIC_MAX(__STDINT_EXP(INT_MAX))SIG_ATOMIC_MIN(-__STDINT_EXP(INT_MAX) - 1)SIZE_MAX(__SIZE_MAX__)UINTMAX_MAX(__UINTMAX_MAX__)INTMAX_MIN(-INTMAX_MAX - 1)INTMAX_MAX(__INTMAX_MAX__)UINT_FAST64_MAX(__UINT_FAST64_MAX__)INT_FAST64_MAX(__INT_FAST64_MAX__)INT_FAST64_MIN(-__INT_FAST64_MAX__ - 1)UINT_FAST32_MAX(__UINT_FAST32_MAX__)INT_FAST32_MAX(__INT_FAST32_MAX__)INT_FAST32_MIN(-__INT_FAST32_MAX__ - 1)UINT_FAST16_MAX(__UINT_FAST16_MAX__)INT_FAST16_MAX(__INT_FAST16_MAX__)INT_FAST16_MIN(-__INT_FAST16_MAX__ - 1)UINT_FAST8_MAX(__UINT_FAST8_MAX__)INT_FAST8_MAX(__INT_FAST8_MAX__)INT_FAST8_MIN(-__INT_FAST8_MAX__ - 1)UINT_LEAST64_MAX(__UINT_LEAST64_MAX__)INT_LEAST64_MAX(__INT_LEAST64_MAX__)INT_LEAST64_MIN(-__INT_LEAST64_MAX__ - 1)UINT64_MAX(__UINT64_MAX__)INT64_MAX(__INT64_MAX__)INT64_MIN(-__INT64_MAX__ - 1)UINT_LEAST32_MAX(__UINT_LEAST32_MAX__)INT_LEAST32_MAX(__INT_LEAST32_MAX__)INT_LEAST32_MIN(-__INT_LEAST32_MAX__ - 1)UINT32_MAX(__UINT32_MAX__)INT32_MAX(__INT32_MAX__)INT32_MIN(-__INT32_MAX__ - 1)UINT_LEAST16_MAX(__UINT_LEAST16_MAX__)INT_LEAST16_MAX(__INT_LEAST16_MAX__)INT_LEAST16_MIN(-__INT_LEAST16_MAX__ - 1)UINT16_MAX(__UINT16_MAX__)INT16_MAX(__INT16_MAX__)INT16_MIN(-__INT16_MAX__ - 1)UINT_LEAST8_MAX(__UINT_LEAST8_MAX__)INT_LEAST8_MAX(__INT_LEAST8_MAX__)INT_LEAST8_MIN(-__INT_LEAST8_MAX__ - 1)UINT8_MAX(__UINT8_MAX__)INT8_MAX(__INT8_MAX__)INT8_MIN(-__INT8_MAX__ - 1)UINTPTR_MAX(__UINTPTR_MAX__)INTPTR_MAX(__INTPTR_MAX__)INTPTR_MIN(-__INTPTR_MAX__ - 1)__int_fast64_t_defined__int_fast32_t_defined__int_fast16_t_defined__int_fast8_t_defined__int_least64_t_defined__int_least32_t_defined__int_least16_t_defined__int_least8_t_defined_STDINT_H__STDINT_EXP(INT_MAX) >= 0x7f__STDINT_EXP(INT_MAX) >= 0x7fff__STDINT_EXP(INT_MAX) >= 0x7fffffff__STDINT_EXP(INT_MAX) > 0x7fffffff!__int_fast8_t_defined!__int_fast16_t_defined!__int_fast32_t_defined!__int_fast64_t_defined__UINTPTR_MAX____INT8_MAX__defined(__int8_t_defined)__INT_LEAST8_MAX__defined(__int_least8_t_defined)__INT16_MAX__defined(__int16_t_defined)__INT_LEAST16_MAX__defined(__int_least16_t_defined)__INT32_MAX__defined(__int32_t_defined)defined (_INT32_EQ_LONG)__INT_LEAST32_MAX__defined(__int_least32_t_defined)__INT64_MAX__defined(__int64_t_defined)__have_long64__INT_LEAST64_MAX__defined(__int_least64_t_defined)__INT_FAST8_MAX__defined(__int_fast8_t_defined)__INT_FAST16_MAX__defined(__int_fast16_t_defined)__INT_FAST32_MAX__defined(__int_fast32_t_defined)__INT_FAST64_MAX__defined(__int_fast64_t_defined)__INTMAX_MAX____UINTMAX_MAX____SIZE_MAX____PTRDIFF_MAX____WCHAR_MIN__defined(__WCHAR_UNSIGNED__) || (L'\0' - 1 > 0)__WCHAR_MAX____WINT_MAX____WINT_MIN____INT8_C__STDINT_EXP(INT_MAX) > 0x7f__INT16_C__STDINT_EXP(INT_MAX) > 0x7fff__INT32_C__INT64_C__INTMAX_C__INTMAX_C(c)c ## LL__INT64_C(c)__INT32_C(c)c ## L__INT16_C(c)c__INT8_C(c)0U0xffffffffU0x7fffffff0xffffffffffffffffULL0x7fff0x7f__UINT_FAST64_TYPE____UINT_FAST32_TYPE____UINT_FAST16_TYPE____UINT_FAST8_TYPE__/* _STDINT_H *//** Macros for greatest-width integer constant expression *//** Macros for minimum-width integer constant expressions *//* wint_t is unsigned int on almost all GCC targets.  *//* This must match definition in <wchar.h> *//* This must match ptrdiff_t  in <stddef.h> (currently long int) *//* This must match sig_atomic_t in <signal.h> (currently int) *//* This must match size_t in stddef.h, currently long unsigned int *//* All relevant GCC versions prefer long to long long for intmax_t.  *//* Limits of Specified-Width Integer Types *//*
 * Fallback to hardcoded values, 
 * should be valid on cpu's with 32bit int/32bit void*
 *//*
 * Fall back to [u]int_least<N>_t for [u]int_fast<N>_t types
 * not having been defined, yet.
 * Leave undefined, if [u]int_least<N>_t should not be available.
 *//*
 * Fastest minimum-width integer types
 *
 * Assume int to be the fastest type for all types with a width 
 * less than __INT_MAX__ rsp. INT_MAX
 */<stdint.h>_GCC_WRAP_STDINT_H__STDC_HOSTED__defined __cplusplus && __cplusplus >= 201103L/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/lib/gcc/arm-none-eabi/10.3.1/include/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/lib/gcc/arm-none-eabi/10.3.1/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/lib/gcc/arm-none-eabi/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/lib/gcc/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/lib_RETARGETABLE_LOCKING_UNBUF_STREAM_OPT_WIDE_ORIENT_FSEEK_OPTIMIZATION_FVWRITE_IN_STREAMIO_LDBL_EQ_DBL_HAVE_CC_INHIBIT_LOOP_TO_LIBCALL_HAVE_LONG_DOUBLE_ATEXIT_DYNAMIC_ALLOCHAVE_INITFINI_ARRAY_MB_LEN_MAX_REENT_CHECK_VERIFY_WANT_REGISTER_FINI_WANT_IO_LONG_LONG_WANT_IO_C99_FORMATS__NEWLIB_H__/* !__NEWLIB_H__ *//* #undef _ICONV_FROM_ENCODING_WIN_1258 *//* #undef _ICONV_FROM_ENCODING_WIN_1257 *//* #undef _ICONV_FROM_ENCODING_WIN_1256 *//* #undef _ICONV_FROM_ENCODING_WIN_1255 *//* #undef _ICONV_FROM_ENCODING_WIN_1254 *//* #undef _ICONV_FROM_ENCODING_WIN_1253 *//* #undef _ICONV_FROM_ENCODING_WIN_1252 *//* #undef _ICONV_FROM_ENCODING_WIN_1251 *//* #undef _ICONV_FROM_ENCODING_WIN_1250 *//* #undef _ICONV_FROM_ENCODING_UTF_8 *//* #undef _ICONV_FROM_ENCODING_UTF_16LE *//* #undef _ICONV_FROM_ENCODING_UTF_16BE *//* #undef _ICONV_FROM_ENCODING_UTF_16 *//* #undef _ICONV_FROM_ENCODING_US_ASCII *//* #undef _ICONV_FROM_ENCODING_UCS_4LE *//* #undef _ICONV_FROM_ENCODING_UCS_4BE *//* #undef _ICONV_FROM_ENCODING_UCS_4_INTERNAL *//* #undef _ICONV_FROM_ENCODING_UCS_4 *//* #undef _ICONV_FROM_ENCODING_UCS_2LE *//* #undef _ICONV_FROM_ENCODING_UCS_2BE *//* #undef _ICONV_FROM_ENCODING_UCS_2_INTERNAL *//* #undef _ICONV_FROM_ENCODING_UCS_2 *//* #undef _ICONV_FROM_ENCODING_KOI8_UNI *//* #undef _ICONV_FROM_ENCODING_KOI8_U *//* #undef _ICONV_FROM_ENCODING_KOI8_RU *//* #undef _ICONV_FROM_ENCODING_KOI8_R *//* #undef _ICONV_FROM_ENCODING_ISO_IR_111 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_9 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_8 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_7 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_6 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_5 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_4 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_3 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_2 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_15 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_14 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_13 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_11 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_10 *//* #undef _ICONV_FROM_ENCODING_ISO_8859_1 *//* #undef _ICONV_FROM_ENCODING_EUC_KR *//* #undef _ICONV_FROM_ENCODING_EUC_TW *//* #undef _ICONV_FROM_ENCODING_EUC_JP *//* #undef _ICONV_FROM_ENCODING_CP866 *//* #undef _ICONV_FROM_ENCODING_CP855 *//* #undef _ICONV_FROM_ENCODING_CP852 *//* #undef _ICONV_FROM_ENCODING_CP850 *//* #undef _ICONV_FROM_ENCODING_CP775 *//* #undef _ICONV_FROM_ENCODING_BIG5 *//*
 * Iconv encodings enabled ("from" direction)
 *//* #undef _ICONV_TO_ENCODING_WIN_1258 *//* #undef _ICONV_TO_ENCODING_WIN_1257 *//* #undef _ICONV_TO_ENCODING_WIN_1256 *//* #undef _ICONV_TO_ENCODING_WIN_1255 *//* #undef _ICONV_TO_ENCODING_WIN_1254 *//* #undef _ICONV_TO_ENCODING_WIN_1253 *//* #undef _ICONV_TO_ENCODING_WIN_1252 *//* #undef _ICONV_TO_ENCODING_WIN_1251 *//* #undef _ICONV_TO_ENCODING_WIN_1250 *//* #undef _ICONV_TO_ENCODING_UTF_8 *//* #undef _ICONV_TO_ENCODING_UTF_16LE *//* #undef _ICONV_TO_ENCODING_UTF_16BE *//* #undef _ICONV_TO_ENCODING_UTF_16 *//* #undef _ICONV_TO_ENCODING_US_ASCII *//* #undef _ICONV_TO_ENCODING_UCS_4LE *//* #undef _ICONV_TO_ENCODING_UCS_4BE *//* #undef _ICONV_TO_ENCODING_UCS_4_INTERNAL *//* #undef _ICONV_TO_ENCODING_UCS_4 *//* #undef _ICONV_TO_ENCODING_UCS_2LE *//* #undef _ICONV_TO_ENCODING_UCS_2BE *//* #undef _ICONV_TO_ENCODING_UCS_2_INTERNAL *//* #undef _ICONV_TO_ENCODING_UCS_2 *//* #undef _ICONV_TO_ENCODING_KOI8_UNI *//* #undef _ICONV_TO_ENCODING_KOI8_U *//* #undef _ICONV_TO_ENCODING_KOI8_RU *//* #undef _ICONV_TO_ENCODING_KOI8_R *//* #undef _ICONV_TO_ENCODING_ISO_IR_111 *//* #undef _ICONV_TO_ENCODING_ISO_8859_9 *//* #undef _ICONV_TO_ENCODING_ISO_8859_8 *//* #undef _ICONV_TO_ENCODING_ISO_8859_7 *//* #undef _ICONV_TO_ENCODING_ISO_8859_6 *//* #undef _ICONV_TO_ENCODING_ISO_8859_5 *//* #undef _ICONV_TO_ENCODING_ISO_8859_4 *//* #undef _ICONV_TO_ENCODING_ISO_8859_3 *//* #undef _ICONV_TO_ENCODING_ISO_8859_2 *//* #undef _ICONV_TO_ENCODING_ISO_8859_15 *//* #undef _ICONV_TO_ENCODING_ISO_8859_14 *//* #undef _ICONV_TO_ENCODING_ISO_8859_13 *//* #undef _ICONV_TO_ENCODING_ISO_8859_11 *//* #undef _ICONV_TO_ENCODING_ISO_8859_10 *//* #undef _ICONV_TO_ENCODING_ISO_8859_1 *//* #undef _ICONV_TO_ENCODING_EUC_KR *//* #undef _ICONV_TO_ENCODING_EUC_TW *//* #undef _ICONV_TO_ENCODING_EUC_JP *//* #undef _ICONV_TO_ENCODING_CP866 *//* #undef _ICONV_TO_ENCODING_CP855 *//* #undef _ICONV_TO_ENCODING_CP852 *//* #undef _ICONV_TO_ENCODING_CP850 *//* #undef _ICONV_TO_ENCODING_CP775 *//* #undef _ICONV_TO_ENCODING_BIG5 *//*
 * Iconv encodings enabled ("to" direction)
 *//* #undef _WANT_USE_LONG_TIME_T *//* Define to use type long for time_t.  *//* Define if using retargetable functions for default lock routines.  *//* #undef _NANO_FORMATTED_IO *//* Define if small footprint nano-formatted-IO implementation used.  *//* #undef _WANT_REENT_GLOBAL_STDIO_STREAMS *//* Define to move the stdio stream FILE objects out of struct _reent and make
   them global.  The stdio stream pointers of struct _reent are initialized to
   point to the global stdio FILE stream objects. *//* #undef _REENT_GLOBAL_ATEXIT *//* Define if declare atexit data as global.  *//* #undef _LITE_EXIT *//* Define if lite version of exit supported.  *//* Define if unbuffered stream file optimization is supported.  *//* Define if wide char orientation is supported.  *//* Define if fseek functions support seek optimization.  *//* Define if ivo supported in streamio.  *//* True if long double supported and it is equal to double.  *//* Define if compiler supports -fno-tree-loop-distribute-patterns. *//* True if long double supported.  *//* True if atexit() may dynamically allocate space for cleanup
   functions.  *//* Define if the linker supports .preinit_array/.init_array/.fini_array
 * sections.  *//* #undef _ICONV_ENABLE_EXTERNAL_CCS *//* Enable ICONV external CCS files loading capabilities *//* #undef _ICONV_ENABLED *//* ICONV enabled *//* MB_LEN_MAX *//* #undef _MB_CAPABLE *//* Multibyte supported *//* Verify _REENT_CHECK macros allocate memory successfully. *//* #undef _WANT_REENT_SMALL *//* Optional reentrant struct support.  Used mostly on platforms with
   very restricted storage.  *//* #undef _WANT_IO_POS_ARGS *//* Positional argument support in printf functions enabled.  *//* #undef _WANT_IO_LONG_DOUBLE *//* long double type support in IO functions like printf/scanf enabled *//* Register application finalization function using atexit. *//* long long type support in IO functions like printf/scanf enabled *//* C99 formats support (such as %a, %zu, ...) in IO functions like
 * printf/scanf enabled *//* Newlib version *//* #undef _ELIX_LEVEL *//* EL/IX level *//* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  *//* newlib.h.  Generated from newlib.hin by configure.  */__OBSOLETE_MATH__OBSOLETE_MATH_DEFAULT__IEEE_LITTLE_ENDIAN__IEEE_BIG_ENDIAN(defined(__arm__) || defined(__thumb__)) && !defined(__MAVERICK__)__VFP_FP____ARMEL____ARM_FP & 0x8__SOFTFP__defined (__aarch64__)defined (__AARCH64EL__)__ARM_FP__epiphany____hppa____nds32____big_endian____SPU____sparc____LITTLE_ENDIAN_DATA__defined(__m68k__) || defined(__mc68000__)defined(__mc68hc11__) || defined(__mc68hc12__) || defined(__mc68hc1x__)__HAVE_SHORT_DOUBLE__defined (__H8300__) || defined (__H8300H__) || defined (__H8300S__) || defined (__H8500__) || defined (__H8300SX__)defined (__xc16x__) || defined (__xc16xL__) || defined (__xc16xS__)__sh____LITTLE_ENDIAN__defined(__SH2E__) || defined(__SH3E__) || defined(__SH4_SINGLE_ONLY__) || defined(__SH2A_SINGLE_ONLY__)_AM29K_WIN32__i386____riscvdefined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)__riscv_flen__i960____lm32____M32R____nvptx__defined(_C4x) || defined(_C3x)__TMS320C6X___BIG_ENDIAN__TIC80____MIPSEL____MIPSEB____MMIX____D30V____W65__defined(__Z8001__) || defined(__Z8002__)__m88k____mn10300____mn10200____v800__v850__D10V____DOUBLE__ == 32__PPC__(defined(_BIG_ENDIAN) && _BIG_ENDIAN) || (defined(_AIX) && _AIX)(defined(_LITTLE_ENDIAN) && _LITTLE_ENDIAN) || (defined(__sun__) && __sun__) || (defined(_WIN32) && _WIN32)__xstormy16____arc____CRX____CSKY____CSKYBE____fr30____FT32____mcore____mt____frv____moxie____MOXIE_BIG_ENDIAN____ia64____BIG_ENDIAN____AVR__defined(__or1k__) || defined(__OR1K__) || defined(__OR1KND__)__IP2K____iq2000____MAVERICK____m32c____CRIS____BFIN____x86_64____mep____MICROBLAZE____MICROBLAZEEL____MSP430____PRU____RL78____RL78_64BIT_DOUBLES____RX____RX_BIG_ENDIAN____RX_64BIT_DOUBLES____RX_16BIT_INTS__(defined(__CR16__) || defined(__CR16C__) ||defined(__CR16CP__))__NIOS2____nios2_big_endian____VISIUM____AMDGCN____XTENSA_EL____thumb____arm__/* not __IEEE_BIG_ENDIAN *//* not __IEEE_LITTLE_ENDIAN *//* Use old math code by default.  *//* 16 Bit INT *//* __MAVERICK__ *//* __ARMEL__ *//* must be __ARMEB__ *//* necv70 was __IEEE_LITTLE_ENDIAN. *//*
 * Macros for use in ieeefp.h. We can't just define the real ones here
 * (like those above) as we have name space issues when this is *not*
 * included via generic the ieeefp.h.
 *//* ARM traditionally used big-endian words; and within those words the
   byte ordering was big or little endian depending upon the target.
   Modern floating-point formats are naturally ordered; in this case
   __VFP_FP__ will be defined, even if soft-float.  *//* This file can define macros to choose variations of the IEEE float
   format:

   _FLT_LARGEST_EXPONENT_IS_NORMAL

	Defined if the float format uses the largest exponent for finite
	numbers rather than NaN and infinity representations.  Such a
	format cannot represent NaNs or infinities at all, but it's FLT_MAX
	is twice the IEEE value.

   _FLT_NO_DENORMALS

	Defined if the float format does not support IEEE denormals.  Every
	float with a zero exponent is taken to be a zero representation.
 
   ??? At the moment, there are no equivalent macros above for doubles and
   the macros are not fully supported by --enable-newlib-hw-fp.

   __IEEE_BIG_ENDIAN

        Defined if the float format is big endian.  This is mutually exclusive
        with __IEEE_LITTLE_ENDIAN.

   __IEEE_LITTLE_ENDIAN
 
        Defined if the float format is little endian.  This is mutually exclusive
        with __IEEE_BIG_ENDIAN.

   Note that one of __IEEE_BIG_ENDIAN or __IEEE_LITTLE_ENDIAN must be specified for a
   platform or error will occur.

   __IEEE_BYTES_LITTLE_ENDIAN

        This flag is used in conjunction with __IEEE_BIG_ENDIAN to describe a situation 
	whereby multiple words of an IEEE floating point are in big endian order, but the
	words themselves are little endian with respect to the bytes.

   _DOUBLE_IS_32BITS 

        This is used on platforms that support double by using the 32-bit IEEE
        float type.

   _FLOAT_ARG

        This represents what type a float arg is passed as.  It is used when the type is
        not promoted to double.
	

   __OBSOLETE_MATH_DEFAULT

	Default value for __OBSOLETE_MATH if that's not set by the user.
	It should be set here based on predefined feature macros.

   __OBSOLETE_MATH

	If set to 1 then some new math code will be disabled and older libm
	code will be used instead.  This is necessary because the new math
	code does not support all targets, it assumes that the toolchain has
	ISO C99 support (hexfloat literals, standard fenv semantics), the
	target has IEEE-754 conforming binary32 float and binary64 double
	(not mixed endian) representation, standard SNaN representation,
	double and single precision arithmetics has similar latency and it
	has no legacy SVID matherr support, only POSIX errno and fenv
	exception based error handling.
*/<machine/ieeefp.h>_READ_WRITE_BUFSIZE_TYPE_READ_WRITE_RETURN_TYPE__IMPORT__EXPORT__RAND_MAX_POINTER_INT__SYS_CONFIG_H____aarch64__defined(__H8500__) || defined(__W65__)defined(__Z8001__) || defined(__Z8002__) || defined(__H8500__) || defined(__W65__) || defined (__mn10200__) || defined (__AVR__) || defined (__MSP430__)defined (__H8300__) || defined (__H8300H__) || defined(__H8300S__) || defined (__H8300SX__)__INT32__defined(__D10V__)defined(__m68k__) || defined(__mc68000__) || defined(__riscv)___AM29K____unix__defined(__linux__) || defined(__RDOS__)defined(__v850) && !defined(__rtems__)defined(__PPC__)defined(_CALL_SYSV)__SPE__defined (__MICROBLAZE__)_REENT_SMALLdefined(__mips__) && !defined(__rtems__)defined __MSP430____MSP430X_LARGE__defined(__r8c_cpu__) || defined(__m16c_cpu__)defined(__or1k__) || defined(__or1knd__)__INT_MAX__INT_MAXdefined (__alpha__) || (defined (__sparc__) && defined(__arch64__)) \__INT_MAX__ == 32767defined(__CYGWIN__)defined(__rtems__)__INT_MAX__ == 32767 || defined (_WIN32)_WANT_REENT_SMALL_WANT_REENT_GLOBAL_STDIO_STREAMS_REENT_GLOBAL_STDIO_STREAMS_WANT_USE_LONG_TIME_T_USE_LONG_TIME_T_MB_EXTENDED_CHARSETS_ALL/* __SYS_CONFIG_H__ *//* If _MB_EXTENDED_CHARSETS_ALL is set, we want all of the extended
   charsets.  The extended charsets add a few functions and a couple
   of tables of a few K each. *//* See if small reent asked for at configuration time and
   is not chosen by the platform by default.  *//* Define `count' parameter of read/write routines.  In POSIX, the `count'
   parameter is "size_t" but legacy newlib code has been using "int" for some
   time.  If not specified, "int" is defaulted.  *//* Define return type of read/write routines.  In POSIX, the return type
   for read()/write() is "ssize_t" but legacy newlib code has been using
   "int" for some time.  If not specified, "int" is defaulted.  *//* End of block that should be kept in sync with GCC's limits.h.  *//* __alpha__ || sparc64 *//* This block should be kept in sync with GCC's limits.h.  The point
   of having these definitions here is to not include limits.h, which
   would pollute the user namespace, while still using types of the
   the correct widths when deciding how to define __int32_t and
   __int64_t.  *//* __m32c__ *//* Xilinx XMK uses Unix98 mutex *//* Configure small REENT structure for Xilinx MicroBlaze platforms *//* For the PowerPC eabi, force the _impure_ptr to be in .sdata *//* we use some glibc header files so turn on glibc large file feature *//* we want the reentrancy structure to be returned by a function *//* in other words, go32 *//* CR16C *//* INT32 *//* 16 bit integer machines *//* ???  This conditional is true for the h8500 and the w65, defining H8300
   in those cases probably isn't the right thing to do.  *//* exceptions first *//* POSIX defs *//* floating point macros */<sys/config.h><newlib.h>_NOINLINE_STATIC_NOINLINE static_NOINLINE__attribute__ ((__noinline__))_ELIDABLE_INLINEstatic __inline___ATTRIBUTE(attrs)__attribute__ (attrs)_LONG_DOUBLE_NOTHROW_END_STD_C_BEGIN_STD_C_ANSIDECL_H_!(defined(_BEGIN_STD_C) && defined(_END_STD_C))_HAVE_STD_CXXdefined(__GNUC__) && !defined(__GNUC_STDC_INLINE__)__GNUC_PREREQ (3, 1)__GNUC_STDC_INLINE__/* _ANSIDECL_H_ *//* On non-GNU compilers and GCC prior to version 3.1 the compiler can't be
   trusted not to inline if it is static. *//* We're using GCC in C99 mode, or an unknown compiler which
  we just have to hope obeys the C99 semantics of inline.  *//* We're using GCC, but without the new C99-compatible behaviour.  *//*  The traditional meaning of 'extern inline' for GCC is not
  to emit the function body unless the address is explicitly
  taken.  However this behaviour is changing to match the C99
  standard, which uses 'extern inline' to indicate that the
  function body *must* be emitted.  Likewise, a function declared
  without either 'extern' or 'static' defaults to extern linkage
  (C99 6.2.2p5), and the compiler may choose whether to use the
  inline version or call the extern linkage version (6.7.4p6).
  If we are using GCC, but do not have the new behaviour, we need
  to use extern inline; if we are using a new GCC with the
  C99-compatible behaviour, or a non-GCC compiler (which we will
  have to hope is C99, since there is no other way to achieve the
  effect of omitting the function if it isn't referenced) we use
  'static inline', which c99 defines to mean more-or-less the same
  as the Gnu C 'extern inline'.  *//* Support gcc's __attribute__ facility.  *//*  ISO C++.  *//* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  *//* Provide support for both ANSI and non-ANSI environments.  */size_t__need_NULLNULL((void *)0)__need_size_t__size_t_SIZET__GCC_SIZE_T___int_size_t_h_SIZE_T_DECLARED_BSD_SIZE_T_DEFINED__SIZE_T_DEFINED_SIZE_T_DEFINED__BSD_SIZE_T__SIZE_T___SIZE_T_T_SIZE_T_SIZE__SYS_SIZE_T_H_SIZE_T__SIZE_T____size_t__(!defined(_STDDEF_H) && !defined(_STDDEF_H_) && !defined(_ANSI_STDDEF_H) \(!defined(__need_wchar_t) && !defined(__need_size_t)	\__sys_stdtypes_hdefined(__NetBSD__)defined (__FreeBSD__)!defined(_SIZE_T_) && !defined(_BSD_SIZE_T_)!defined(_PTRDIFF_T_) && !defined(_BSD_PTRDIFF_T_)!defined(_WCHAR_T_) && !defined(_BSD_WCHAR_T_)_BSD_WCHAR_T_defined (__need_ptrdiff_t) || defined (_STDDEF_H_)defined (__need_size_t) || defined (_STDDEF_H_)defined (__need_wchar_t) || defined (_STDDEF_H_)defined (__sequent__) && defined (_PTRDIFF_T_)defined (_TYPE_ptrdiff_t) && (defined (__need_ptrdiff_t) || defined (_STDDEF_H_))defined (_TYPE_size_t) && (defined (__need_size_t) || defined (_STDDEF_H_))defined (_TYPE_wchar_t) && (defined (__need_wchar_t) || defined (_STDDEF_H_))defined (_STDDEF_H) || defined (__need_ptrdiff_t)_PTRDIFF_T_T_PTRDIFF__T_PTRDIFF__PTRDIFF_T_PTRDIFF_T__BSD_PTRDIFF_T____int_ptrdiff_t_h_GCC_PTRDIFF_T_PTRDIFF_T_DECLARED__PTRDIFF_TYPE__defined (_STDDEF_H) || defined (__need_size_t)defined (__FreeBSD__) \__SIZE_TYPE__!(defined (__GNUG__) && defined (size_t))__BEOS__defined (_STDDEF_H) || defined (__need_wchar_t)__wchar_t____WCHAR_T___WCHAR_T_T_WCHAR__T_WCHAR__WCHAR_T_WCHAR_T__BSD_WCHAR_T_DEFINED__BSD_RUNE_T_DEFINED__WCHAR_T_DECLARED_WCHAR_T_DEFINED__WCHAR_T_DEFINED_WCHAR_T_H___int_wchar_t_h__INT_WCHAR_T_H_GCC_WCHAR_T_BSD_RUNE_T_!defined (_ANSI_SOURCE) && !defined (_POSIX_SOURCE)defined (__FreeBSD__) && (__FreeBSD__ < 5)defined (__FreeBSD__) && (__FreeBSD__ >= 5)_RUNE_T_DECLARED__WCHAR_TYPE__defined (__need_wint_t)_WINT_T__WINT_TYPE___GCC_PTRDIFF_T__GCC_SIZE_T__GCC_WCHAR_T_defined (_STDDEF_H) || defined (__need_NULL)__GNUG___STDDEF_H(defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) \_GCC_MAX_ALIGN_Tdefined(__cplusplus) && __cplusplus >= 201103L_GXX_NULLPTR_T/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before *//* _STDDEF_H was defined this time *//* C++11.  *//* C11 or C++11.  *//* _Float128 is defined as a basic type, so max_align_t must be
     sufficiently aligned for it.  This code must work in C++, so we
     use __float128 here; that is only available on some
     architectures, but only on i386 is extra alignment needed for
     __float128.  *//* Type whose alignment is supported in every context and is at least
   as great as that of any standard type not using alignment
   specifiers.  *//* Offset of member MEMBER in a struct of type TYPE. *//* NULL not defined and <stddef.h> or need NULL.  *//* G++ *//* C++ *//* in case <stdio.h> has defined it. *//* A null pointer constant.  *//* __sys_stdtypes_h *//* __NetBSD__ *//*  The following ones are the real ones.  *//*  The references to _GCC_PTRDIFF_T_, _GCC_SIZE_T_, and _GCC_WCHAR_T_
    are probably typos and should be removed before 2.8 is released.  *//* _STDDEF_H or __need_wchar_t.  *//* __wchar_t__ *//* __WCHAR_T__ *//* _BSD_RUNE_T_DEFINED_ *//* _WCHAR_T_DECLARED *//* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... *//* Why is this file so hard to maintain properly?  In contrast to
   the comment above regarding BSD/386 1.1, on FreeBSD for as long
   as the symbol has existed, _BSD_RUNE_T_ must not stay defined or
   redundant typedefs will occur when stdlib.h is included after this file. *//* Darwin *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." *//* Cray Unicos/Mk *//* BeOS *//* FreeBSD 5 *//* Define this type if we are doing the whole job,
   or if we want this type in particular.  *//* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  *//* _STDDEF_H or __need_size_t.  *//* __size_t__ *//* __SIZE_T__ *//* _SIZE_T *//* _SYS_SIZE_T_H *//* _T_SIZE_ *//* _T_SIZE *//* __SIZE_T *//* _SIZE_T_ *//* _BSD_SIZE_T_ *//* _SIZE_T_DEFINED_ *//* _SIZE_T_DEFINED *//* _BSD_SIZE_T_DEFINED_ *//* _SIZE_T_DECLARED *//* ___int_size_t_h *//* _GCC_SIZE_T *//* _SIZET_ *//* __size_t *//* !(defined (__GNUG__) && defined (size_t)) *//* __BEOS__ *//* __size_t is a typedef, must not trash it.  *//* in case <sys/types.h> has defined it. *//* Unsigned type of `sizeof' something.  *//* _STDDEF_H or __need_ptrdiff_t.  *//* If this symbol has done its job, get rid of it.  *//* _PTRDIFF_T *//* _T_PTRDIFF_ *//* _T_PTRDIFF *//* __PTRDIFF_T *//* _PTRDIFF_T_ *//* _BSD_PTRDIFF_T_ *//* ___int_ptrdiff_t_h *//* _GCC_PTRDIFF_T *//* _PTRDIFF_T_DECLARED *//* DragonFly *//* Signed type of difference of two pointers.  *//* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  *//* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  *//* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  *//* defined(__NetBSD__) *//* Undef _FOO_T_ if we are supposed to define foo_t.  *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_. *//* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  *//* snaroff@next.com says the NeXT needs this.  *//* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  *//*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 *//* Copyright (C) 1989-2020 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */<stddef.h>__pt_guarded_by(x)__lock_annotate(pt_guarded_by(x))__guarded_by(x)__lock_annotate(guarded_by(x))__nosanitizethread__nosanitizeaddress__no_lock_analysis__lock_annotate(no_thread_safety_analysis)__requires_unlocked(__VA_ARGS__...)__lock_annotate(locks_excluded(__VA_ARGS__))__requires_shared(__VA_ARGS__...)__lock_annotate(shared_locks_required(__VA_ARGS__))__requires_exclusive(__VA_ARGS__...)__lock_annotate(exclusive_locks_required(__VA_ARGS__))__asserts_shared(__VA_ARGS__...)__lock_annotate(assert_shared_lock(__VA_ARGS__))__asserts_exclusive(__VA_ARGS__...)__lock_annotate(assert_exclusive_lock(__VA_ARGS__))__unlocks(__VA_ARGS__...)__lock_annotate(unlock_function(__VA_ARGS__))__trylocks_shared(__VA_ARGS__...)__lock_annotate(shared_trylock_function(__VA_ARGS__))__trylocks_exclusive(__VA_ARGS__...)__lock_annotate(exclusive_trylock_function(__VA_ARGS__))__locks_shared(__VA_ARGS__...)__lock_annotate(shared_lock_function(__VA_ARGS__))__locks_exclusive(__VA_ARGS__...)__lock_annotate(exclusive_lock_function(__VA_ARGS__))__lockable__lock_annotate(lockable)__lock_annotate(x)__datatype_type_tag(kind,type)__arg_type_tag(arg_kind,arg_idx,type_tag_idx)__NULLABILITY_PRAGMA_POP__NULLABILITY_PRAGMA_PUSH_Null_unspecified_Nullable_Nonnull__DEQUALIFY(type,var)((type)(__uintptr_t)(const volatile void *)(var))__DEVOLATILE(type,var)((type)(__uintptr_t)(volatile void *)(var))__DECONST(type,var)((type)(__uintptr_t)(const void *)(var))__COPYRIGHT(s)struct __hack__SCCSID(s)__RCSID_SOURCE(s)__RCSID(s)__FBSDID(s)__sym_default(sym,impl,verid)__asm__(".symver " #impl ", " #sym "@@" #verid)__sym_compat(sym,impl,verid)__asm__(".symver " #impl ", " #sym "@" #verid)__warn_references(sym,msg)__asm__(".section .gnu.warning." #sym); __asm__(".asciz \"" msg "\""); __asm__(".previous")__weak_reference(sym,alias)__asm__(".weak " #alias); __asm__(".equ " #alias ", " #sym)__strong_reference(sym,aliassym)extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))__printf0like(fmtarg,firstvararg)__strftimelike(fmtarg,firstvararg)__attribute__((__format__ (__strftime__, fmtarg, firstvararg)))__strfmonlike(fmtarg,firstvararg)__attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))__format_arg(fmtarg)__attribute__((__format_arg__ (fmtarg)))__scanflike(fmtarg,firstvararg)__attribute__((__format__ (__scanf__, fmtarg, firstvararg)))__printflike(fmtarg,firstvararg)__attribute__((__format__ (__printf__, fmtarg, firstvararg)))__containerof(x,s,m)({ const volatile __typeof(((s *)0)->m) *__x = (x); __DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));})__rangeof(type,start,end)(__offsetof(type, end) - __offsetof(type, start))__offsetof(type,field)offsetof(type, field)__hidden__attribute__((__visibility__("hidden")))__exported__attribute__((__visibility__("default")))__null_sentinel__attribute__((__sentinel__))__predict_false(exp)__builtin_expect((exp), 0)__predict_true(exp)__builtin_expect((exp), 1)__restrict__unreachable()__builtin_unreachable()__returns_twice__attribute__((__returns_twice__))__result_use_check__attribute__((__warn_unused_result__))__fastcall__attribute__((__fastcall__))__nonnull_all__attribute__((__nonnull__))__nonnull(x)__attribute__((__nonnull__ x))__noinline__always_inline__inline__ __attribute__((__always_inline__))__pure__attribute__((__pure__))__malloc_like__attribute__((__malloc__))__min_size(x)static (x)__generic(expr,t,yes,no)_Generic(expr, t: yes, default: no)__alloc_align(x)__attribute__((__alloc_align__(x)))__alloc_size2(n,x)__attribute__((__alloc_size__(n, x)))__alloc_size(x)__attribute__((__alloc_size__(x)))__section(x)__attribute__((__section__(x)))__aligned(x)__attribute__((__aligned__(x)))__packed__attribute__((__packed__))__used__attribute__((__used__))__unused__attribute__((__unused__))__pure2__attribute__((__const__))__dead2__attribute__((__noreturn__))__weak_symbol__attribute__((__weak__))__volatile__signed__const__XSTRING(x)__STRING(x)#x__CONCAT(x,y)__CONCAT1(x,y)x ## y__P(protos)protos__CC_SUPPORTS_DYNAMIC_ARRAY_INIT__CC_SUPPORTS_VARADIC_XXX__CC_SUPPORTS_WARNING__CC_SUPPORTS___FUNC____CC_SUPPORTS___INLINE____CC_SUPPORTS___INLINE__CC_SUPPORTS_INLINE__GNUCLIKE_BUILTIN_MEMCPY__GNUCLIKE_MATH_BUILTIN_RELOPS__GNUCLIKE_BUILTIN_NEXT_ARG__compiler_membar()__asm __volatile(" " : : : "memory")__GNUC_VA_LIST_COMPATIBILITY__GNUCLIKE_BUILTIN_VAALIST__GNUCLIKE_BUILTIN_STDARG__GNUCLIKE_BUILTIN_VARARGS__GNUCLIKE_BUILTIN_CONSTANT_P__GNUCLIKE_CTOR_SECTION_HANDLING__GNUCLIKE___SECTION__GNUCLIKE___OFFSETOF__GNUCLIKE___TYPEOF__GNUCLIKE_MATH_BUILTIN_CONSTANTS__GNUCLIKE_ASM__END_DECLS__BEGIN_DECLS__ptrvalue__unbounded__bounded__flexarr[0]__attribute_format_strfmon__(a,b)__attribute_pure____attribute_malloc____long_double_t__ptr_tvoid *__ASMNAME(cname)__XSTRING (__USER_LABEL_PREFIX__) cname__THROW__DOTS, ...__PMT(args)args_SYS_CDEFS_H___BOUNDED_POINTERS____has_attribute__has_extension__has_feature__has_include__has_builtindefined(__cplusplus)defined(__GNUC__) || defined(__INTEL_COMPILER)__GNUC__ >= 3 || defined(__INTEL_COMPILER)__INTEL_COMPILERdefined(__INTEL_COMPILER) && defined(__cplusplus) && \(__GNUC_MINOR__ > 95 || __GNUC__ >= 3)defined(__GNUC__)defined(__STDC__) || defined(__cplusplus)!(defined(__CC_SUPPORTS___INLINE))!defined(__CC_SUPPORTS___INLINE)NO_ANSI_KEYWORDS!__GNUC_PREREQ__(2, 5) && !defined(__INTEL_COMPILER)__GNUC__ == 2 && __GNUC_MINOR__ >= 5 && __GNUC_MINOR__ < 7 && !defined(__INTEL_COMPILER)__GNUC_PREREQ__(2, 7) || defined(__INTEL_COMPILER)__GNUC_PREREQ__(4, 3) || __has_attribute(__alloc_size__)__GNUC_PREREQ__(4, 9) || __has_attribute(__alloc_align__)!__GNUC_PREREQ__(2, 95)!defined(__STDC_VERSION__) || __STDC_VERSION__ < 201112L!__has_extension(c_alignas)(defined(__cplusplus) && __cplusplus >= 201103L) || \!defined(__cplusplus) && !__has_extension(c_atomic) && \!__has_extension(c_static_assert)__GNUC_PREREQ__(4,6) && !defined(__cplusplus)defined(__COUNTER__)!__has_extension(c_thread_local)(defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || \__GNUC_PREREQ__(3, 1) && !defined(__cplusplus)!defined(__cplusplus) && \__GNUC_PREREQ__(2, 96)__GNUC_PREREQ__(3, 1) || (defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 800)__GNUC_PREREQ__(3, 1)__GNUC_PREREQ__(3, 3)__GNUC_PREREQ__(3, 4)__GNUC_PREREQ__(4, 1)__GNUC_PREREQ__(4, 6) || __has_builtin(__builtin_unreachable)!__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER)!(__GNUC__ == 2 && __GNUC_MINOR__ == 95)!defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901__GNUC_PREREQ__(4, 0)defined(__FreeBSD_cc_version) && __FreeBSD_cc_version >= 300001 && \__ELF____STDC____FBSDID__RCSID__RCSID_SOURCE__SCCSID__COPYRIGHT__DECONST__DEVOLATILE__DEQUALIFY!(defined(__clang__) && __has_feature(nullability))__has_attribute(__argument_with_type_tag__) && \__has_extension(c_thread_safety_attributes)__has_attribute(no_sanitize) && defined(__clang__)9695/* !_SYS_CDEFS_H_ *//* Guard variables and structure members by lock. *//*
 * Function or variable should not be sanitized, i.e. by AddressSanitizer.
 * GCC has the nosanitize attribute, but as a function attribute only, and
 * warns on use as a variable attribute.
 *//* Function should not be analyzed. *//* Function requires that an exclusive or shared lock is or is not held. *//* Function asserts that an exclusive or shared lock is held. *//* Function releases a lock. *//* Function attempts to acquire an exclusive or shared lock. *//* Function acquires an exclusive or shared lock. *//* FIXME: Use __lockable__, etc. to avoid colliding with user namespace macros,
 * once clang is fixed: https://bugs.llvm.org/show_bug.cgi?id=34319 *//* Structure implements a lock. *//*
 * Lock annotations.
 *
 * Clang provides support for doing basic thread-safety tests at
 * compile-time, by marking which locks will/should be held when
 * entering/leaving a functions.
 *
 * Furthermore, it is also possible to annotate variables and structure
 * members to enforce that they are only accessed when certain locks are
 * held.
 *//*
 * Type Safety Checking
 *
 * Clang provides additional attributes to enable checking type safety
 * properties that cannot be enforced by the C type system. 
 *//*
 * Nullability qualifiers: currently only supported by Clang.
 *//* __GNUC__ || __INTEL_COMPILER *//* __ELF__ *//* __STDC__ *//* !__ELF__ *//* Compiler-dependent macros that rely on FreeBSD-specific extensions. *//*
 * Compiler-dependent macros to declare that functions take printf-like
 * or scanf-like arguments.  They are null except for versions of gcc
 * that are known to support the features properly (old versions of gcc-2
 * didn't permit keeping the keywords out of the application namespace).
 *//*
 * Given the pointer x to the member m of the struct s, return
 * a pointer to the containing structure.  When using GCC, we first
 * assign pointer x to a local variable, to check that its type is
 * compatible with member m.
 *//* Only default visibility is supported on PE/COFF targets. *//*
 * GNU C version 2.96 adds explicit branch prediction so that
 * the CPU back-end can hint the processor and also so that
 * code blocks can be reordered such that the predicted path
 * sees a more linear flow, thus improving cache behavior, etc.
 *
 * The following two macros provide us with a way to utilize this
 * compiler feature.  Use __predict_true() if you expect the expression
 * to evaluate to true, and __predict_false() if you expect the
 * expression to evaluate to false.
 *
 * A few notes about usage:
 *
 *	* Generally, __predict_false() error condition checks (unless
 *	  you have some _strong_ reason to do otherwise, in which case
 *	  document it), and/or __predict_true() `no-error' condition
 *	  checks, assuming you want to optimize for the no-error case.
 *
 *	* Other than that, if you don't know the likelihood of a test
 *	  succeeding from empirical or other `hard' evidence, don't
 *	  make predictions.
 *
 *	* These are meant to be used in places that are run `a lot'.
 *	  It is wasteful to make predictions in code that is run
 *	  seldomly (e.g. at subsystem initialization time) as the
 *	  basic block reordering that this affects can often generate
 *	  larger code.
 *//*
 * GCC 2.95 provides `__restrict' as an extension to C90 to support the
 * C99-specific `restrict' type qualifier.  We happen to use `__restrict' as
 * a way to define the `restrict' type qualifier without disturbing older
 * software that is unaware of C99 keywords.
 *//* XXX: should use `#if __STDC_VERSION__ < 199901'. *//*
 * C99 Static array indices in function parameter declarations.  Syntax such as:
 * void bar(int myArray[static 10]);
 * is allowed in C99 but not in C++.  Define __min_size appropriately so
 * headers using it can be compiled in either language.  Use like this:
 * void bar(int myArray[__min_size(10)]);
 *//*
 * Emulation of C11 _Generic().  Unlike the previously defined C11
 * keywords, it is not possible to implement this using exactly the same
 * syntax.  Therefore implement something similar under the name
 * __generic().  Unlike _Generic(), this macro can only distinguish
 * between a single type, so it requires nested invocations to
 * distinguish multiple cases.
 *//* __STDC_VERSION__ || __STDC_VERSION__ < 201112L *//* (defined(__cplusplus) && __cplusplus >= 201103L) || *//*
 * XXX: Some compilers (Clang 3.3, GCC 4.7) falsely announce C++11 mode
 * without actually supporting the thread_local keyword. Don't check for
 * the presence of C++11 when defining _Thread_local.
 *//* Nothing, gcc 4.6 and higher has _Static_assert built-in *//*
 * No native support for _Atomic(). Place object in structure to prevent
 * most forms of direct non-atomic access.
 *//* XXX: Only emulates _Alignas(constant-expression); not _Alignas(type-name). *//*
 * Keywords added in C11.
 *//* XXX Find out what to do for __packed, __aligned and __section *//*
 * Compiler-dependent macros to help declare dead (non-returning) and
 * pure (no side effects) functions, and unused variables.  They are
 * null except for versions of gcc that are known to support the features
 * properly (old versions of gcc-2 supported the dead and pure features
 * in a different (wrong) way).  If we do not provide an implementation
 * for a given compiler, let the compile fail if it is told to use
 * a feature that we cannot live without.
 *//* !(__STDC__ || __cplusplus) *//* !__CC_SUPPORTS___INLINE *//* !NO_ANSI_KEYWORDS *//* delete ANSI C keywords *//*
 * In non-ANSI C environments, new programs will want ANSI-only C keywords
 * deleted from the program and old programs will want them left alone.
 * When using a compiler other than gcc, programs using the ANSI C keywords
 * const, inline etc. as normal identifiers should define -DNO_ANSI_KEYWORDS.
 * When using "gcc -traditional", we assume that this is the intent; if
 * __GNUC__ is defined but __STDC__ is not, we leave the new keywords alone.
 *//* delete pseudo-ANSI C keywords *//**//* traditional C preprocessor *//* !__cplusplus *//* ! __CC_SUPPORTS___INLINE *//* delete GCC keyword *//* convert to C++ keyword *//* define reserved names to standard *//* expand x, then stringify *//* stringify without expanding x *//* full-blown ANSI C *//*
 * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
 * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
 * The __CONCAT macro is a bit tricky to use if it must work in non-ANSI
 * mode -- there must be no spaces between its arguments, and for nested
 * __CONCAT's, all the __CONCAT's must be at the left.  __CONCAT can also
 * concatenate double-quoted strings produced by the __STRING macro, but
 * this only works with ANSI C.
 *
 * __XSTRING is like __STRING, but it expands any macros in its argument
 * first.  It is only available with ANSI C.
 *//* see varargs.h *//* XXX: if __GNUC__ >= 2: not tested everywhere originally, where replaced *//*
 * Compiler memory barriers, specific to gcc and clang.
 *//*
 * This code has been put in place to help reduce the addition of
 * compiler specific defines in FreeBSD code.  It helps to aid in
 * having a compiler-agnostic source tree.
 *//*
 * Testing against Clang-specific extensions.
 *//* nothing *//*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 *//* Written 2000 by Werner Almesberger *//* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */max_align_tstruct <unnamed>ptrdiff_t__max_align_ld__alignof__(long double)aligned__max_align_ll__alignof__(long long)offsetof(TYPE,MEMBER)__builtin_offsetof (TYPE, MEMBER)__need_wchar_t__need_ptrdiff_t_ANSI_STDDEF_H_STDDEF_H___gnuc_va_list__GNUC_VA_LIST__need___va_list_STDARG_H_ANSI_STDARG_H_!defined(__STRICT_ANSI__) || __STDC_VERSION__ + 0 >= 199900L \_BSD_VA_LISTdefined(__svr4__) || (defined(_SCO_DS) && !defined(__VA_LIST))_VA_LIST___i860___VA_LIST_SCO_DS!defined (_VA_LIST_) || defined (__BSD_NET2__) || defined (____386BSD____) || defined (__bsdi__) || defined (__sequent__) || defined (__FreeBSD__) || defined(WINNT)_VA_LIST_DEFINED_VA_LIST_T_H__va_list__!(defined (__BSD_NET2__) || defined (____386BSD____) || defined (__bsdi__) || defined (__sequent__) || defined (__FreeBSD__))/* not _STDARG_H *//* not _ANSI_STDARG_H_ *//* _STDARG_H *//* not __svr4__ *//* not _VA_LIST_, except on certain systems *//* not _VA_LIST_DEFINED *//* not _VA_LIST *//* not _VA_LIST_T_H *//* not __va_list__ *//* The macro __va_list__ is used by BeOS.  *//* The macro _VA_LIST_T_H is used in the Bull dpx2  *//* The macro _VA_LIST is used in SCO Unix 3.2.  *//* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  *//* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  *//* not __svr4__ || _SCO_DS *//* _VA_LIST_ *//* __i860__ *//* SVR4.2 uses _VA_LIST for an internal alias for va_list,
   so we must avoid testing it and setting it here.
   SVR4 uses _VA_LIST as a flag in stdarg.h, but we should
   have no conflict with that.  *//* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type, 
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  *//* Define va_list, if desired, from __gnuc_va_list. *//* Define the standard macros for the user,
   if this invocation was from the user program.  *//* Define __gnuc_va_list.  *//* not __need___va_list *//*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */wint_t__need_wint_t_MACHINE__TYPES_H<machine/_types.h>__va_list__useconds_t__suseconds_t__nlink_t__nl_item__socklen_t__sa_family_t__timer_t__clockid_t__time_t__clock_t_iconv_t_mbstate_tunion <unnamed>__ssize_t_ssize_t_fpos_t__key_t__loff_t__off_t_off64_t__mode_t__ino_t__id_t__gid_t__uid_t__dev_t__pid_t_off_t__fsfilcnt_t__fsblkcnt_t__blksize_t__blkcnt_t__value__countunsigned char[4]__wchb__wch_TIMER_T__CLOCKID_T__TIME_T__CLOCK_T__SYS__TYPES_H__machine_blkcnt_t_defined__machine_blksize_t_defined__machine_fsblkcnt_t_defined__machine_fsfilcnt_t_defined__machine_off_t_defineddefined(__XMK__)__machine_dev_t_defined__machine_uid_t_defined__machine_gid_t_defined__machine_id_t_defined__machine_ino_t_defined(defined(__i386__) && (defined(GO32) || defined(__MSDOS__))) || \__machine_mode_t_defineddefined(__i386__) && (defined(GO32) || defined(__MSDOS__))defined(__sparc__) && !defined(__sparc_v9__)__machine_off64_t_defineddefined(__CYGWIN__) && !defined(__LP64__)__machine_key_t_defined__machine_fpos_t_defined__LARGE64_FILES__machine_fpos64_t_defined__machine_size_t_defineddefined(__INT_MAX__) && __INT_MAX__ == 2147483647__machine_ssize_t_defined__machine_mbstate_t_defined__machine_iconv_t_defined__machine_clock_t_defineddefined(_USE_LONG_TIME_T) || __LONG_MAX__ > 0x7fffffffL__machine_clockid_t_defined__machine_sa_family_t_defined__machine_socklen_t_defined__GNUC_MINOR__ > 95 || __GNUC__ >= 3/* _SYS__TYPES_H *//*
 * Must be identical to the __GNUCLIKE_BUILTIN_VAALIST definition in
 * <sys/cdefs.h>.  The <sys/cdefs.h> must not be included here to avoid cyclic
 * header dependencies.
 *//* microseconds (unsigned) *//* microseconds (signed) *//* clock() *//* Iconv descriptor type *//* Value so far.  *//* Conversion state information.  *//* If __SIZE_TYPE__ is defined (gcc) we define ssize_t based on size_t.
   We simply change "unsigned" to "signed" for this single definition
   to make sure ssize_t and size_t only differ by their signedness. *//* Defined by GCC provided <stddef.h> *//* (and must be `long' for now) *//* XXX must match off_t in <sys/types.h> *//*
 * We need fpos_t for the following, but it doesn't have a leading "_",
 * so we use _fpos_t instead.
 *//* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*//* ANSI C namespace clean utility typedefs */<_ansi.h>__retarget_lock_release_recursive__retarget_lock_release__retarget_lock_try_acquire_recursive__retarget_lock_try_acquire__retarget_lock_acquire_recursive__retarget_lock_acquire__retarget_lock_close_recursive__retarget_lock_close__retarget_lock_init_recursive_LOCK_T *__lock *__lock **__retarget_lock_init_LOCK_T__lock__lock_release_recursive(lock)__retarget_lock_release_recursive(lock)__lock_release(lock)__retarget_lock_release(lock)__lock_try_acquire_recursive(lock)__retarget_lock_try_acquire_recursive(lock)__lock_try_acquire(lock)__retarget_lock_try_acquire(lock)__lock_acquire_recursive(lock)__retarget_lock_acquire_recursive(lock)__lock_acquire(lock)__retarget_lock_acquire(lock)__lock_close_recursive(lock)__retarget_lock_close_recursive(lock)__lock_close(lock)__retarget_lock_close(lock)__lock_init_recursive(lock)__retarget_lock_init_recursive(&lock)__lock_init(lock)__retarget_lock_init(&lock)__LOCK_INIT_RECURSIVE(class,lock)__LOCK_INIT(class,lock)extern struct __lock __lock_ ## lock; class _LOCK_T lock = &__lock_ ## lock_LOCK_RECURSIVE_T__SYS_LOCK_H__!defined(_RETARGETABLE_LOCKING)/* __SYS_LOCK_H__ *//* !defined(_RETARGETABLE_LOCKING) *//* dummy lock routines for single-threaded aps */lock<sys/lock.h><sys/_types.h>_reclaim_reent_reent *__sFILE_reent_glue_rand48__FILE__sbuf_atexit_on_exit_args__tm_Bigint__locale_t_flock_t__ULong_flags2_mbstate_lock_data_offset_blksize_lbunsigned char[1]_nbufunsigned char[3]_ubuf_urunsigned char *_up_ub_close_seek_write_read__FILE[3]__sFILE[3]__sf__sglue__FILE *__sFILE *_iobs_niobs_glue *_next..(**)(..)_sig_func_atexit0_atexit *_new_unusedunsigned int[30]_N_LISTS_nmallocunsigned char *[30]_nextf_h_errno_wcsrtombs_state_wcrtomb_state_mbsrtowcs_state_mbrtowc_state_mbrlen_state_getdate_errchar[24]_REENT_SIGNAL_SIZE_signal_bufchar[8]_l64a_buf_wctomb_state_mbtowc_state_mblen_state_r48_addunsigned short[3]_mult_seed_rand_next_gamma_signgam_localtime_bufchar[26]_REENT_ASCTIME_SIZE_asctime_buf_strtok_last_unused_rand_cvtbuf_cvtlen_Bigint *_Bigint **_freelist_p5s_result_k_result__cleanup__sdidinit__locale_t *_locale_unspecified_locale_infochar[25]_REENT_EMERGENCY_SIZE_emergency_inc_stderr_stdout_stdin_errno_cookie_lbfsize_bf_file_flags_w_r_p_size_base..(*[32])(..)_ATEXIT_SIZE_fns_ind_is_cxa_fntypesvoid *[32]_dso_handle_fnargs__tm_isdst__tm_yday__tm_wday__tm_year__tm_mon__tm_mday__tm_hour__tm_min__tm_sec__ULong[1]unsigned long[1]_x_wds_sign_maxwds_k_reent *const_global_impure_ptr_impure_ptr_GLOBAL_ATEXIT(_GLOBAL_REENT->_atexit)_GLOBAL_REENT_REENT__ATTRIBUTE_IMPURE_PTR___Kmax(sizeof (size_t) << 3)_REENT_INIT_PTR(var){ memset((var), 0, sizeof(*(var))); _REENT_INIT_PTR_ZEROED(var); }_REENT_GETDATE_ERR_P(ptr)(&((ptr)->_new._reent._getdate_err))_REENT_SIGNAL_BUF(ptr)((ptr)->_new._reent._signal_buf)_REENT_L64A_BUF(ptr)((ptr)->_new._reent._l64a_buf)_REENT_WCSRTOMBS_STATE(ptr)((ptr)->_new._reent._wcsrtombs_state)_REENT_WCRTOMB_STATE(ptr)((ptr)->_new._reent._wcrtomb_state)_REENT_MBSRTOWCS_STATE(ptr)((ptr)->_new._reent._mbsrtowcs_state)_REENT_MBRTOWC_STATE(ptr)((ptr)->_new._reent._mbrtowc_state)_REENT_MBRLEN_STATE(ptr)((ptr)->_new._reent._mbrlen_state)_REENT_WCTOMB_STATE(ptr)((ptr)->_new._reent._wctomb_state)_REENT_MBTOWC_STATE(ptr)((ptr)->_new._reent._mbtowc_state)_REENT_MBLEN_STATE(ptr)((ptr)->_new._reent._mblen_state)_REENT_STRTOK_LAST(ptr)((ptr)->_new._reent._strtok_last)_REENT_EMERGENCY(ptr)((ptr)->_emergency)_REENT_TM(ptr)(&(ptr)->_new._reent._localtime_buf)_REENT_ASCTIME_BUF(ptr)((ptr)->_new._reent._asctime_buf)_REENT_MP_FREELIST(ptr)((ptr)->_freelist)_REENT_MP_P5S(ptr)((ptr)->_p5s)_REENT_MP_RESULT_K(ptr)((ptr)->_result_k)_REENT_MP_RESULT(ptr)((ptr)->_result)_REENT_RAND48_ADD(ptr)((ptr)->_new._reent._r48._add)_REENT_RAND48_MULT(ptr)((ptr)->_new._reent._r48._mult)_REENT_RAND48_SEED(ptr)((ptr)->_new._reent._r48._seed)_REENT_RAND_NEXT(ptr)((ptr)->_new._reent._rand_next)_REENT_SIGNGAM(ptr)((ptr)->_new._reent._gamma_signgam)_REENT_CHECK_SIGNAL_BUF(ptr)_REENT_CHECK_MISC(ptr)_REENT_CHECK_EMERGENCY(ptr)_REENT_CHECK_ASCTIME_BUF(ptr)_REENT_CHECK_TM(ptr)_REENT_CHECK_MP(ptr)_REENT_CHECK_RAND48(ptr)_REENT_INIT_PTR_ZEROED(var){ (var)->_stdin = _REENT_STDIO_STREAM(var, 0); (var)->_stdout = _REENT_STDIO_STREAM(var, 1); (var)->_stderr = _REENT_STDIO_STREAM(var, 2); (var)->_new._reent._rand_next = 1; (var)->_new._reent._r48._seed[0] = _RAND48_SEED_0; (var)->_new._reent._r48._seed[1] = _RAND48_SEED_1; (var)->_new._reent._r48._seed[2] = _RAND48_SEED_2; (var)->_new._reent._r48._mult[0] = _RAND48_MULT_0; (var)->_new._reent._r48._mult[1] = _RAND48_MULT_1; (var)->_new._reent._r48._mult[2] = _RAND48_MULT_2; (var)->_new._reent._r48._add = _RAND48_ADD; }_REENT_INIT(var){ 0, _REENT_STDIO_STREAM(&(var), 0), _REENT_STDIO_STREAM(&(var), 1), _REENT_STDIO_STREAM(&(var), 2), 0, "", 0, _NULL, 0, _NULL, _NULL, 0, _NULL, _NULL, 0, _NULL, { { 0, _NULL, "", {0, 0, 0, 0, 0, 0, 0, 0, 0}, 0, 1, { {_RAND48_SEED_0, _RAND48_SEED_1, _RAND48_SEED_2}, {_RAND48_MULT_0, _RAND48_MULT_1, _RAND48_MULT_2}, _RAND48_ADD }, {0, {0}}, {0, {0}}, {0, {0}}, "", "", 0, {0, {0}}, {0, {0}}, {0, {0}}, {0, {0}}, {0, {0}} } }, _REENT_INIT_ATEXIT _NULL, {_NULL, 0, _NULL} }_REENT_STDIO_STREAM(var,index)&(var)->__sf[index]_RAND48_ADD(0x000b)_RAND48_MULT_2(0x0005)_RAND48_MULT_1(0xdeec)_RAND48_MULT_0(0xe66d)_RAND48_SEED_2(0x1234)_RAND48_SEED_1(0xabcd)_RAND48_SEED_0(0x330e)_REENT_SMALL_CHECK_INIT(ptr)_REENT_INIT_ATEXIT_NULL, _ATEXIT_INIT,_ATEXIT_INIT{_NULL, 0, {_NULL}, {{_NULL}, {_NULL}, 0, 0}}__Long_NULL_SYS_REENT_H___LONG_MAX__ == 2147483647L__INT_MAX__ == 2147483647!defined( __Long)__machine_flock_t_defined_REENT_GLOBAL_ATEXITdefined(_REENT_SMALL) && !defined(_REENT_GLOBAL_STDIO_STREAMS)__SINGLE_THREAD____CUSTOM_FILE_IO__defined(__DYNAMIC_REENT__) && !defined(__SINGLE_THREAD__)__getreent/* _SYS_REENT_H_ *//* points to head of LIFO stack *//* __SINGLE_THREAD__ || !__DYNAMIC_REENT__ *//* #define _REENT_ONLY define this to get only reentrant routines *//*
 * All references to struct _reent are via this pointer.
 * Internally, newlib routines that need to reference it should use _REENT.
 *//* This value is used in stdlib/misc.c.  reent/reent.c has to know it
   as well to make sure the freelist is correctly free'd.  Therefore
   we define it here, rather than in stdlib/misc.c, as before. *//* !_REENT_SMALL *//* first three file descriptors *//* root of glue chain *//* These are here last so that __FILE can grow without changing the offsets
     of the above members (on the off chance that future binary compatibility
     would be broken otherwise).  *//* signal info *//* one guaranteed table, required by ANSI *//* atexit stuff *//* Two next two fields were once used by malloc.  They are no longer
     used. They are used to preserve the space used before so as to
     allow addition of new reent fields and keep binary compatibility.   *//* should be size_t *//* used by some fp conversion routines *//* used by mprec routines *//* 1 means stdio has been init'd *//* per-thread locale *//* unused, reserved for locale stuff *//* TODO *//* used by tmpnam *//* FILE is a big struct and may change over time.  To try to achieve binary
     compatibility with future versions, put stdin,stdout,stderr here.
     These are pointers into member __sf defined below.  *//* local copy of errno *//* Handle the dynamically allocated rand48 structure. *//* Generic _REENT check macro.  *//* Specify how to handle reent_check malloc failures. *//* _REENT_GLOBAL_STDIO_STREAMS *//* strsignal *//* strtok, multibyte states *//* file descriptors *//* XXX *//* As an exception to the above put _errno first for binary
     compatibility with non _REENT_SMALL targets.  *//* This version of _reent is laid out with "int"s in pairs, to help
 * ports with 16-bit int's but 32-bit pointers, align nicely.  *//* miscellaneous reentrant data *//*
 * struct _reent
 *
 * This structure contains *all* globals needed by the library.
 * It's raison d'etre is to facilitate threads by making all library routines
 * reentrant.  IE: All state information is contained here.
 *//* How big the some arrays are.  *//* Put this in here as well, for good luck.  *//*
 * rand48 family support
 *
 * Copyright (c) 1993 Martin Birgmeier
 * All rights reserved.
 *
 * You may redistribute unmodified or modified versions of this source
 * code provided that the above copyright notice and this and the
 * following conditions are retained.
 *
 * This software is provided ``as is'', and comes with no warranties
 * of any kind. I shall in no event be liable for anything that happens
 * to anyone/anything when using this software.
 *//* !__CUSTOM_FILE_IO__ *//* __LARGE64_FILES *//* for wide char stdio functions. *//* for thread-safety locking *//* current lseek offset *//* for future use *//* stat.st_blksize (may be != _bf._size) *//* Unix stdio files get aligned to block boundaries on fseek() *//* buffer for fgetline() *//* separate buffer for fgetline() when line crosses buffer boundary *//* guarantee a getc() buffer *//* guarantee an ungetc() buffer *//* tricks to meet minimum requirements even when malloc() fails *//* saved _r when _r is counting ungetc data *//* saved _p when _p is doing ungetc data *//* ungetc buffer *//* separate buffer for long sequences of ungetc() *//* cookie passed to io functions *//* operations *//* 0 or -_bf._size, for inline putc *//* the buffer (at least 1 byte, if !NULL) *//* fileno, if Unix descriptor, else -1 *//* flags, below; this FILE is free if 0 *//* write space left for putc() *//* read space left for getc() *//* current position in (some) buffer *//* Get custom _FILE definition.  *//* Here for binary compatibility? Remove? *//* _REENT_SMALL && !_REENT_GLOBAL_STDIO_STREAMS *//* Following is needed both in libc/stdio and libc/stdlib so we put it
 * here instead of libc/stdio/local.h where it was previously. *//*
 * struct __sFILE_fake is the start of a struct __sFILE, with only the
 * minimal fields allocated.  In __sinit() we really allocate the 3
 * standard streams, etc., and point away from this fake.
 *//*
 * Stdio state variables.
 *
 * The following always hold:
 *
 *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
 *		_lbfsize is -_bf._size, else _lbfsize is 0
 *	if _flags&__SRD, _w is 0
 *	if _flags&__SWR, _r is 0
 *
 * This ensures that the getc and putc macros (or inline functions) never
 * try to write or read from a file that is in `read' or `write' mode.
 * (Moreover, they can, and do, automatically switch from read mode to
 * write mode, and back, on "r+" and "w+" files.)
 *
 * _lbfsize is used only to make the inline line-buffered output stream
 * code as compact as possible.
 *
 * _ub, _up, and _ur are used when ungetc() pushes back more characters
 * than fit in the current _bf, or when ungetc() pushes back a character
 * that does not match the previous one in _bf.  When this happens,
 * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
 * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
 *//*
 * Stdio buffers.
 *
 * This and __FILE are defined here because we need them for struct _reent,
 * but we don't want stdio.h included when stdlib.h is.
 *//* the table itself *//* Some entries may already have been called, and will be NULL.  *//* next index in this table *//* next in list *//* Bitmask is set if function was registered via __cxa_atexit.  *//* type of exit routine -
				   Must have at least _ATEXIT_SIZE bits *//* Bitmask is set if user function takes arguments.  *//* user fn args *//* must be at least 32 to guarantee ANSI conformance *//*
 * atexit() support.
 *//* needed by reentrant structure *//*
 * If _REENT_SMALL is defined, we make struct _reent as small as possible,
 * by having nearly everything possible allocated at first use.
 *//* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  *//* This header file provides the reentrancy.  */_BYTE_ORDER_LITTLE_ENDIAN_PDP_ENDIAN341243211234__MACHINE_ENDIAN_H____ARMEB__/* !__MACHINE_ENDIAN_H__ *//* ARM configuration file.
   Copyright (c) 2015 ARM Ltd.  All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
   3. The name of the company may not be used to endorse or promote
      products derived from this software without specific prior written
      permission.

   THIS SOFTWARE IS PROVIDED BY ARM LTD ``AS IS'' AND ANY EXPRESS OR IMPLIED
   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   IN NO EVENT SHALL ARM LTD BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */<machine/_endian.h><sys/cdefs.h>__ntohs(_x)__bswap16(_x)__ntohl(_x)__bswap32(_x)__htons(_x)__htonl(_x)__bswap64(_x)__builtin_bswap64(_x)__builtin_bswap32(_x)__builtin_bswap16(_x)BYTE_ORDERPDP_ENDIANBIG_ENDIANLITTLE_ENDIAN_QUAD_LOWWORD_QUAD_HIGHWORD_BYTE_ORDER == _LITTLE_ENDIAN__machine_host_to_from_network_defined/* __MACHINE_ENDIAN_H__ *//* __machine_host_to_from_network_defined *//* !__GNUC__ *//* __GNUC__ */__sigset_t_SYS__SIGSET_H_/* !_SYS__SIGSET_H_ *//*-
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.4 (Berkeley) 5/4/95
 * $FreeBSD$
 */timevaltime_tsuseconds_ttv_usectv_sec_TIMEVAL_DEFINED_TIME_T_DECLARED__time_t_defined_SUSECONDS_T_DECLARED_SYS__TIMEVAL_H_!defined(__time_t_defined) && !defined(_TIME_T_DECLARED)/* !_SYS__TIMEVAL_H_ *//* _TIMEVAL_DEFINED *//* and microseconds *//* seconds *//*
 * Structure returned by gettimeofday(2) system call, and used in other calls.
 *//* This define is also used outside of Newlib, e.g. in MinGW-w64 *//*-
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: head/sys/sys/_timeval.h 326256 2017-11-27 15:01:59Z pfg $
 */timespectv_nsec_SYS__TIMESPEC_H_/* !_SYS__TIMESPEC_H_ *//* and nanoseconds *//*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD: head/sys/sys/_timespec.h 326023 2017-11-20 19:43:44Z pfg $
 */<sys/_timespec.h>itimerspecit_valueit_intervalTIMESPEC_TO_TIMEVAL(tv,ts)do { (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; } while (0)TIMEVAL_TO_TIMESPEC(tv,ts)do { (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; } while (0)_SYS_TIMESPEC_H_/* _SYS_TIMESPEC_H_ *//*
 * Structure defined by POSIX.1b to be like a itimerval, but with
 * timespecs. Used in the timer_*() system calls.
 *//* __BSD_VISIBLE *//*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD$
 */<sys/timespec.h><sys/_timeval.h><sys/_sigset.h>pselectfd_set *const timespecconst timespec *timespec *const sigset_tconst sigset_t *selecttimeval *fd_setfd_mask__fd_masksigset_t__fd_mask[2]unsigned long[2]FD_SETSIZE64_NFDBITS((int)sizeof(__fd_mask) * 8)_howmany(FD_SETSIZE, _NFDBITS)__fds_bitsFD_ZERO(p)do { fd_set *_p; __size_t _n; _p = (p); _n = _howmany(FD_SETSIZE, _NFDBITS); while (_n > 0) _p->__fds_bits[--_n] = 0; } while (0)FD_SET(n,p)((p)->__fds_bits[(n)/_NFDBITS] |= __fdset_mask(n))FD_ISSET(n,p)(((p)->__fds_bits[(n)/_NFDBITS] & __fdset_mask(n)) != 0)FD_COPY(f,t)(void)(*(t) = *(f))FD_CLR(n,p)((p)->__fds_bits[(n)/_NFDBITS] &= ~__fdset_mask(n))__fdset_mask(n)((__fd_mask)1 << ((n) % _NFDBITS))fds_bits_howmany(x,y)(((x) + ((y) - 1)) / (y))NFDBITS_SYS_TYPES_FD_SET_SIGSET_T_DECLARED_SYS_SELECT_H!(defined (_WINSOCK_H) || defined (_WINSOCKAPI_) || defined (__USE_W32_SOCKETS))!defined(_SIGSET_T_DECLARED)_howmany!defined (__INSIDE_CYGWIN_NET__)(int __n, fd_set *__readfds, fd_set *__writefds, fd_set *__exceptfds, const struct timespec *__timeout, const sigset_t *__set)(int __n, fd_set *__readfds, fd_set *__writefds, fd_set *__exceptfds, struct timeval *__timeout)/* sys/select.h *//* !(_WINSOCK_H || _WINSOCKAPI_ || __USE_W32_SOCKETS) *//* !__INSIDE_CYGWIN_NET__ *//* bits per mask *//*
 * Select uses bit masks of file descriptors in longs.
 * These macros manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here
 * should be >= NOFILE (param.h).
 *//* We don't define fd_set and friends if we are compiling POSIX
   source, or if we have included (or may include as indicated
   by __USE_W32_SOCKETS) the W32api winsock[2].h header which
   defines Windows versions of them.   Note that a program which
   includes the W32api winsock[2].h header must know what it is doing;
   it must not call the Cygwin select function.
*/__n__readfds__writefds__exceptfds__timeout__setsched_paramsched_prioritySCHED_RRSCHED_FIFOSCHED_OTHER_SYS_SCHED_H_defined(_POSIX_SPORADIC_SERVER)defined(_POSIX_SPORADIC_SERVER) || defined(_POSIX_THREAD_SPORADIC_SERVER)/* end of include file *//* sporadic server *//* Maximum pending replenishments for *//* Initial budget for sporadic server *//* Replenishment period for sporadic server *//*   server *//* Low scheduling priority for sporadic *//* Process execution scheduling priority *//* Open Group Specifications Issue 6 *//* Scheduling Parameters *//* Scheduling Policies *//*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2010.
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */<sys/sched.h>pthread_once_tpthread_key_tpthread_condattr_tpthread_cond_tpthread_mutexattr_tpthread_mutex_tpthread_attr_tpthread_tinit_executedis_initializedclockrecursivedetachstateschedparamschedpolicyinheritschedcontentionscopestacksizestackaddr_PTHREAD_ONCE_INIT{ 1, 0 }_PTHREAD_COND_INITIALIZER((pthread_cond_t) 0xFFFFFFFF)_PTHREAD_MUTEX_INITIALIZER((pthread_mutex_t) 0xFFFFFFFF)PTHREAD_CREATE_JOINABLEPTHREAD_CREATE_DETACHEDPTHREAD_EXPLICIT_SCHEDPTHREAD_INHERIT_SCHEDPTHREAD_SCOPE_SYSTEMPTHREAD_SCOPE_PROCESS_SYS__PTHREADTYPES_H_defined(_POSIX_THREADS) || __POSIX_VISIBLE >= 199506defined(_POSIX_THREAD_CPUTIME)defined(_POSIX_THREAD_PROCESS_SHARED)defined(_POSIX_THREAD_PRIO_PROTECT)defined(_UNIX98_THREAD_MUTEX_ATTRIBUTES)defined(_POSIX_BARRIERS)defined(_POSIX_SPIN_LOCKS)defined(_POSIX_READER_WRITER_LOCKS)/* ! _SYS__PTHREADTYPES_H_ *//* defined(_POSIX_READER_WRITER_LOCKS) *//* allow this to be shared amongst processes *//* is this structure initialized? *//* POSIX RWLock Object *//* POSIX Reader/Writer Lock Types *//* defined(_POSIX_SPIN_LOCKS) *//* POSIX Spin Lock Object *//* POSIX Spin Lock Types *//* defined(_POSIX_BARRIERS) *//* POSIX Barrier Object *//* POSIX Barrier Types *//* defined(_POSIX_THREADS) || __POSIX_VISIBLE >= 199506 *//* is initialized and not run *//* dynamic package initialization *//* has the initialization routine been run? *//* thread-specific data keys *//* Keys *//* a condition attribute object *//* specifiy clock for timeouts *//* identify a condition variable *//* Condition Variables *//* !defined(__XMK__) *//* allow mutex to be shared amongst processes *//* identify a mutex *//* !defined(_UNIX98_THREAD_MUTEX_ATTRIBUTES) *//*
 * Attempting to recursively lock a mutex of this type results
 * in undefined behavior. Attempting to unlock a mutex of this type
 * which was not locked by the calling thread results in undefined
 * behavior. Attempting to unlock a mutex of this type which is not locked
 * results in undefined behavior. An implementation may map this mutex to
 * one of the other mutex types.
 *//*
 * This type of mutex provides error checking. A thread attempting
 * to relock this mutex without first unlocking it shall return with an
 * error. A thread attempting to unlock a mutex which another thread has
 * locked shall return with an error. A thread attempting to unlock an
 * unlocked mutex shall return with an error.
 *//*
 * A thread attempting to relock this mutex without first unlocking
 * it shall succeed in locking the mutex.  The relocking deadlock which
 * can occur with mutexes of type PTHREAD_MUTEX_NORMAL cannot occur with
 * this type of mutex.  Multiple locks of this mutex shall require the
 * same number of unlocks to release the mutex before another thread can
 * acquire the mutex. A thread attempting to unlock a mutex which another
 * thread has locked shall return with an error.  A thread attempting to
 * unlock an unlocked mutex shall return with an error.
 *//*
 * This type of mutex does not detect deadlock. A thread attempting to
 * relock this mutex without first unlocking it shall deadlock. Attempting
 * to unlock a mutex locked by a different thread results in undefined
 * behavior.  Attempting to unlock an unlocked mutex results in undefined
 * behavior.
 *//* The following defines are part of the X/Open System Interface (XSI). *//* Values for mutex type *//* Values for blocking protocol. *//* Mutexes *//*   located *//*   the memory where the resource is *//* visible too all processes with access to *//* visible within only the creating process *//* NOTE: P1003.1c/D10, p. 81 defines following values for process_shared.  *//* see time.h *//* P1003.4b/D8, p. 54 adds cputime_clock_allowed attribute.  *//* P1003.1c/D10, p. 141 *//* set from provided attribute object *//*   the calling thread. *//*   attributes are inherited from *//* scheduling policy and associated *//* P1003.1c/D10, p. 111 *//* P1003.1c/D10, p. 118-119 *//* identify a thread *//*
 *  2.5 Primitive System Data Types,  P1003.1c/D10, p. 19.
 *//*
 *  Written by Joel Sherrill <joel.sherrill@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2013, 2015.
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 */_SYS_TYPES_Hdefined(__XMK__) && defined(___int64_t_defined)/* !_SYS_TYPES_H *//*
 * Newlib targets may provide an own version of this file in their machine
 * directory to add custom user types for <sys/types.h>.
 */<machine/types.h><sys/_pthreadtypes.h><sys/select.h><machine/endian.h>sbintime_tuseconds_ttimer_tclockid_tnlink_tmode_tssize_tkey_tpid_tgid_tuid_tdev_toff_tino_tid_tfsfilcnt_tfsblkcnt_tcaddr_tdaddr_tclock_tblksize_tblkcnt_tulonguintushortu_longu_intu_shortu_charu_register_tin_port_tin_addr_tregister_tu_int64_tu_int32_tu_int16_tu_int8_t__need_inttypes_USECONDS_T_DECLARED_TIMER_T_DECLARED__timer_t_defined_CLOCKID_T_DECLARED__clockid_t_defined_NLINK_T_DECLARED_MODE_T_DECLARED_SSIZE_T_DECLARED_KEY_T_DECLARED_PID_T_DECLARED_GID_T_DECLARED_UID_T_DECLARED_DEV_T_DECLARED_OFF_T_DECLARED_INO_T_DECLARED_ID_T_DECLARED_FSBLKCNT_T_DECLARED__caddr_t_defined__daddr_t_defined_CLOCK_T_DECLARED__clock_t_defined_BLKSIZE_T_DECLARED_BLKCNT_T_DECLARED_BSDTYPES_DEFINED__u_long_defined__u_int_defined__u_short_defined__u_char_defined_IN_PORT_T_DECLARED_IN_ADDR_T_DECLAREDquadquad_tphysadrphysadr_t__BIT_TYPES_DEFINED__!defined(__clock_t_defined) && !defined(_CLOCK_T_DECLARED)!defined(__clockid_t_defined) && !defined(_CLOCKID_T_DECLARED)!defined(__timer_t_defined) && !defined(_TIMER_T_DECLARED)/* _SYS_TYPES_H *//* !__need_inttypes *//* link count *//* permissions *//* IPC key *//* process id *//* group id *//* user id *//* device number or struct cdev *//* file offset *//*
 * All these should be machine specific - right now they are all broken.
 * However, for all of Cygnus' embedded targets, we want them to all be
 * the same.  Otherwise things like sizeof (struct stat) might depend on
 * how the file was compiled (e.g. -mint16 vs -mint32, etc.).
 *//* __i386__ && (GO32 || __MSDOS__) *//* inode number *//* can hold a uid_t or pid_t *//* for statvfs() *//* System V compatibility *//* __MISC_VISIBLE *//* also defined in mingw/gmon.h and in w32api/winsock[2].h *//* base type for internet address *//* BSD types permitted by POSIX and always exposed as in Glibc.  Only provided
   for backward compatibility with BSD code.  The uintN_t standard types should
   be preferred in new code. *//* unified sys/types.h: 
   start with sef's sysvi386 version.
   merge go32 version -- a few ifdefs.
   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:

   typedef int gid_t;
   typedef int uid_t;
   typedef int dev_t;
   typedef int ino_t;
   typedef int mode_t;
   typedef int caddr_t;

   however, these aren't "reasonable" values, the sysvi386 ones make far 
   more sense, and should work sufficiently well (in particular, h8300 
   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
 */<sys/reent.h>_funlockfile(fp)(((fp)->_flags & __SSTR) ? 0 : __lock_release_recursive((fp)->_lock))_flockfile(fp)(((fp)->_flags & __SSTR) ? 0 : __lock_acquire_recursive((fp)->_lock))_NEWLIB_STDIO_H!defined(_flockfile)!defined(_funlockfile)/* _NEWLIB_STDIO_H *//* Internal locking macros, used to protect stdio functions.  In the
   general case, expand to nothing. Use __SSTR flag in FILE _flags to
   detect if FILE is private to sprintf/sscanf class of functions; if
   set then do nothing as lock is not initialised. */<sys/stdio.h><sys/types.h><stdarg.h>"_ansi.h"_putchar_unlocked_ptrFILE *_getchar_unlocked_stdin_r(_ptr)((_ptr)->_stdin)__sputc_r'\n'_funopen_rconst voidconst void *funopen__swbuf_r__srget_rfwrite_unlockedconst void *__restrict__fread_unlockedvoid *__restrict__FILE *__restrict__fputc_unlockedfgetc_unlockedfflush_unlockedfileno_unlockedferror_unlockedfeof_unlockedclearerr_unlocked__getlinechar **size_t *unsigned int *__getdelimfpurge_vsscanf_r_vsprintf_rchar *__restrict___vsnprintf_r_vsniprintf_r_vsiscanf_r_vsiprintf_r_vscanf_r_vprintf_r_viscanf_r_viprintf_r_vfscanf_r_vfprintf_r_vfiscanf_r_vfiprintf_r_vdprintf_r_vdiprintf_r_vasprintf_r_vasnprintf_r_vasniprintf_r_vasiprintf_r_ungetc_r_tmpnam_r_tmpfile_r_tempnam_r_sscanf_r_sprintf_r_snprintf_r_sniprintf_r_siscanf_r_siprintf_r_scanf_r_rename_r_remove_r_puts_r_putchar_r_putchar_unlocked_r_putc_unlocked_r_putc_r_printf_r_perror_r_open_memstream_r_iscanf_r_iprintf_r_gets_r_getchar_unlocked_r_getchar_r_getc_unlocked_r_getc_r_fwrite_unlocked_r_fwrite_r_rewind_r_ftello_r_ftell_r_fseeko_r_fseek_r_fscanf_r_fread_unlocked_r_fread_r_fputs_unlocked_r_fputs_r_fputc_unlocked_r_fputc_r_fpurge_r_fprintf_r_freopen_r_fopen_r_fmemopen_r_fiscanf_r_fiprintf_r_fsetpos_rconst fpos_tconst fpos_t *long *_fgetpos_rfpos_t *_fgets_unlocked_r_fgets_r_fgetc_unlocked_r_fgetc_r_fflush_r_fdopen_r_fcloseall_r_fclose_r_dprintf_r_diprintf_r_asprintf_rchar **__restrict___asnprintf_rsize_t *__restrict___asniprintf_r_asiprintf_rrenameatvdprintfopen_memstreamfmemopendprintfputchar_unlockedputc_unlockedfunlockfileftrylockfileflockfilegetchar_unlockedgetc_unlockedputwgetwsetlinebufsetbufferpopenpclosefilenofdopenvsniprintfvsiscanfvsiprintfviscanfviprintfvfiscanfvfiprintfvdiprintfvasnprintfvasniprintfvasiprintfsniprintfsiscanfsiprintfiscanfiprintffiscanffiprintfdiprintfasnprintfasniprintfasiprintfvsscanfvscanfvfscanfvsnprintfsnprintfftellofseekorenameremovesprintffopenperrorferrorfeofclearerrrewindftellfsetposfseekfgetposfpos_t *__restrict__fwritefreadungetcputsputcharputcgetsgetchargetcfputsfputcfgetsfgetcvsprintfvprintfvfprintfsscanfscanfprintffscanffprintfsetvbufsetbuffreopenfflushfclosetempnamtmpnamtmpfilectermidfpos_tFILEva_listL_ctermidfast_putc(x,p)(--(p)->_w < 0 ? __swbuf_r(_REENT, (int)(x), p) == EOF : (*(p)->_p = (x), (p)->_p++, 0))putchar_unlocked(_c)_putchar_unlocked(_c)getchar_unlocked()_getchar_unlocked()clearerr_unlocked(p)__sclearerr(p)ferror_unlocked(p)__sferror(p)feof_unlocked(p)__sfeof(p)clearerr(p)ferror(p)feof(p)__sfileno(p)((p)->_file)((void)((p)->_flags &= ~(__SERR|__SEOF)))((int)(((p)->_flags & __SERR) != 0))((int)(((p)->_flags & __SEOF) != 0))__sgetc_r(__ptr,__p)__sgetc_raw_r(__ptr, __p)__sgetc_raw_r(__ptr,__f)(--(__f)->_r < 0 ? __srget_r(__ptr, __f) : (int)(*(__f)->_p++))fwopen(__cookie,__fn)funopen(__cookie, (int (*)())0, __fn, (fpos_t (*)())0, (int (*)())0)fropen(__cookie,__fn)funopen(__cookie, __fn, (int (*)())0, (fpos_t (*)())0, (int (*)())0)__VALIST_stderr_r(x)((x)->_stderr)_stdout_r(x)((x)->_stdout)_stdin_r(x)((x)->_stdin)stderr(_REENT->_stderr)stdout(_REENT->_stdout)stdin(_REENT->_stdin)TMP_MAXSEEK_ENDSEEK_CURSEEK_SETP_tmpdir"/tmp"L_tmpnamFILENAME_MAX1024FOPEN_MAXBUFSIZEOF(-1)_IONBF_IOLBF_IOFBF__SWID0x2000__SNLK0x0001__SL640x8000__SORD__SOFF0x1000__SNPT0x0800__SOPT0x0400__SSTR0x0200__SAPP0x0100__SMBF0x0080__SERR0x0040__SEOF0x0020__SRW0x0010__SWR0x0008__SRD0x0004__SNBF0x0002__SLBF__FILE_defined_FSTDIO_STDIO_H___POSIX_VISIBLE >= 200809 || __XSI_VISIBLE!defined(__FILE_defined)__BUFSIZ____FOPEN_MAX____FILENAME_MAX____L_tmpnam____BSD_VISIBLE || __XSI_VISIBLE__GNU_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 600)__BSD_VISIBLE || __XSI_VISIBLE || __POSIX_VISIBLE >= 200112_COMPILING_NEWLIB_REENT_ONLY__LARGEFILE_VISIBLE || __POSIX_VISIBLE >= 200112__ISO_C_VISIBLE >= 1999__MISC_VISIBLE || __POSIX_VISIBLE >= 199209__MISC_VISIBLE || (__XSI_VISIBLE && __POSIX_VISIBLE < 200112)__MISC_VISIBLE || __POSIX_VISIBLE!defined(__CYGWIN__) || defined(_COMPILING_NEWLIB)__SCLE__SSP_FORTIFY_LEVEL > 0(__format__ (__scanf__, 3, 0))format__scanf__(__format__ (__printf__, 3, 0))__printf__(__format__ (__printf__, 4, 0))(__format__ (__scanf__, 2, 0))(__format__ (__printf__, 2, 0))(__format__ (__scanf__, 3, 4))(__format__ (__printf__, 3, 4))(__format__ (__printf__, 4, 5))(__format__ (__scanf__, 2, 3))(__format__ (__printf__, 2, 3))_c__cookie__readfn__writefn__seekfn__closefn_n_old(__format__ (__scanf__, 1, 0))(__format__ (__printf__, 1, 0))(__format__ (__scanf__, 1, 2))(__format__ (__printf__, 1, 2))mallocwarn_unused_result/* _STDIO_H_ *//* __CUSTOM_FILE_IO__ *//* posix says it goes in stdio.h :( *//* fast always-buffered version, true iff error *//* __cplusplus *//* __SINGLE_THREAD__ *//* __POSIX_VISIBLE - FIXME: must initialize stdio first, use fn *//* _REENT_SMALL *//*
 * This has been tuned to generate reasonable code on the vax using pcc
 *//*  For a platform with CR/LF, additional logic is required by
  __sgetc_r which would otherwise simply be a macro; therefore we
  use an inlined function.  The function is only meant to be inlined
  in place as used and the function body should never be emitted.  

  There are two possible means to this end when compiling with GCC,
  one when compiling with a standard C99 compiler, and for other
  compilers we're just stuck.  At the moment, this issue only
  affects the Cygwin target, so we'll most likely be using GCC. *//*
 * The __sfoo macros are here so that we can 
 * define function versions in the C library.
 *//* __GNU_VISIBLE *//* These four struct member names are dictated by Linux; hopefully,
     they don't conflict with any macros.  *//* !__LARGE64_FILES *//*
 * Stdio function-access interface.
 *//*
 * Routines internal to the implementation.
 *//* !__CYGWIN__ *//* Other extensions.  *//*
 * Recursive versions of the above.
 *//* getline - see __getline for now *//* getdelim - see __getdelim for now *//*
 * Routines in POSIX 1003.1:200x.
 *//*
 * Routines in POSIX 1003.1:2001.
 *//* !_REENT_ONLY *//* Newlib-specific *//*
 * Functions defined in ANSI C standard.
 *//* set file offset to EOF plus offset *//* set file offset to current plus offset *//* set file offset to offset *//* setvbuf should set unbuffered *//* setvbuf should set line buffered *//* setvbuf should set fully buffered *//*
 * The following three definitions are for ANSI C, which took them
 * from System V, which stupidly took internal interface macros and
 * made them official arguments to setvbuf(), without renaming them.
 * Hence, these ugly _IOxxx names are *supposed* to appear in user code.
 *
 * Although these happen to match their counterparts above, the
 * implementation does not rely on that (so these could be renumbered).
 *//* true => stream orientation wide, false => byte, only valid if __SORD in _flags is true *//* stdio functions do not lock streams themselves *//* _flags2 flags *//* is 64-bit offset large file *//* convert line endings CR/LF <-> NL *//* true => stream orientation (byte/wide) decided *//* set iff _offset is in fact correct *//* do not do fseek() optimisation *//* do fseek() optimisation *//* this is an sprintf/snprintf string *//* fdopen()ed in append mode - so must  write to end *//* _buf is from malloc *//* found error *//* found EOF *//* open for reading & writing *//* RD and WR are never simultaneously asserted *//* OK to write *//* OK to read *//* unbuffered *//* line buffered *//*
 * <sys/reent.h> defines __FILE, _fpos_t.
 * They must be defined there because struct _reent needs them (and we don't
 * want reent.h to include this file.
 *//* __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE *//* typedef va_list only when required *//* typedef only __gnuc_va_list, used throughout the header *//* ``function stdio'' *//*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 *//*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * and/or other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */_name_type/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/machine/stdlib.h_MACHSTDLIB_H_/* _MACHSTDLIB_H_ *//* place holder so platforms may add stdlib.h extensions *//Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/alloca.halloca(size)__builtin_alloca(size)alloca_NEWLIB_ALLOCA_H/* Rearranged for general inclusion by stdlib.h.
   2001, Corinna Vinschen <vinschen@redhat.com> *//* libc/include/alloca.h - Allocate memory on stack *//Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/stdlib.h<alloca.h><machine/stdlib.h>quick_exitat_quick_exitaligned_allocstrtold_strtold_rqsort_r__eprintf_system_r_mstats_r_realloc_r_free_r_calloc_r_malloc_r_dtoa_rint *posix_memalignvoid **_unsetenv_runsetenvcfree_strtoull_rstrtoull_strtoll_rstrtolllldivllabs_atoll_ratollsrandomsetstaterandominitstate_srand48_rsrand48unsigned short *_seed48_rseed48_nrand48_rnrand48_mrand48_rmrand48_lrand48_rlrand48_lcong48_runsigned short[7]lcong48_jrand48_rjrand48_erand48_rerand48_drand48_rdrand48rand_rutoaitoa__utoa__itoa_setenv_rsetenv_reallocf_r_putenv_rputenv_Exiton_exit_l64a_rl64aa64lsystem_strtoul_rstrtoul_strtol_rstrtolstrtof_strtod_rstrtodsrandrpmatchrealpathreallocfreallocarrayreallocrandqsort_mktemp_r_mkstemps_r_mkstemp_r_mkostemps_r_mkostemp_r_mkdtemp_rmktempmkstempsmkstempmkdtemp_wcstombs_rconst wchar_tconst wchar_t *const wchar_t *__restrict___mbstate_t *struct <unnamed> *wcstombs_mbstowcs_rwchar_t *wchar_t *__restrict__mbstowcs_wctomb_rwctomb_mbtowc_rmbtowc_mblen_rmblenldivlabsgetsuboptchar *constchar *const *_findenv_r_findenv_getenv_rgetenvfreedivcallocbsearch_atol_ratol_atoi_ratoiatoffatofatexitarc4random_bufarc4random_uniformarc4randomabsabort__locale_mb_cur_max__compar_fn_tlldiv_tldiv_tdiv_tremquotsuboptargstrtodfMB_CUR_MAX__locale_mb_cur_max()RAND_MAXEXIT_SUCCESSEXIT_FAILURE__compar_fn_t_defined_STDLIB_H___STRICT_ANSI____BSD_VISIBLE || __POSIX_VISIBLE >= 200809__MISC_VISIBLE || __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 4__BSD_VISIBLE || (__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200112)__BSD_VISIBLE || __XSI_VISIBLE >= 4__SVID_VISIBLE || __XSI_VISIBLE >= 4__SVID_VISIBLE || __XSI_VISIBLE__BSD_VISIBLE || __POSIX_VISIBLE >= 200112__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200112__SVID_VISIBLE || __XSI_VISIBLE >= 4 || __BSD_VISIBLE__ISO_C_VISIBLE >= 2011alloc_alignalloc_size(1)nonnull(__deprecated__("the use of `mktemp' is dangerous; use `mkstemp' instead"))the use of `mktemp' is dangerous; use `mkstemp' insteadchar[56]deprecatedexitunused(__noreturn__)"__bsd_qsort_r"__USER_LABEL_PREFIX__/* _STDLIB_H_ *//* __ISO_C_VISIBLE >= 2011 *//*
 * If we're in a mode greater than C99, expose C11 functions.
 *//* _HAVE_LONG_DOUBLE *//* On platforms where long double equals double.  *//* There are two common qsort_r variants.  If you request
   _BSD_SOURCE, you get the BSD version; otherwise you get the GNU
   version.  We want that #undef qsort_r will still let you
   invoke the underlying function, but that requires gcc support. *//* __SVID_VISIBLE || __XSI_VISIBLE *//* the following strtodf interface is deprecated...use strtof instead *//* getsubopt(3) external variable *//* remainder *//* quotient *//*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */__base__nmemb__size__thunk_compar__string__end_PTR__numer__denom__nptr__seed__overwrite__status__func__arg__inputresponsepathresolved_path__key/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/_locale.hlocale_t_SYS__LOCALE_H/* _SYS__LOCALE_H *//* Definition of opaque POSIX-1.2008 type locale_t for userspace. *//Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/strings.h<sys/_locale.h>strncasecmp_lstrcasecmp_lstrncasecmpstrcasecmprindexindexflsllflslflsffsllffslffsexplicit_bzerobzerobcopybcmp_STRINGS_H___BSD_VISIBLE || __POSIX_VISIBLE <= 200112__MISC_VISIBLE || __POSIX_VISIBLE < 200809 || __XSI_VISIBLE >= 700/* _STRINGS_H_ *//* LEGACY *//*-
 * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: head/include/strings.h 272673 2014-10-07 04:54:11Z delphij $
 *//Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/sys/string.h/* This is a dummy <sys/string.h> used as a placeholder for
   systems that need to have a special header file.  *//Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/arm-none-eabi/include/string.h<sys/string.h><strings.h>strsignalstruprstrlwrstrnstrstrsepstrnlenstrlcpystrlcat_strerror_rstrerror_r_strndup_rstrndup_strdup_rstrdupstpncpystpcpymemccpytimingsafe_memcmptimingsafe_bcmpstrtok_rstrxfrm_lstrerror_lstrcoll_lstrxfrmstrtokstrstrstrspnstrrchrstrpbrkstrncpystrncmpstrncatstrlenstrerrorstrcspnstrcpystrcollstrcmpstrchrstrcatmemsetmemmovememcpymemcmpmemchr_STRING_H___MISC_VISIBLE || __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 4__ASMNAMEDEFS_H__GNU_VISIBLE && defined(__GNUC__)__GNU_VISIBLE && !defined(basename)"__xpg_strerror_r"/* _STRING_H_ *//* There are two common basename variants.  If you do NOT #include <libgen.h>
   and you do

     #define _GNU_SOURCE
     #include <string.h>

   you get the GNU version.  Otherwise you get the POSIX versionfor which you
   should #include <libgen.h>i for the function prototype.  POSIX requires that
   #undef basename will still let you invoke the underlying function.  However,
   this also implies that the POSIX version is used in this case.  That's made
   sure here. *//* __GNU_VISIBLE && __GNUC__ *//* Kludge to work around problem compiling in gdb *//* Reentrant version of strerror.  *//* There are two common strerror_r variants.  If you request
   _GNU_SOURCE, you get the GNU version; otherwise you get the POSIX
   version.  POSIX requires that #undef strerror_r will still let you
   invoke the underlying function, but that requires gcc support.  *//*
 * string.h
 *
 * Definitions for memory and string functions.
 */__signo/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/CMSIS/cmsis_version.h__CM_CMSIS_VERSION((__CM_CMSIS_VERSION_MAIN << 16U) | __CM_CMSIS_VERSION_SUB )__CM_CMSIS_VERSION_SUB( 4U)__CM_CMSIS_VERSION_MAIN( 5U)__CMSIS_VERSION_Hdefined ( __ICCARM__ )defined (__clang__)/*!< CMSIS Core(M) version number *//*!< [15:0]  CMSIS Core(M) sub version *//*!< [31:16] CMSIS Core(M) main version *//*  CMSIS Version definitions *//* treat file as system include file *//* treat file as system include file for MISRA check *//*
 * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @file     cmsis_version.h
 * @brief    CMSIS Core(M) Version definitions
 * @version  V5.0.4
 * @date     23. July 2019
 ******************************************************************************//**************************************************************************//Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/CMSIS/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/CMSIS/cmsis_gcc.h__zero_table_t__copy_table_t__STRTalways_inlinevolatile uint32_tvolatile uint32_t *__STRHTvolatile uint16_tvolatile uint16_t *__STRBTvolatile uint8_tvolatile uint8_t *__LDRTresult__LDRHT__LDRBT__RRXvalue__CLREX__STREXW__STREXH__STREXB__LDREXW__LDREXH__LDREXB__CLZ32U__builtin_clz__RBIT__ROR__REVSH__builtin_bswap16__REV16__REV__builtin_bswap32__DMB__DSB__ISB__set_FPSCR__get_FPSCR(0U)__set_FAULTMASK__get_FAULTMASK__set_BASEPRI_MAX__set_BASEPRI__get_BASEPRI__disable_fault_irq__enable_fault_irq__set_PRIMASK__get_PRIMASK__set_MSP__get_MSP__set_PSP__get_PSP__get_xPSR__get_APSR__get_IPSR__set_CONTROL__get_CONTROL__disable_irq__enable_irq_start__cmsis_startconst __copy_table_tconst __copy_table_t *pTablei0uconst uint32_tconst uint32_t *const __zero_table_tconst __zero_table_t *T_UINT32_READpackedT_UINT32_WRITET_UINT16_READT_UINT16_WRITET_UINT32wlendestsrcv__zero_table_end____zero_table_start____copy_table_end____copy_table_start____USAT(ARG1,ARG2)__extension__ ({ uint32_t __RES, __ARG1 = (ARG1); __ASM volatile ("usat %0, %1, %2" : "=r" (__RES) : "I" (ARG2), "r" (__ARG1) : "cc" ); __RES; })__SSAT(ARG1,ARG2)__extension__ ({ int32_t __RES, __ARG1 = (ARG1); __ASM volatile ("ssat %0, %1, %2" : "=r" (__RES) : "I" (ARG2), "r" (__ARG1) : "cc" ); __RES; })__BKPT(value)__ASM volatile ("bkpt "#value)__SEV()__ASM volatile ("sev")__WFE()__ASM volatile ("wfe":::"memory")__WFI()__ASM volatile ("wfi":::"memory")__NOP()__ASM volatile ("nop")__CMSIS_GCC_USE_REG(r)"r" (r)__CMSIS_GCC_RW_REG(r)"+r" (r)__CMSIS_GCC_OUT_REG(r)"=r" (r)__VECTOR_TABLE_ATTRIBUTE__attribute__((used, section(".vectors")))__VECTOR_TABLE__Vectors__STACK_LIMIT__StackLimit__INITIAL_SP__StackTop__PROGRAM_START__COMPILER_BARRIER()__ASM volatile("":::"memory")__RESTRICT__ALIGNED(x)__attribute__((aligned(x)))__UNALIGNED_UINT32_READ(addr)(((const struct T_UINT32_READ *)(const void *)(addr))->v)__UNALIGNED_UINT32_WRITE(addr,val)(void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))__UNALIGNED_UINT16_READ(addr)(((const struct T_UINT16_READ *)(const void *)(addr))->v)__UNALIGNED_UINT16_WRITE(addr,val)(void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))__UNALIGNED_UINT32(x)(((struct T_UINT32 *)(x))->v)__PACKED_UNIONunion __attribute__((packed, aligned(1)))__PACKED_STRUCTstruct __attribute__((packed, aligned(1)))__PACKED__attribute__((packed, aligned(1)))__WEAK__attribute__((weak))__USED__attribute__((used))__NO_RETURN__STATIC_FORCEINLINE__attribute__((always_inline)) static inline__STATIC_INLINEstatic inline__INLINE__ASM__asm__CMSIS_GCC_HGCC diagnostic pushGCC diagnostic ignored "-Wsign-conversion"GCC diagnostic ignored "-Wconversion"GCC diagnostic ignored "-Wunused-parameter"__UNALIGNED_UINT32GCC diagnostic ignored "-Wpacked"GCC diagnostic ignored "-Wattributes"GCC diagnostic pop__UNALIGNED_UINT16_WRITE__UNALIGNED_UINT16_READ__UNALIGNED_UINT32_WRITE__UNALIGNED_UINT32_READ__ALIGNED__COMPILER_BARRIER(defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \(!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \(defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))(!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))(defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \__has_builtin(__builtin_arm_get_fpscr)__has_builtin(__builtin_arm_set_fpscr)defined (__thumb__) && !defined (__thumb2__)(__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)(__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)(defined (__ARM_FEATURE_DSP) && (__ARM_FEATURE_DSP == 1))__thumb2____ARM_ARCH_7M__/* __CMSIS_GCC_H *//*@} end of group CMSIS_SIMD_intrinsics *//* (__ARM_FEATURE_DSP == 1) *//* Big endian *//* Little endian *//** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
  Access to dedicated SIMD instructions
  @{
*//* ###################  Compiler specific Intrinsics  ########################### *//* end of group CMSIS_Core_InstructionInterface *//*@}*//* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
           (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) *//**
  \brief   Store-Release Exclusive (32 bit)
  \details Executes a STL exclusive instruction for 32 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
  \return          0  Function succeeded
  \return          1  Function failed
 *//**
  \brief   Store-Release Exclusive (16 bit)
  \details Executes a STLH exclusive instruction for 16 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
  \return          0  Function succeeded
  \return          1  Function failed
 *//**
  \brief   Store-Release Exclusive (8 bit)
  \details Executes a STLB exclusive instruction for 8 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
  \return          0  Function succeeded
  \return          1  Function failed
 *//**
  \brief   Load-Acquire Exclusive (32 bit)
  \details Executes a LDA exclusive instruction for 32 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint32_t at (*ptr)
 *//**
  \brief   Load-Acquire Exclusive (16 bit)
  \details Executes a LDAH exclusive instruction for 16 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint16_t at (*ptr)
 *//**
  \brief   Load-Acquire Exclusive (8 bit)
  \details Executes a LDAB exclusive instruction for 8 bit value.
  \param [in]    ptr  Pointer to data
  \return             value of type uint8_t at (*ptr)
 *//**
  \brief   Store-Release (32 bit)
  \details Executes a STL instruction for 32 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
 *//**
  \brief   Store-Release (16 bit)
  \details Executes a STLH instruction for 16 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
 *//**
  \brief   Store-Release (8 bit)
  \details Executes a STLB instruction for 8 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
 *//**
  \brief   Load-Acquire (32 bit)
  \details Executes a LDA instruction for 32 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint32_t at (*ptr)
 *//**
  \brief   Load-Acquire (16 bit)
  \details Executes a LDAH instruction for 16 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint16_t at (*ptr)
 *//**
  \brief   Load-Acquire (8 bit)
  \details Executes a LDAB instruction for 8 bit value.
  \param [in]    ptr  Pointer to data
  \return             value of type uint8_t at (*ptr)
 *//* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
           (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
           (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) *//**
  \brief   Unsigned Saturate
  \details Saturates an unsigned value.
  \param [in]  value  Value to be saturated
  \param [in]    sat  Bit position to saturate to (0..31)
  \return             Saturated value
 *//**
  \brief   Signed Saturate
  \details Saturates a signed value.
  \param [in]  value  Value to be saturated
  \param [in]    sat  Bit position to saturate to (1..32)
  \return             Saturated value
 *//**
  \brief   STRT Unprivileged (32 bit)
  \details Executes a Unprivileged STRT instruction for 32 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
 *//**
  \brief   STRT Unprivileged (16 bit)
  \details Executes a Unprivileged STRT instruction for 16 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
 *//**
  \brief   STRT Unprivileged (8 bit)
  \details Executes a Unprivileged STRT instruction for 8 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
 *//**
  \brief   LDRT Unprivileged (32 bit)
  \details Executes a Unprivileged LDRT instruction for 32 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint32_t at (*ptr)
 *//* Add explicit type cast here *//* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
       accepted by assembler. So has to use following less efficient pattern.
    *//**
  \brief   LDRT Unprivileged (16 bit)
  \details Executes a Unprivileged LDRT instruction for 16 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint16_t at (*ptr)
 *//**
  \brief   LDRT Unprivileged (8 bit)
  \details Executes a Unprivileged LDRT instruction for 8 bit value.
  \param [in]    ptr  Pointer to data
  \return             value of type uint8_t at (*ptr)
 *//**
  \brief   Rotate Right with Extend (32 bit)
  \details Moves each bit of a bitstring right by one bit.
           The carry input is shifted in at the left end of the bitstring.
  \param [in]    value  Value to rotate
  \return               Rotated value
 *//**
  \brief   Unsigned Saturate
  \details Saturates an unsigned value.
  \param [in]  ARG1  Value to be saturated
  \param [in]  ARG2  Bit position to saturate to (0..31)
  \return             Saturated value
 *//**
  \brief   Signed Saturate
  \details Saturates a signed value.
  \param [in]  ARG1  Value to be saturated
  \param [in]  ARG2  Bit position to saturate to (1..32)
  \return             Saturated value
 *//* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
           (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
           (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
           (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) *//**
  \brief   Remove the exclusive lock
  \details Removes the exclusive lock which is created by LDREX.
 *//**
  \brief   STR Exclusive (32 bit)
  \details Executes a exclusive STR instruction for 32 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
  \return          0  Function succeeded
  \return          1  Function failed
 *//**
  \brief   STR Exclusive (16 bit)
  \details Executes a exclusive STR instruction for 16 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
  \return          0  Function succeeded
  \return          1  Function failed
 *//**
  \brief   STR Exclusive (8 bit)
  \details Executes a exclusive STR instruction for 8 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
  \return          0  Function succeeded
  \return          1  Function failed
 *//**
  \brief   LDR Exclusive (32 bit)
  \details Executes a exclusive LDR instruction for 32 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint32_t at (*ptr)
 *//**
  \brief   LDR Exclusive (16 bit)
  \details Executes a exclusive LDR instruction for 16 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint16_t at (*ptr)
 *//**
  \brief   LDR Exclusive (8 bit)
  \details Executes a exclusive LDR instruction for 8 bit value.
  \param [in]    ptr  Pointer to data
  \return             value of type uint8_t at (*ptr)
 *//* Even though __builtin_clz produces a CLZ instruction on ARM, formally
     __builtin_clz(0) is undefined behaviour, so handle this case specially.
     This guarantees ARM-compatible results if happening to compile on a non-ARM
     target, and ensures the compiler doesn't decide to activate any
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   *//**
  \brief   Count leading zeros
  \details Counts the number of leading zeros of a data value.
  \param [in]  value  Value to count the leading zeros
  \return             number of leading zeros in value
 *//* shift when v's highest bits are zero *//* r will be reversed bits of v; first get LSB of v *//* extra shift needed at end *//*sizeof(v)*//**
  \brief   Reverse bit order of value
  \details Reverses the bit order of the given value.
  \param [in]    value  Value to reverse
  \return               Reversed value
 *//**
  \brief   Breakpoint
  \details Causes the processor to enter Debug state.
           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
  \param [in]    value  is ignored by the processor.
                 If required, a debugger can use it to store additional information about the breakpoint.
 *//**
  \brief   Rotate Right in unsigned value (32 bit)
  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
  \param [in]    op1  Value to rotate
  \param [in]    op2  Number of Bits to rotate
  \return               Rotated value
 *//**
  \brief   Reverse byte order (16 bit)
  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
  \param [in]    value  Value to reverse
  \return               Reversed value
 *//**
  \brief   Reverse byte order (16 bit)
  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
  \param [in]    value  Value to reverse
  \return               Reversed value
 *//**
  \brief   Reverse byte order (32 bit)
  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
  \param [in]    value  Value to reverse
  \return               Reversed value
 *//**
  \brief   Data Memory Barrier
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 *//**
  \brief   Data Synchronization Barrier
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 *//**
  \brief   Instruction Synchronization Barrier
  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 *//**
  \brief   Send Event
  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 *//**
  \brief   Wait For Event
  \details Wait For Event is a hint instruction that permits the processor to enter
           a low-power state until one of a number of events occurs.
 *//**
  \brief   Wait For Interrupt
  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
 *//**
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 *//* Define macros for porting to both thumb1 and thumb2.
 * For thumb1, use low register (r0-r7), specified by constraint "l"
 * Otherwise, use general registers, specified by constraint "r" *//** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  Access to dedicated instructions
  @{
*//* ##########################  Core Instruction Access  ######################### *//*@} end of CMSIS_Core_RegAccFunctions *//* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)// Re-enable using built-in when GCC has been fixed/**
  \brief   Set FPSCR
  \details Assigns the given value to the Floating Point Status/Control register.
  \param [in]    fpscr  Floating Point Status/Control value to set
 *//**
  \brief   Get FPSCR
  \details Returns the current value of the Floating Point Status/Control register.
  \return               Floating Point Status/Control register value
 */// without main extensions, the non-secure MSPLIM is RAZ/WI/**
  \brief   Set Main Stack Pointer Limit (non-secure)
  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
  Stack Pointer Limit register hence the write is silently ignored.

  \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secure state.
  \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 *//**
  \brief   Set Main Stack Pointer Limit
  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
  Stack Pointer Limit register hence the write is silently ignored in non-secure
  mode.

  \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
  \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 *//**
  \brief   Get Main Stack Pointer Limit (non-secure)
  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
  Stack Pointer Limit register hence zero is returned always.

  \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in secure state.
  \return               MSPLIM Register value
 *//**
  \brief   Get Main Stack Pointer Limit
  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
  Stack Pointer Limit register hence zero is returned always in non-secure
  mode.

  \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
  \return               MSPLIM Register value
 */// without main extensions, the non-secure PSPLIM is RAZ/WI/**
  \brief   Set Process Stack Pointer (non-secure)
  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
  Stack Pointer Limit register hence the write is silently ignored.

  \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.
  \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 *//**
  \brief   Set Process Stack Pointer Limit
  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
  Stack Pointer Limit register hence the write is silently ignored in non-secure
  mode.
  
  \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
  \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 *//**
  \brief   Get Process Stack Pointer Limit (non-secure)
  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
  Stack Pointer Limit register hence zero is returned always.

  \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.
  \return               PSPLIM Register value
 *//**
  \brief   Get Process Stack Pointer Limit
  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
  Stack Pointer Limit register hence zero is returned always in non-secure
  mode.
  
  \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
  \return               PSPLIM Register value
 *//**
  \brief   Set Fault Mask (non-secure)
  \details Assigns the given value to the non-secure Fault Mask register when in secure state.
  \param [in]    faultMask  Fault Mask value to set
 *//**
  \brief   Set Fault Mask
  \details Assigns the given value to the Fault Mask register.
  \param [in]    faultMask  Fault Mask value to set
 *//**
  \brief   Get Fault Mask (non-secure)
  \details Returns the current value of the non-secure Fault Mask register when in secure state.
  \return               Fault Mask register value
 *//**
  \brief   Get Fault Mask
  \details Returns the current value of the Fault Mask register.
  \return               Fault Mask register value
 *//**
  \brief   Set Base Priority with condition
  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
           or the new value increases the BASEPRI priority level.
  \param [in]    basePri  Base Priority value to set
 *//**
  \brief   Set Base Priority (non-secure)
  \details Assigns the given value to the non-secure Base Priority register when in secure state.
  \param [in]    basePri  Base Priority value to set
 *//**
  \brief   Set Base Priority
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 *//**
  \brief   Get Base Priority (non-secure)
  \details Returns the current value of the non-secure Base Priority register when in secure state.
  \return               Base Priority register value
 *//**
  \brief   Get Base Priority
  \details Returns the current value of the Base Priority register.
  \return               Base Priority register value
 *//**
  \brief   Disable FIQ
  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
           Can only be executed in Privileged modes.
 *//**
  \brief   Enable FIQ
  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
           Can only be executed in Privileged modes.
 *//**
  \brief   Set Priority Mask (non-secure)
  \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
  \param [in]    priMask  Priority Mask
 *//**
  \brief   Set Priority Mask
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 *//**
  \brief   Get Priority Mask (non-secure)
  \details Returns the current state of the non-secure priority mask bit from the Priority Mask Register when in secure state.
  \return               Priority Mask value
 *//**
  \brief   Get Priority Mask
  \details Returns the current state of the priority mask bit from the Priority Mask Register.
  \return               Priority Mask value
 *//**
  \brief   Set Stack Pointer (non-secure)
  \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
  \param [in]    topOfStack  Stack Pointer value to set
 *//**
  \brief   Get Stack Pointer (non-secure)
  \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
  \return               SP Register value
 *//**
  \brief   Set Main Stack Pointer (non-secure)
  \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 *//**
  \brief   Set Main Stack Pointer
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 *//**
  \brief   Get Main Stack Pointer (non-secure)
  \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure state.
  \return               MSP Register value
 *//**
  \brief   Get Main Stack Pointer
  \details Returns the current value of the Main Stack Pointer (MSP).
  \return               MSP Register value
 *//**
  \brief   Set Process Stack Pointer (non-secure)
  \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure state.
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 *//**
  \brief   Set Process Stack Pointer
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 *//**
  \brief   Get Process Stack Pointer (non-secure)
  \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure state.
  \return               PSP Register value
 *//**
  \brief   Get Process Stack Pointer
  \details Returns the current value of the Process Stack Pointer (PSP).
  \return               PSP Register value
 *//**
  \brief   Get xPSR Register
  \details Returns the content of the xPSR Register.
  \return               xPSR Register value
 *//**
  \brief   Get APSR Register
  \details Returns the content of the APSR Register.
  \return               APSR Register value
 *//**
  \brief   Get IPSR Register
  \details Returns the content of the IPSR Register.
  \return               IPSR Register value
 *//**
  \brief   Set Control Register (non-secure)
  \details Writes the given value to the non-secure Control Register when in secure state.
  \param [in]    control  Control Register value to set
 *//**
  \brief   Set Control Register
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 *//**
  \brief   Get Control Register (non-secure)
  \details Returns the content of the non-secure Control Register when in secure mode.
  \return               non-secure Control Register value
 *//**
  \brief   Get Control Register
  \details Returns the content of the Control Register.
  \return               Control Register value
 *//**
  \brief   Disable IRQ Interrupts
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 *//**
  \brief   Enable IRQ Interrupts
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 *//** \ingroup  CMSIS_Core_FunctionInterface
    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  @{
 *//* ###########################  Core Function Access  ########################### *//**
  \brief   Initializes data and bss sections
  \details This default implementations initialized all data and additional bss
           sections relying on .copy.table and .zero.table specified properly
           in the used linker script.
  
 *//* #########################  Startup and Lowlevel Init  ######################## *//* deprecated *//* CMSIS compiler specific defines *//* Fallback for __has_builtin *//* ignore some GCC warnings *//*
 * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @file     cmsis_gcc.h
 * @brief    CMSIS compiler GCC header file
 * @version  V5.3.0
 * @date     26. March 2020
 ******************************************************************************/ptraddrop1op2fpscrfaultMaskbasePripriMasktopOfMainStacktopOfProcStackcontrol/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/CMSIS/cmsis_compiler.h"cmsis_gcc.h"__CMSIS_COMPILER_Hdefined ( __CC_ARM )defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)defined ( __GNUC__ )defined ( __TI_ARM__ )defined ( __TASKING__ )defined ( __CSMC__ )/* __CMSIS_COMPILER_H */// NO RETURN is automatically detected hence no warning here/*
 * COSMIC Compiler
 *//*
   * The CMSIS functions have been implemented as intrinsics in the compiler.
   * Please use "carm -?i" to get an up to date list of all intrinsics,
   * Including the CMSIS ones.
   *//*
 * TASKING Compiler
 *//*
 * TI Arm Compiler
 *//*
 * IAR Compiler
 *//*
 * GNU Compiler
 *//*
 * Arm Compiler above 6.10.1 (armclang)
 *//*
 * Arm Compiler 6.6 LTM (armclang)
 *//*
 * Arm Compiler 4/5
 *//*
 * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @file     cmsis_compiler.h
 * @brief    CMSIS compiler generic header file
 * @version  V5.1.0
 * @date     09. October 2018
 ******************************************************************************//Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/CMSIS/mpu_armv7.hARM_MPU_Loadconst ARM_MPU_Region_tconst ARM_MPU_Region_t *rowWordSizesizeof(ARM_MPU_Region_t)4Usizeof(ARM_MPU_Region_t)/4UMPU_TYPE_RALIASESconst uint32_t *__restrict__375815372834723758157200MPU_Type *MPU3758157212&(MPU->RBAR)ARM_MPU_OrderedMemcpyARM_MPU_SetRegionExARM_MPU_SetRegionARM_MPU_ClrRegionARM_MPU_Disable33283758157056SCB_Type *SCB65536SCB_SHCSR_MEMFAULTENA_Msk4294901759~SCB_SHCSR_MEMFAULTENA_MskMPU_CTRL_ENABLE_Msk4294967294~MPU_CTRL_ENABLE_MskARM_MPU_EnableARM_MPU_Region_tRASRRBARARM_MPU_CACHEP_WB_NWA3UARM_MPU_CACHEP_WT_NWA2UARM_MPU_CACHEP_WB_WRA1UARM_MPU_CACHEP_NOCACHEARM_MPU_ACCESS_NORMAL(OuterCp,InnerCp,IsShareable)ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) >> 1U), ((InnerCp) & 1U))ARM_MPU_ACCESS_DEVICE(IsShareable)((IsShareable) ? ARM_MPU_ACCESS_(0U, 1U, 0U, 1U) : ARM_MPU_ACCESS_(2U, 0U, 0U, 0U))ARM_MPU_ACCESS_ORDEREDARM_MPU_ACCESS_(0U, 1U, 0U, 0U)ARM_MPU_RASR(DisableExec,AccessPermission,TypeExtField,IsShareable,IsCacheable,IsBufferable,SubRegionDisable,Size)ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)ARM_MPU_RASR_EX(DisableExec,AccessPermission,AccessAttributes,SubRegionDisable,Size)((((DisableExec) << MPU_RASR_XN_Pos) & MPU_RASR_XN_Msk) | (((AccessPermission) << MPU_RASR_AP_Pos) & MPU_RASR_AP_Msk) | (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) | (((SubRegionDisable) << MPU_RASR_SRD_Pos) & MPU_RASR_SRD_Msk) | (((Size) << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk) | (((MPU_RASR_ENABLE_Msk))))ARM_MPU_ACCESS_(TypeExtField,IsShareable,IsCacheable,IsBufferable)((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk) | (((IsShareable) << MPU_RASR_S_Pos) & MPU_RASR_S_Msk) | (((IsCacheable) << MPU_RASR_C_Pos) & MPU_RASR_C_Msk) | (((IsBufferable) << MPU_RASR_B_Pos) & MPU_RASR_B_Msk))ARM_MPU_RBAR(Region,BaseAddress)(((BaseAddress) & MPU_RBAR_ADDR_Msk) | ((Region) & MPU_RBAR_REGION_Msk) | (MPU_RBAR_VALID_Msk))ARM_MPU_AP_RO6UARM_MPU_AP_PRO5UARM_MPU_AP_FULLARM_MPU_AP_UROARM_MPU_AP_PRIVARM_MPU_AP_NONEARM_MPU_REGION_SIZE_4GB((uint8_t)0x1FU)ARM_MPU_REGION_SIZE_2GB((uint8_t)0x1EU)ARM_MPU_REGION_SIZE_1GB((uint8_t)0x1DU)ARM_MPU_REGION_SIZE_512MB((uint8_t)0x1CU)ARM_MPU_REGION_SIZE_256MB((uint8_t)0x1BU)ARM_MPU_REGION_SIZE_128MB((uint8_t)0x1AU)ARM_MPU_REGION_SIZE_64MB((uint8_t)0x19U)ARM_MPU_REGION_SIZE_32MB((uint8_t)0x18U)ARM_MPU_REGION_SIZE_16MB((uint8_t)0x17U)ARM_MPU_REGION_SIZE_8MB((uint8_t)0x16U)ARM_MPU_REGION_SIZE_4MB((uint8_t)0x15U)ARM_MPU_REGION_SIZE_2MB((uint8_t)0x14U)ARM_MPU_REGION_SIZE_1MB((uint8_t)0x13U)ARM_MPU_REGION_SIZE_512KB((uint8_t)0x12U)ARM_MPU_REGION_SIZE_256KB((uint8_t)0x11U)ARM_MPU_REGION_SIZE_128KB((uint8_t)0x10U)ARM_MPU_REGION_SIZE_64KB((uint8_t)0x0FU)ARM_MPU_REGION_SIZE_32KB((uint8_t)0x0EU)ARM_MPU_REGION_SIZE_16KB((uint8_t)0x0DU)ARM_MPU_REGION_SIZE_8KB((uint8_t)0x0CU)ARM_MPU_REGION_SIZE_4KB((uint8_t)0x0BU)ARM_MPU_REGION_SIZE_2KB((uint8_t)0x0AU)ARM_MPU_REGION_SIZE_1KB((uint8_t)0x09U)ARM_MPU_REGION_SIZE_512B((uint8_t)0x08U)ARM_MPU_REGION_SIZE_256B((uint8_t)0x07U)ARM_MPU_REGION_SIZE_128B((uint8_t)0x06U)ARM_MPU_REGION_SIZE_64B((uint8_t)0x05U)ARM_MPU_REGION_SIZE_32B((uint8_t)0x04U)ARM_MPU_ARMV7_H/** Load the given number of MPU regions from a table.
* \param table Pointer to the MPU configuration table.
* \param cnt Amount of regions to be configured.
*//** Memcopy with strictly ordered memory access, e.g. for register targets.
* \param dst Destination data is copied to.
* \param src Source data is copied from.
* \param len Amount of data words to be copied.
*//** Configure the given MPU region.
* \param rnr Region number to be configured.
* \param rbar Value for RBAR register.
* \param rsar Value for RSAR register.
*//** Configure an MPU region.
* \param rbar Value for RBAR register.
* \param rsar Value for RSAR register.
*//** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*//** Disable the MPU.
*//** Enable the MPU.
* \param MPU_Control Default access permissions for unconfigured regions.
*///!< The region attribute and size register value (RASR) \ref MPU_RASR//!< The region base address register value (RBAR)/**
* Struct for a single MPU Region
*//**
* MPU Memory Access Attribute write-back, no write allocate policy.
*//**
* MPU Memory Access Attribute write-through, no write allocate policy.
*//**
* MPU Memory Access Attribute write-back, write and read allocate policy.
*//**
* MPU Memory Access Attribute non-cacheable policy.
*//**
* MPU Memory Access Attribute for normal memory.
*  - TEX: 1BBb (reflecting outer cacheability rules)
*  - Shareable or non-shareable
*  - Cacheable or non-cacheable (reflecting inner cacheability rules)
*  - Bufferable or non-bufferable (reflecting inner cacheability rules)
*
* \param OuterCp Configures the outer cache policy.
* \param InnerCp Configures the inner cache policy.
* \param IsShareable Configures the memory as shareable or non-shareable.
*//**
* MPU Memory Access Attribute for device memory.
*  - TEX: 000b (if shareable) or 010b (if non-shareable)
*  - Shareable or non-shareable
*  - Non-cacheable
*  - Bufferable (if shareable) or non-bufferable (if non-shareable)
*
* \param IsShareable Configures the device memory as shareable or non-shareable.
*//**
* MPU Memory Access Attribute for strongly ordered memory.
*  - TEX: 000b
*  - Shareable
*  - Non-cacheable
*  - Non-bufferable
*//**
* MPU Region Attribute and Size Register Value
* 
* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
* \param IsShareable       Region is shareable between multiple bus masters.
* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
* \param SubRegionDisable  Sub-region disable field.
* \param Size              Region size of the region to be configured, for example 4K, 8K.
*//**
* MPU Region Attribute and Size Register Value
* 
* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
* \param AccessAttributes  Memory access attribution, see \ref ARM_MPU_ACCESS_.
* \param SubRegionDisable  Sub-region disable field.
* \param Size              Region size of the region to be configured, for example 4K, 8K.
*//**
* MPU Memory Access Attributes
* 
* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
* \param IsShareable       Region is shareable between multiple bus masters.
* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
*//** MPU Region Base Address Register Value
*
* \param Region The region to be configured, number 0 to 15.
* \param BaseAddress The base address for the region.
*////!< MPU Access Permission read-only access///!< MPU Access Permission privileged access read-only///!< MPU Access Permission full access///!< MPU Access Permission unprivileged access read-only///!< MPU Access Permission privileged access only///!< MPU Access Permission no access///!< MPU Region Size 4 GBytes///!< MPU Region Size 2 GBytes///!< MPU Region Size 1 GByte///!< MPU Region Size 512 MBytes///!< MPU Region Size 256 MBytes///!< MPU Region Size 128 MBytes///!< MPU Region Size 64 MBytes///!< MPU Region Size 32 MBytes///!< MPU Region Size 16 MBytes///!< MPU Region Size 8 MBytes///!< MPU Region Size 4 MBytes///!< MPU Region Size 2 MBytes///!< MPU Region Size 1 MByte///!< MPU Region Size 512 KBytes///!< MPU Region Size 256 KBytes///!< MPU Region Size 128 KBytes///!< MPU Region Size 64 KBytes///!< MPU Region Size 32 KBytes///!< MPU Region Size 16 KBytes///!< MPU Region Size 8 KBytes///!< MPU Region Size 4 KBytes///!< MPU Region Size 2 KBytes///!< MPU Region Size 1 KByte///!< MPU Region Size 512 Bytes///!< MPU Region Size 256 Bytes///!< MPU Region Size 128 Bytes///!< MPU Region Size 64 Bytes///!< MPU Region Size 32 Bytes/*
 * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//******************************************************************************
 * @file     mpu_armv7.h
 * @brief    CMSIS MPU API for Armv7-M MPU
 * @version  V5.1.1
 * @date     10. February 2020
 ******************************************************************************/tablecntdstlenrnrrbarrasrMPU_Control/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/CMSIS/core_cm3.h"mpu_armv7.h""cmsis_compiler.h""cmsis_version.h"ITM_CheckCharvolatile int32_t1520786085ITM_RXBUFFER_EMPTY(0)ITM_ReceiveCharch-1ITM_SendChar3758096384ITM_Type *ITMITM_TCR_ITMENA_Msk0UL1ULvolatile union <unnamed>volatile union <unnamed>[32]union <unnamed>[32]volatile union <unnamed> *union <unnamed> *SysTick_Config16777215SysTick_LOAD_RELOAD_Msk(1UL)3758153744SysTick_Type *SysTickSysTick_IRQn__NVIC_PRIO_BITS1UL << __NVIC_PRIO_BITS(1UL << __NVIC_PRIO_BITS)(1UL << __NVIC_PRIO_BITS) - 1ULSysTick_CTRL_CLKSOURCE_MskSysTick_CTRL_TICKINT_MskSysTick_CTRL_ENABLE_Msk(0UL)SCB_GetFPUType__NVIC_SystemReset15300x5FAULSCB_AIRCR_VECTKEY_Pos1002700800x5FAUL << SCB_AIRCR_VECTKEY_Pos(0x5FAUL << SCB_AIRCR_VECTKEY_Pos)1792SCB_AIRCR_PRIGROUP_MskSCB_AIRCR_SYSRESETREQ_Msk__NVIC_GetVectorvectorsNVIC_USER_IRQ_OFFSET__NVIC_SetVectorNVIC_DecodePriorityuint32_t *constPriorityGroupTmp0x07UL(uint32_t)0x07ULPreemptPriorityBitsSubPriorityBits7UL(uint32_t)(__NVIC_PRIO_BITS)(uint32_t)7UL(uint32_t)0ULNVIC_EncodePriority__NVIC_GetPriority3758153984NVIC_Type *NVICvolatile uint8_t[240]unsigned char[240]240240U8U8U - __NVIC_PRIO_BITS(8U - __NVIC_PRIO_BITS)volatile uint8_t[12]unsigned char[12]12U0xFUL4UL__NVIC_SetPriority2550xFFUL(uint32_t)0xFFUL__NVIC_GetActivevolatile uint32_t[8]unsigned long[8]5UL0x1FUL__NVIC_ClearPendingIRQ__NVIC_SetPendingIRQticksIRQnvectorPriorityPriorityGrouppPreemptPrioritypSubPriorityPreemptPrioritySubPrioritypriority__NVIC_GetPendingIRQ__NVIC_DisableIRQ__NVIC_GetEnableIRQ__NVIC_EnableIRQ__NVIC_GetPriorityGroupingSCB_AIRCR_PRIGROUP_Pos__NVIC_SetPriorityGroupingreg_value655354294901760SCB_AIRCR_VECTKEY_Msk4294903552(uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk))63743~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk))(uint32_t)0x5FAUL(uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos)CoreDebug_TypeMPU_TypeTPI_TypeDWT_TypeITM_TypeSysTick_TypeSCnSCB_TypeSCB_TypeNVIC_TypeCONTROL_TypexPSR_TypeIPSR_TypeAPSR_TypeDEMCRDCRDRDCRSRDHCSRRASR_A3RBAR_A3RASR_A2RBAR_A2RASR_A1RBAR_A1RNRCTRLconst volatile uint32_tTYPEDEVTYPEDEVIDuint32_t[8]RESERVED7CLAIMCLRCLAIMSETuint32_t[39]unsigned long[39]39URESERVED5ITCTRLFIFO1ITATBCTR0uint32_t[1]RESERVED4ITATBCTR2FIFO0TRIGGERuint32_t[759]unsigned long[759]759759URESERVED3FSCRFFCRFFSRuint32_t[131]unsigned long[131]131131URESERVED2SPPRuint32_t[55]unsigned long[55]5555URESERVED1ACPRuint32_t[2]RESERVED0CSPSRSSPSRFUNCTION3MASK3COMP3FUNCTION2MASK2COMP2FUNCTION1MASK1COMP1FUNCTION0MASK0COMP0PCSRFOLDCNTLSUCNTSLEEPCNTEXCCNTCPICNTCYCCNTCID3CID2CID1CID0PID3PID2PID1PID0PID7PID6PID5PID4uint32_t[6]unsigned long[6]LSRLARuint32_t[43]unsigned long[43]43Uuint32_t[32]unsigned long[32]TCRuint32_t[15]unsigned long[15]15UTPRTERuint32_t[864]unsigned long[864]864864UPORTu32u16u8CALIBVALLOADACTLRICTRCPACRuint32_t[5]unsigned long[5]const volatile uint32_t[5]ISARconst volatile uint32_t[4]unsigned long[4]MMFRADRDFRconst volatile uint32_t[2]PFRAFSRBFARMMFARDFSRHFSRCFSRSHCSRSHPCCRSCRAIRCRVTORICSRCPUIDSTIRuint32_t[644]unsigned long[644]644644UIPuint32_t[56]unsigned long[56]5656UIABRuint32_t[24]unsigned long[24]24UICPRISPRICERISERwb_reserved1SPSELnPRIVNZCVQICI_IT_2TICI_IT_1_reserved0ISRITM_RxBuffer((int32_t)0x5AA55AA5U)EXC_RETURN_THREAD_PSP(0xFFFFFFFDUL)EXC_RETURN_THREAD_MSP(0xFFFFFFF9UL)EXC_RETURN_HANDLER(0xFFFFFFF1UL)NVIC_GetVectorNVIC_SetVectorNVIC_SystemResetNVIC_GetPriorityNVIC_SetPriorityNVIC_GetActiveNVIC_ClearPendingIRQNVIC_SetPendingIRQNVIC_GetPendingIRQNVIC_DisableIRQNVIC_GetEnableIRQNVIC_EnableIRQNVIC_GetPriorityGroupingNVIC_SetPriorityGrouping((MPU_Type *) MPU_BASE )MPU_BASE(SCS_BASE + 0x0D90UL)CoreDebug((CoreDebug_Type *) CoreDebug_BASE)TPI((TPI_Type *) TPI_BASE )DWT((DWT_Type *) DWT_BASE )((ITM_Type *) ITM_BASE )((NVIC_Type *) NVIC_BASE )((SysTick_Type *) SysTick_BASE )((SCB_Type *) SCB_BASE )SCnSCB((SCnSCB_Type *) SCS_BASE )SCB_BASE(SCS_BASE + 0x0D00UL)NVIC_BASE(SCS_BASE + 0x0100UL)SysTick_BASE(SCS_BASE + 0x0010UL)CoreDebug_BASE(0xE000EDF0UL)TPI_BASE(0xE0040000UL)DWT_BASE(0xE0001000UL)ITM_BASE(0xE0000000UL)SCS_BASE(0xE000E000UL)_FLD2VAL(field,value)(((uint32_t)(value) & field ## _Msk) >> field ## _Pos)_VAL2FLD(field,value)(((uint32_t)(value) << field ## _Pos) & field ## _Msk)CoreDebug_DEMCR_VC_CORERESET_Msk(1UL )CoreDebug_DEMCR_VC_CORERESET_PosCoreDebug_DEMCR_VC_MMERR_Msk(1UL << CoreDebug_DEMCR_VC_MMERR_Pos)CoreDebug_DEMCR_VC_MMERR_PosCoreDebug_DEMCR_VC_NOCPERR_Msk(1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)CoreDebug_DEMCR_VC_NOCPERR_PosCoreDebug_DEMCR_VC_CHKERR_Msk(1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)CoreDebug_DEMCR_VC_CHKERR_PosCoreDebug_DEMCR_VC_STATERR_Msk(1UL << CoreDebug_DEMCR_VC_STATERR_Pos)CoreDebug_DEMCR_VC_STATERR_Pos7UCoreDebug_DEMCR_VC_BUSERR_Msk(1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)CoreDebug_DEMCR_VC_BUSERR_PosCoreDebug_DEMCR_VC_INTERR_Msk(1UL << CoreDebug_DEMCR_VC_INTERR_Pos)CoreDebug_DEMCR_VC_INTERR_Pos9UCoreDebug_DEMCR_VC_HARDERR_Msk(1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)CoreDebug_DEMCR_VC_HARDERR_Pos10UCoreDebug_DEMCR_MON_EN_Msk(1UL << CoreDebug_DEMCR_MON_EN_Pos)CoreDebug_DEMCR_MON_EN_Pos16UCoreDebug_DEMCR_MON_PEND_Msk(1UL << CoreDebug_DEMCR_MON_PEND_Pos)CoreDebug_DEMCR_MON_PEND_Pos17UCoreDebug_DEMCR_MON_STEP_Msk(1UL << CoreDebug_DEMCR_MON_STEP_Pos)CoreDebug_DEMCR_MON_STEP_Pos18UCoreDebug_DEMCR_MON_REQ_Msk(1UL << CoreDebug_DEMCR_MON_REQ_Pos)CoreDebug_DEMCR_MON_REQ_Pos19UCoreDebug_DEMCR_TRCENA_Msk(1UL << CoreDebug_DEMCR_TRCENA_Pos)CoreDebug_DEMCR_TRCENA_PosCoreDebug_DCRSR_REGSEL_Msk(0x1FUL )CoreDebug_DCRSR_REGSEL_PosCoreDebug_DCRSR_REGWnR_Msk(1UL << CoreDebug_DCRSR_REGWnR_Pos)CoreDebug_DCRSR_REGWnR_PosCoreDebug_DHCSR_C_DEBUGEN_MskCoreDebug_DHCSR_C_DEBUGEN_PosCoreDebug_DHCSR_C_HALT_Msk(1UL << CoreDebug_DHCSR_C_HALT_Pos)CoreDebug_DHCSR_C_HALT_PosCoreDebug_DHCSR_C_STEP_Msk(1UL << CoreDebug_DHCSR_C_STEP_Pos)CoreDebug_DHCSR_C_STEP_PosCoreDebug_DHCSR_C_MASKINTS_Msk(1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)CoreDebug_DHCSR_C_MASKINTS_PosCoreDebug_DHCSR_C_SNAPSTALL_Msk(1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)CoreDebug_DHCSR_C_SNAPSTALL_PosCoreDebug_DHCSR_S_REGRDY_Msk(1UL << CoreDebug_DHCSR_S_REGRDY_Pos)CoreDebug_DHCSR_S_REGRDY_PosCoreDebug_DHCSR_S_HALT_Msk(1UL << CoreDebug_DHCSR_S_HALT_Pos)CoreDebug_DHCSR_S_HALT_PosCoreDebug_DHCSR_S_SLEEP_Msk(1UL << CoreDebug_DHCSR_S_SLEEP_Pos)CoreDebug_DHCSR_S_SLEEP_PosCoreDebug_DHCSR_S_LOCKUP_Msk(1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)CoreDebug_DHCSR_S_LOCKUP_PosCoreDebug_DHCSR_S_RETIRE_ST_Msk(1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)CoreDebug_DHCSR_S_RETIRE_ST_PosCoreDebug_DHCSR_S_RESET_ST_Msk(1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)CoreDebug_DHCSR_S_RESET_ST_Pos25UCoreDebug_DHCSR_DBGKEY_Msk(0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)CoreDebug_DHCSR_DBGKEY_PosMPU_RASR_ENABLE_MskMPU_RASR_ENABLE_PosMPU_RASR_SIZE_Msk(0x1FUL << MPU_RASR_SIZE_Pos)MPU_RASR_SIZE_PosMPU_RASR_SRD_Msk(0xFFUL << MPU_RASR_SRD_Pos)MPU_RASR_SRD_PosMPU_RASR_B_Msk(1UL << MPU_RASR_B_Pos)MPU_RASR_B_PosMPU_RASR_C_Msk(1UL << MPU_RASR_C_Pos)MPU_RASR_C_PosMPU_RASR_S_Msk(1UL << MPU_RASR_S_Pos)MPU_RASR_S_PosMPU_RASR_TEX_Msk(0x7UL << MPU_RASR_TEX_Pos)MPU_RASR_TEX_PosMPU_RASR_AP_Msk(0x7UL << MPU_RASR_AP_Pos)MPU_RASR_AP_PosMPU_RASR_XN_Msk(1UL << MPU_RASR_XN_Pos)MPU_RASR_XN_Pos28UMPU_RASR_ATTRS_Msk(0xFFFFUL << MPU_RASR_ATTRS_Pos)MPU_RASR_ATTRS_PosMPU_RBAR_REGION_Msk(0xFUL )MPU_RBAR_REGION_PosMPU_RBAR_VALID_Msk(1UL << MPU_RBAR_VALID_Pos)MPU_RBAR_VALID_PosMPU_RBAR_ADDR_Msk(0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)MPU_RBAR_ADDR_PosMPU_RNR_REGION_Msk(0xFFUL )MPU_RNR_REGION_PosMPU_CTRL_ENABLE_PosMPU_CTRL_HFNMIENA_Msk(1UL << MPU_CTRL_HFNMIENA_Pos)MPU_CTRL_HFNMIENA_PosMPU_CTRL_PRIVDEFENA_Msk(1UL << MPU_CTRL_PRIVDEFENA_Pos)MPU_CTRL_PRIVDEFENA_PosMPU_TYPE_SEPARATE_MskMPU_TYPE_SEPARATE_PosMPU_TYPE_DREGION_Msk(0xFFUL << MPU_TYPE_DREGION_Pos)MPU_TYPE_DREGION_PosMPU_TYPE_IREGION_Msk(0xFFUL << MPU_TYPE_IREGION_Pos)MPU_TYPE_IREGION_PosTPI_DEVTYPE_MajorType_Msk(0xFUL << TPI_DEVTYPE_MajorType_Pos)TPI_DEVTYPE_MajorType_PosTPI_DEVTYPE_SubType_MskTPI_DEVTYPE_SubType_PosTPI_DEVID_NrTraceInput_MskTPI_DEVID_NrTraceInput_PosTPI_DEVID_AsynClkIn_Msk(0x1UL << TPI_DEVID_AsynClkIn_Pos)TPI_DEVID_AsynClkIn_PosTPI_DEVID_MinBufSz_Msk(0x7UL << TPI_DEVID_MinBufSz_Pos)TPI_DEVID_MinBufSz_PosTPI_DEVID_PTINVALID_Msk(0x1UL << TPI_DEVID_PTINVALID_Pos)TPI_DEVID_PTINVALID_PosTPI_DEVID_MANCVALID_Msk(0x1UL << TPI_DEVID_MANCVALID_Pos)TPI_DEVID_MANCVALID_PosTPI_DEVID_NRZVALID_Msk(0x1UL << TPI_DEVID_NRZVALID_Pos)TPI_DEVID_NRZVALID_Pos11UTPI_ITCTRL_Mode_Msk(0x3UL )TPI_ITCTRL_Mode_PosTPI_ITATBCTR0_ATREADY1_Msk(0x1UL )TPI_ITATBCTR0_ATREADY1_PosTPI_ITATBCTR0_ATREADY2_MskTPI_ITATBCTR0_ATREADY2_PosTPI_FIFO1_ITM0_MskTPI_FIFO1_ITM0_PosTPI_FIFO1_ITM1_Msk(0xFFUL << TPI_FIFO1_ITM1_Pos)TPI_FIFO1_ITM1_PosTPI_FIFO1_ITM2_Msk(0xFFUL << TPI_FIFO1_ITM2_Pos)TPI_FIFO1_ITM2_PosTPI_FIFO1_ETM_bytecount_Msk(0x3UL << TPI_FIFO1_ETM_bytecount_Pos)TPI_FIFO1_ETM_bytecount_PosTPI_FIFO1_ETM_ATVALID_Msk(0x1UL << TPI_FIFO1_ETM_ATVALID_Pos)TPI_FIFO1_ETM_ATVALID_Pos26UTPI_FIFO1_ITM_bytecount_Msk(0x3UL << TPI_FIFO1_ITM_bytecount_Pos)TPI_FIFO1_ITM_bytecount_Pos27UTPI_FIFO1_ITM_ATVALID_Msk(0x1UL << TPI_FIFO1_ITM_ATVALID_Pos)TPI_FIFO1_ITM_ATVALID_Pos29UTPI_ITATBCTR2_ATREADY1_MskTPI_ITATBCTR2_ATREADY1_PosTPI_ITATBCTR2_ATREADY2_MskTPI_ITATBCTR2_ATREADY2_PosTPI_FIFO0_ETM0_MskTPI_FIFO0_ETM0_PosTPI_FIFO0_ETM1_Msk(0xFFUL << TPI_FIFO0_ETM1_Pos)TPI_FIFO0_ETM1_PosTPI_FIFO0_ETM2_Msk(0xFFUL << TPI_FIFO0_ETM2_Pos)TPI_FIFO0_ETM2_PosTPI_FIFO0_ETM_bytecount_Msk(0x3UL << TPI_FIFO0_ETM_bytecount_Pos)TPI_FIFO0_ETM_bytecount_PosTPI_FIFO0_ETM_ATVALID_Msk(0x1UL << TPI_FIFO0_ETM_ATVALID_Pos)TPI_FIFO0_ETM_ATVALID_PosTPI_FIFO0_ITM_bytecount_Msk(0x3UL << TPI_FIFO0_ITM_bytecount_Pos)TPI_FIFO0_ITM_bytecount_PosTPI_FIFO0_ITM_ATVALID_Msk(0x1UL << TPI_FIFO0_ITM_ATVALID_Pos)TPI_FIFO0_ITM_ATVALID_PosTPI_TRIGGER_TRIGGER_MskTPI_TRIGGER_TRIGGER_PosTPI_FFCR_EnFCont_Msk(0x1UL << TPI_FFCR_EnFCont_Pos)TPI_FFCR_EnFCont_PosTPI_FFCR_TrigIn_Msk(0x1UL << TPI_FFCR_TrigIn_Pos)TPI_FFCR_TrigIn_PosTPI_FFSR_FlInProg_MskTPI_FFSR_FlInProg_PosTPI_FFSR_FtStopped_Msk(0x1UL << TPI_FFSR_FtStopped_Pos)TPI_FFSR_FtStopped_PosTPI_FFSR_TCPresent_Msk(0x1UL << TPI_FFSR_TCPresent_Pos)TPI_FFSR_TCPresent_PosTPI_FFSR_FtNonStop_Msk(0x1UL << TPI_FFSR_FtNonStop_Pos)TPI_FFSR_FtNonStop_PosTPI_SPPR_TXMODE_MskTPI_SPPR_TXMODE_PosTPI_ACPR_PRESCALER_Msk(0x1FFFUL )TPI_ACPR_PRESCALER_PosDWT_FUNCTION_FUNCTION_MskDWT_FUNCTION_FUNCTION_PosDWT_FUNCTION_EMITRANGE_Msk(0x1UL << DWT_FUNCTION_EMITRANGE_Pos)DWT_FUNCTION_EMITRANGE_PosDWT_FUNCTION_CYCMATCH_Msk(0x1UL << DWT_FUNCTION_CYCMATCH_Pos)DWT_FUNCTION_CYCMATCH_PosDWT_FUNCTION_DATAVMATCH_Msk(0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)DWT_FUNCTION_DATAVMATCH_PosDWT_FUNCTION_LNK1ENA_Msk(0x1UL << DWT_FUNCTION_LNK1ENA_Pos)DWT_FUNCTION_LNK1ENA_PosDWT_FUNCTION_DATAVSIZE_Msk(0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)DWT_FUNCTION_DATAVSIZE_PosDWT_FUNCTION_DATAVADDR0_Msk(0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)DWT_FUNCTION_DATAVADDR0_PosDWT_FUNCTION_DATAVADDR1_Msk(0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)DWT_FUNCTION_DATAVADDR1_PosDWT_FUNCTION_MATCHED_Msk(0x1UL << DWT_FUNCTION_MATCHED_Pos)DWT_FUNCTION_MATCHED_PosDWT_MASK_MASK_MskDWT_MASK_MASK_PosDWT_FOLDCNT_FOLDCNT_MskDWT_FOLDCNT_FOLDCNT_PosDWT_LSUCNT_LSUCNT_MskDWT_LSUCNT_LSUCNT_PosDWT_SLEEPCNT_SLEEPCNT_MskDWT_SLEEPCNT_SLEEPCNT_PosDWT_EXCCNT_EXCCNT_MskDWT_EXCCNT_EXCCNT_PosDWT_CPICNT_CPICNT_MskDWT_CPICNT_CPICNT_PosDWT_CTRL_CYCCNTENA_MskDWT_CTRL_CYCCNTENA_PosDWT_CTRL_POSTPRESET_Msk(0xFUL << DWT_CTRL_POSTPRESET_Pos)DWT_CTRL_POSTPRESET_PosDWT_CTRL_POSTINIT_Msk(0xFUL << DWT_CTRL_POSTINIT_Pos)DWT_CTRL_POSTINIT_PosDWT_CTRL_CYCTAP_Msk(0x1UL << DWT_CTRL_CYCTAP_Pos)DWT_CTRL_CYCTAP_PosDWT_CTRL_SYNCTAP_Msk(0x3UL << DWT_CTRL_SYNCTAP_Pos)DWT_CTRL_SYNCTAP_PosDWT_CTRL_PCSAMPLENA_Msk(0x1UL << DWT_CTRL_PCSAMPLENA_Pos)DWT_CTRL_PCSAMPLENA_PosDWT_CTRL_EXCTRCENA_Msk(0x1UL << DWT_CTRL_EXCTRCENA_Pos)DWT_CTRL_EXCTRCENA_PosDWT_CTRL_CPIEVTENA_Msk(0x1UL << DWT_CTRL_CPIEVTENA_Pos)DWT_CTRL_CPIEVTENA_PosDWT_CTRL_EXCEVTENA_Msk(0x1UL << DWT_CTRL_EXCEVTENA_Pos)DWT_CTRL_EXCEVTENA_PosDWT_CTRL_SLEEPEVTENA_Msk(0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)DWT_CTRL_SLEEPEVTENA_PosDWT_CTRL_LSUEVTENA_Msk(0x1UL << DWT_CTRL_LSUEVTENA_Pos)DWT_CTRL_LSUEVTENA_Pos20UDWT_CTRL_FOLDEVTENA_Msk(0x1UL << DWT_CTRL_FOLDEVTENA_Pos)DWT_CTRL_FOLDEVTENA_Pos21UDWT_CTRL_CYCEVTENA_Msk(0x1UL << DWT_CTRL_CYCEVTENA_Pos)DWT_CTRL_CYCEVTENA_Pos22UDWT_CTRL_NOPRFCNT_Msk(0x1UL << DWT_CTRL_NOPRFCNT_Pos)DWT_CTRL_NOPRFCNT_PosDWT_CTRL_NOCYCCNT_Msk(0x1UL << DWT_CTRL_NOCYCCNT_Pos)DWT_CTRL_NOCYCCNT_PosDWT_CTRL_NOEXTTRIG_Msk(0x1UL << DWT_CTRL_NOEXTTRIG_Pos)DWT_CTRL_NOEXTTRIG_PosDWT_CTRL_NOTRCPKT_Msk(0x1UL << DWT_CTRL_NOTRCPKT_Pos)DWT_CTRL_NOTRCPKT_PosDWT_CTRL_NUMCOMP_Msk(0xFUL << DWT_CTRL_NUMCOMP_Pos)DWT_CTRL_NUMCOMP_PosITM_LSR_Present_MskITM_LSR_Present_PosITM_LSR_Access_Msk(1UL << ITM_LSR_Access_Pos)ITM_LSR_Access_PosITM_LSR_ByteAcc_Msk(1UL << ITM_LSR_ByteAcc_Pos)ITM_LSR_ByteAcc_PosITM_TCR_ITMENA_PosITM_TCR_TSENA_Msk(1UL << ITM_TCR_TSENA_Pos)ITM_TCR_TSENA_PosITM_TCR_SYNCENA_Msk(1UL << ITM_TCR_SYNCENA_Pos)ITM_TCR_SYNCENA_PosITM_TCR_DWTENA_Msk(1UL << ITM_TCR_DWTENA_Pos)ITM_TCR_DWTENA_PosITM_TCR_SWOENA_Msk(1UL << ITM_TCR_SWOENA_Pos)ITM_TCR_SWOENA_PosITM_TCR_TSPrescale_Msk(3UL << ITM_TCR_TSPrescale_Pos)ITM_TCR_TSPrescale_PosITM_TCR_GTSFREQ_Msk(3UL << ITM_TCR_GTSFREQ_Pos)ITM_TCR_GTSFREQ_PosITM_TCR_TraceBusID_Msk(0x7FUL << ITM_TCR_TraceBusID_Pos)ITM_TCR_TraceBusID_PosITM_TCR_BUSY_Msk(1UL << ITM_TCR_BUSY_Pos)ITM_TCR_BUSY_Pos23UITM_TPR_PRIVMASK_Msk(0xFFFFFFFFUL )ITM_TPR_PRIVMASK_PosSysTick_CALIB_TENMS_Msk(0xFFFFFFUL )SysTick_CALIB_TENMS_PosSysTick_CALIB_SKEW_Msk(1UL << SysTick_CALIB_SKEW_Pos)SysTick_CALIB_SKEW_Pos30USysTick_CALIB_NOREF_Msk(1UL << SysTick_CALIB_NOREF_Pos)SysTick_CALIB_NOREF_Pos31USysTick_VAL_CURRENT_MskSysTick_VAL_CURRENT_PosSysTick_LOAD_RELOAD_PosSysTick_CTRL_ENABLE_Pos(1UL << SysTick_CTRL_TICKINT_Pos)SysTick_CTRL_TICKINT_Pos(1UL << SysTick_CTRL_CLKSOURCE_Pos)SysTick_CTRL_CLKSOURCE_PosSysTick_CTRL_COUNTFLAG_Msk(1UL << SysTick_CTRL_COUNTFLAG_Pos)SysTick_CTRL_COUNTFLAG_PosSCnSCB_ACTLR_DISMCYCINT_MskSCnSCB_ACTLR_DISMCYCINT_PosSCnSCB_ACTLR_DISDEFWBUF_Msk(1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)SCnSCB_ACTLR_DISDEFWBUF_PosSCnSCB_ACTLR_DISFOLD_Msk(1UL << SCnSCB_ACTLR_DISFOLD_Pos)SCnSCB_ACTLR_DISFOLD_PosSCnSCB_ACTLR_DISFPCA_Msk(1UL << SCnSCB_ACTLR_DISFPCA_Pos)SCnSCB_ACTLR_DISFPCA_PosSCnSCB_ACTLR_DISOOFP_Msk(1UL << SCnSCB_ACTLR_DISOOFP_Pos)SCnSCB_ACTLR_DISOOFP_PosSCnSCB_ICTR_INTLINESNUM_MskSCnSCB_ICTR_INTLINESNUM_PosSCB_DFSR_HALTED_MskSCB_DFSR_HALTED_PosSCB_DFSR_BKPT_Msk(1UL << SCB_DFSR_BKPT_Pos)SCB_DFSR_BKPT_PosSCB_DFSR_DWTTRAP_Msk(1UL << SCB_DFSR_DWTTRAP_Pos)SCB_DFSR_DWTTRAP_PosSCB_DFSR_VCATCH_Msk(1UL << SCB_DFSR_VCATCH_Pos)SCB_DFSR_VCATCH_PosSCB_DFSR_EXTERNAL_Msk(1UL << SCB_DFSR_EXTERNAL_Pos)SCB_DFSR_EXTERNAL_PosSCB_HFSR_VECTTBL_Msk(1UL << SCB_HFSR_VECTTBL_Pos)SCB_HFSR_VECTTBL_PosSCB_HFSR_FORCED_Msk(1UL << SCB_HFSR_FORCED_Pos)SCB_HFSR_FORCED_PosSCB_HFSR_DEBUGEVT_Msk(1UL << SCB_HFSR_DEBUGEVT_Pos)SCB_HFSR_DEBUGEVT_PosSCB_CFSR_UNDEFINSTR_Msk(1UL << SCB_CFSR_UNDEFINSTR_Pos)SCB_CFSR_UNDEFINSTR_Pos(SCB_CFSR_USGFAULTSR_Pos + 0U)SCB_CFSR_INVSTATE_Msk(1UL << SCB_CFSR_INVSTATE_Pos)SCB_CFSR_INVSTATE_Pos(SCB_CFSR_USGFAULTSR_Pos + 1U)SCB_CFSR_INVPC_Msk(1UL << SCB_CFSR_INVPC_Pos)SCB_CFSR_INVPC_Pos(SCB_CFSR_USGFAULTSR_Pos + 2U)SCB_CFSR_NOCP_Msk(1UL << SCB_CFSR_NOCP_Pos)SCB_CFSR_NOCP_Pos(SCB_CFSR_USGFAULTSR_Pos + 3U)SCB_CFSR_UNALIGNED_Msk(1UL << SCB_CFSR_UNALIGNED_Pos)SCB_CFSR_UNALIGNED_Pos(SCB_CFSR_USGFAULTSR_Pos + 8U)SCB_CFSR_DIVBYZERO_Msk(1UL << SCB_CFSR_DIVBYZERO_Pos)SCB_CFSR_DIVBYZERO_Pos(SCB_CFSR_USGFAULTSR_Pos + 9U)SCB_CFSR_IBUSERR_Msk(1UL << SCB_CFSR_IBUSERR_Pos)SCB_CFSR_IBUSERR_Pos(SCB_CFSR_BUSFAULTSR_Pos + 0U)SCB_CFSR_PRECISERR_Msk(1UL << SCB_CFSR_PRECISERR_Pos)SCB_CFSR_PRECISERR_Pos(SCB_CFSR_BUSFAULTSR_Pos + 1U)SCB_CFSR_IMPRECISERR_Msk(1UL << SCB_CFSR_IMPRECISERR_Pos)SCB_CFSR_IMPRECISERR_Pos(SCB_CFSR_BUSFAULTSR_Pos + 2U)SCB_CFSR_UNSTKERR_Msk(1UL << SCB_CFSR_UNSTKERR_Pos)SCB_CFSR_UNSTKERR_Pos(SCB_CFSR_BUSFAULTSR_Pos + 3U)SCB_CFSR_STKERR_Msk(1UL << SCB_CFSR_STKERR_Pos)SCB_CFSR_STKERR_Pos(SCB_CFSR_BUSFAULTSR_Pos + 4U)SCB_CFSR_BFARVALID_Msk(1UL << SCB_CFSR_BFARVALID_Pos)SCB_CFSR_BFARVALID_Pos(SCB_CFSR_BUSFAULTSR_Pos + 7U)SCB_CFSR_IACCVIOL_MskSCB_CFSR_IACCVIOL_Pos(SCB_SHCSR_MEMFAULTACT_Pos + 0U)SCB_CFSR_DACCVIOL_Msk(1UL << SCB_CFSR_DACCVIOL_Pos)SCB_CFSR_DACCVIOL_Pos(SCB_SHCSR_MEMFAULTACT_Pos + 1U)SCB_CFSR_MUNSTKERR_Msk(1UL << SCB_CFSR_MUNSTKERR_Pos)SCB_CFSR_MUNSTKERR_Pos(SCB_SHCSR_MEMFAULTACT_Pos + 3U)SCB_CFSR_MSTKERR_Msk(1UL << SCB_CFSR_MSTKERR_Pos)SCB_CFSR_MSTKERR_Pos(SCB_SHCSR_MEMFAULTACT_Pos + 4U)SCB_CFSR_MMARVALID_Msk(1UL << SCB_CFSR_MMARVALID_Pos)SCB_CFSR_MMARVALID_Pos(SCB_SHCSR_MEMFAULTACT_Pos + 7U)SCB_CFSR_MEMFAULTSR_MskSCB_CFSR_MEMFAULTSR_PosSCB_CFSR_BUSFAULTSR_Msk(0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)SCB_CFSR_BUSFAULTSR_PosSCB_CFSR_USGFAULTSR_Msk(0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)SCB_CFSR_USGFAULTSR_PosSCB_SHCSR_MEMFAULTACT_MskSCB_SHCSR_MEMFAULTACT_PosSCB_SHCSR_BUSFAULTACT_Msk(1UL << SCB_SHCSR_BUSFAULTACT_Pos)SCB_SHCSR_BUSFAULTACT_PosSCB_SHCSR_USGFAULTACT_Msk(1UL << SCB_SHCSR_USGFAULTACT_Pos)SCB_SHCSR_USGFAULTACT_PosSCB_SHCSR_SVCALLACT_Msk(1UL << SCB_SHCSR_SVCALLACT_Pos)SCB_SHCSR_SVCALLACT_PosSCB_SHCSR_MONITORACT_Msk(1UL << SCB_SHCSR_MONITORACT_Pos)SCB_SHCSR_MONITORACT_PosSCB_SHCSR_PENDSVACT_Msk(1UL << SCB_SHCSR_PENDSVACT_Pos)SCB_SHCSR_PENDSVACT_PosSCB_SHCSR_SYSTICKACT_Msk(1UL << SCB_SHCSR_SYSTICKACT_Pos)SCB_SHCSR_SYSTICKACT_PosSCB_SHCSR_USGFAULTPENDED_Msk(1UL << SCB_SHCSR_USGFAULTPENDED_Pos)SCB_SHCSR_USGFAULTPENDED_PosSCB_SHCSR_MEMFAULTPENDED_Msk(1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)SCB_SHCSR_MEMFAULTPENDED_Pos13USCB_SHCSR_BUSFAULTPENDED_Msk(1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)SCB_SHCSR_BUSFAULTPENDED_Pos14USCB_SHCSR_SVCALLPENDED_Msk(1UL << SCB_SHCSR_SVCALLPENDED_Pos)SCB_SHCSR_SVCALLPENDED_Pos(1UL << SCB_SHCSR_MEMFAULTENA_Pos)SCB_SHCSR_MEMFAULTENA_PosSCB_SHCSR_BUSFAULTENA_Msk(1UL << SCB_SHCSR_BUSFAULTENA_Pos)SCB_SHCSR_BUSFAULTENA_PosSCB_SHCSR_USGFAULTENA_Msk(1UL << SCB_SHCSR_USGFAULTENA_Pos)SCB_SHCSR_USGFAULTENA_PosSCB_CCR_NONBASETHRDENA_MskSCB_CCR_NONBASETHRDENA_PosSCB_CCR_USERSETMPEND_Msk(1UL << SCB_CCR_USERSETMPEND_Pos)SCB_CCR_USERSETMPEND_PosSCB_CCR_UNALIGN_TRP_Msk(1UL << SCB_CCR_UNALIGN_TRP_Pos)SCB_CCR_UNALIGN_TRP_PosSCB_CCR_DIV_0_TRP_Msk(1UL << SCB_CCR_DIV_0_TRP_Pos)SCB_CCR_DIV_0_TRP_PosSCB_CCR_BFHFNMIGN_Msk(1UL << SCB_CCR_BFHFNMIGN_Pos)SCB_CCR_BFHFNMIGN_PosSCB_CCR_STKALIGN_Msk(1UL << SCB_CCR_STKALIGN_Pos)SCB_CCR_STKALIGN_PosSCB_SCR_SLEEPONEXIT_Msk(1UL << SCB_SCR_SLEEPONEXIT_Pos)SCB_SCR_SLEEPONEXIT_PosSCB_SCR_SLEEPDEEP_Msk(1UL << SCB_SCR_SLEEPDEEP_Pos)SCB_SCR_SLEEPDEEP_PosSCB_SCR_SEVONPEND_Msk(1UL << SCB_SCR_SEVONPEND_Pos)SCB_SCR_SEVONPEND_PosSCB_AIRCR_VECTRESET_MskSCB_AIRCR_VECTRESET_PosSCB_AIRCR_VECTCLRACTIVE_Msk(1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)SCB_AIRCR_VECTCLRACTIVE_Pos(1UL << SCB_AIRCR_SYSRESETREQ_Pos)SCB_AIRCR_SYSRESETREQ_Pos(7UL << SCB_AIRCR_PRIGROUP_Pos)SCB_AIRCR_ENDIANESS_Msk(1UL << SCB_AIRCR_ENDIANESS_Pos)SCB_AIRCR_ENDIANESS_PosSCB_AIRCR_VECTKEYSTAT_Msk(0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)SCB_AIRCR_VECTKEYSTAT_Pos(0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)SCB_VTOR_TBLOFF_Msk(0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)SCB_VTOR_TBLOFF_PosSCB_ICSR_VECTACTIVE_Msk(0x1FFUL )SCB_ICSR_VECTACTIVE_PosSCB_ICSR_RETTOBASE_Msk(1UL << SCB_ICSR_RETTOBASE_Pos)SCB_ICSR_RETTOBASE_PosSCB_ICSR_VECTPENDING_Msk(0x1FFUL << SCB_ICSR_VECTPENDING_Pos)SCB_ICSR_VECTPENDING_PosSCB_ICSR_ISRPENDING_Msk(1UL << SCB_ICSR_ISRPENDING_Pos)SCB_ICSR_ISRPENDING_PosSCB_ICSR_ISRPREEMPT_Msk(1UL << SCB_ICSR_ISRPREEMPT_Pos)SCB_ICSR_ISRPREEMPT_PosSCB_ICSR_PENDSTCLR_Msk(1UL << SCB_ICSR_PENDSTCLR_Pos)SCB_ICSR_PENDSTCLR_PosSCB_ICSR_PENDSTSET_Msk(1UL << SCB_ICSR_PENDSTSET_Pos)SCB_ICSR_PENDSTSET_PosSCB_ICSR_PENDSVCLR_Msk(1UL << SCB_ICSR_PENDSVCLR_Pos)SCB_ICSR_PENDSVCLR_PosSCB_ICSR_PENDSVSET_Msk(1UL << SCB_ICSR_PENDSVSET_Pos)SCB_ICSR_PENDSVSET_PosSCB_ICSR_NMIPENDSET_Msk(1UL << SCB_ICSR_NMIPENDSET_Pos)SCB_ICSR_NMIPENDSET_PosSCB_CPUID_REVISION_MskSCB_CPUID_REVISION_PosSCB_CPUID_PARTNO_Msk(0xFFFUL << SCB_CPUID_PARTNO_Pos)SCB_CPUID_PARTNO_PosSCB_CPUID_ARCHITECTURE_Msk(0xFUL << SCB_CPUID_ARCHITECTURE_Pos)SCB_CPUID_ARCHITECTURE_PosSCB_CPUID_VARIANT_Msk(0xFUL << SCB_CPUID_VARIANT_Pos)SCB_CPUID_VARIANT_PosSCB_CPUID_IMPLEMENTER_Msk(0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)SCB_CPUID_IMPLEMENTER_PosNVIC_STIR_INTID_MskNVIC_STIR_INTID_PosCONTROL_nPRIV_MskCONTROL_nPRIV_PosCONTROL_SPSEL_Msk(1UL << CONTROL_SPSEL_Pos)CONTROL_SPSEL_PosxPSR_ISR_MskxPSR_ISR_PosxPSR_ICI_IT_1_Msk(0x3FUL << xPSR_ICI_IT_1_Pos)xPSR_ICI_IT_1_PosxPSR_T_Msk(1UL << xPSR_T_Pos)xPSR_T_PosxPSR_ICI_IT_2_Msk(3UL << xPSR_ICI_IT_2_Pos)xPSR_ICI_IT_2_PosxPSR_Q_Msk(1UL << xPSR_Q_Pos)xPSR_Q_PosxPSR_V_Msk(1UL << xPSR_V_Pos)xPSR_V_PosxPSR_C_Msk(1UL << xPSR_C_Pos)xPSR_C_PosxPSR_Z_Msk(1UL << xPSR_Z_Pos)xPSR_Z_PosxPSR_N_Msk(1UL << xPSR_N_Pos)xPSR_N_PosIPSR_ISR_MskIPSR_ISR_PosAPSR_Q_Msk(1UL << APSR_Q_Pos)APSR_Q_PosAPSR_V_Msk(1UL << APSR_V_Pos)APSR_V_PosAPSR_C_Msk(1UL << APSR_C_Pos)APSR_C_PosAPSR_Z_Msk(1UL << APSR_Z_Pos)APSR_Z_PosAPSR_N_Msk(1UL << APSR_N_Pos)APSR_N_Pos__IOM__OM__IMvolatile const__IO__O__I__CORE_CM3_H_DEPENDANT__FPU_USED__CORTEX_M(3U)__CM3_CMSIS_VERSION((__CM3_CMSIS_VERSION_MAIN << 16U) | __CM3_CMSIS_VERSION_SUB )__CM3_CMSIS_VERSION_SUB(__CM_CMSIS_VERSION_SUB)__CM3_CMSIS_VERSION_MAIN(__CM_CMSIS_VERSION_MAIN)__CORE_CM3_H_GENERICdefined __TARGET_FPU_VFPdefined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)defined __ARM_FPdefined (__VFP_FP__) && !defined(__SOFTFP__)defined __ARMVFP__defined __TI_VFP_SUPPORT__defined __FPU_VFP__( __CSMC__ & 0x400U)__CMSIS_GENERICdefined __CHECK_DEVICE_DEFINES__CM3_REV__MPU_PRESENT__VTOR_PRESENT__Vendor_SysTickConfigdefined (__CM3_REV) && (__CM3_REV < 0x0201U)defined (__CM3_REV) && (__CM3_REV >= 0x200U)defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)CMSIS_NVIC_VIRTUALCMSIS_NVIC_VIRTUAL_HEADER_FILECMSIS_VECTAB_VIRTUALCMSIS_VECTAB_VIRTUAL_HEADER_FILEdefined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)/* __CMSIS_GENERIC *//* __CORE_CM3_H_DEPENDANT *//*@} end of CMSIS_core_DebugFunctions *//*    character available *//* no character available *//**
  \brief   ITM Check Character
  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
  \return          0  No character available.
  \return          1  Character available.
 *//* ready for next character *//**
  \brief   ITM Receive Character
  \details Inputs a character via the external variable \ref ITM_RxBuffer.
  \return             Received character.
  \return         -1  No character pending.
 *//* ITM Port #0 enabled *//* ITM enabled *//**
  \brief   ITM Send Character
  \details Transmits a character via the ITM channel 0, and
           \li Just returns when no debugger is connected that has booked the output.
           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
  \param [in]     ch  Character to transmit.
  \returns            Character to transmit.
 *//*!< Value identifying \ref ITM_RxBuffer is ready for next character. *//*!< External variable to receive characters. *//**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_core_DebugFunctions ITM Functions
  \brief    Functions that access the ITM debug interface.
  @{
 *//* ##################################### Debug In/Output function ########################################### *//*@} end of CMSIS_Core_SysTickFunctions *//* Function successful *//* Enable SysTick IRQ and SysTick Timer *//* Load the SysTick Counter Value *//* set Priority for Systick Interrupt *//* set reload register *//* Reload value impossible *//**
  \brief   System Tick Configuration
  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
           Counter is in free running mode to generate periodic interrupts.
  \param [in]  ticks  Number of ticks between two interrupts.
  \return          0  Function succeeded.
  \return          1  Function failed.
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 *//**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
  \brief    Functions that configure the System.
  @{
 *//* ##################################    SysTick function  ############################################ *//*@} end of CMSIS_Core_FpuFunctions *//* No FPU *//**
  \brief   get FPU type
  \details returns the FPU type
  \returns
   - \b  0: No FPU
   - \b  1: Single precision FPU
   - \b  2: Double + Single precision FPU
 *//**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_FpuFunctions FPU Functions
  \brief    Function that provides FPU type.
  @{
 *//* ##########################  FPU functions  #################################### *//* ##########################  MPU functions  #################################### *//*@} end of CMSIS_Core_NVICFunctions *//* wait until reset *//* Ensure completion of memory access *//* Keep priority group unchanged *//* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset *//**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 *//**
  \brief   Get Interrupt Vector
  \details Reads an interrupt vector from interrupt vector table.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]   IRQn      Interrupt number.
  \return                 Address of interrupt handler function
 *//* ARM Application Note 321 states that the M3 does not require the architectural barrier *//**
  \brief   Set Interrupt Vector
  \details Sets an interrupt vector in SRAM based interrupt vector table.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
           VTOR must been relocated to SRAM before.
  \param [in]   IRQn      Interrupt number
  \param [in]   vector    Address of interrupt handler function
 *//* only values 0..7 are used          *//**
  \brief   Decode Priority
  \details Decodes an interrupt priority value with a given priority group to
           preemptive priority value and subpriority value.
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
  \param [in]     PriorityGroup  Used priority group.
  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
  \param [out]     pSubPriority  Subpriority value (starting from 0).
 *//**
  \brief   Encode Priority
  \details Encodes the priority for an interrupt with the given priority group,
           preemptive priority value, and subpriority value.
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]     PriorityGroup  Used priority group.
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 *//**
  \brief   Get Interrupt Priority
  \details Reads the priority of a device specific interrupt or a processor exception.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 *//**
  \brief   Set Interrupt Priority
  \details Sets the priority of a device specific interrupt or a processor exception.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 *//**
  \brief   Get Active Interrupt
  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt status is not active.
  \return             1  Interrupt status is active.
  \note    IRQn must not be negative.
 *//**
  \brief   Clear Pending Interrupt
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 *//**
  \brief   Set Pending Interrupt
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 *//**
  \brief   Get Pending Interrupt
  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 *//**
  \brief   Disable Interrupt
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 *//**
  \brief   Get Interrupt Enable status
  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt is not enabled.
  \return             1  Interrupt is enabled.
  \note    IRQn must not be negative.
 *//**
  \brief   Enable Interrupt
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 *//**
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 *//* Insert write key and priority group *//* clear bits to change               *//* read old register configuration    *//**
  \brief   Set Priority Grouping
  \details Sets the priority grouping field using the required unlock sequence.
           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
           Only values from 0..7 are used.
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 *//* return to Thread mode, uses PSP after return                                *//* return to Thread mode, uses MSP after return                                *//* return to Handler mode, uses MSP after return                               *//* The following EXC_RETURN values are saved the LR on exception entry *//* (CMSIS_VECTAB_VIRTUAL) *//* CMSIS_NVIC_VIRTUAL *//**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
  \brief    Functions that manage interrupts and exceptions via the NVIC.
  @{
 *//* ##########################   NVIC functions  #################################### *//**
  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
*//*******************************************************************************
 *                Hardware Abstraction Layer
  Core Function Interface contains:
  - Core NVIC Functions
  - Core SysTick Functions
  - Core Debug Functions
  - Core Register Access Functions
 ******************************************************************************//*@} *//*!< Memory Protection Unit *//*!< Core Debug configuration struct *//*!< TPI configuration struct *//*!< DWT configuration struct *//*!< ITM configuration struct *//*!< NVIC configuration struct *//*!< SysTick configuration struct *//*!< SCB configuration struct *//*!< System control Register not in SCB *//*!< System Control Block Base Address *//*!< NVIC Base Address *//*!< SysTick Base Address *//*!< Core Debug Base Address *//*!< TPI Base Address *//*!< DWT Base Address *//*!< ITM Base Address *//*!< System Control Space Base Address *//* Memory mapping of Core Hardware *//**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_core_base     Core Definitions
  \brief      Definitions for base addresses, unions, and structures.
  @{
 *//*@} end of group CMSIS_core_bitfield *//**
  \brief     Mask and shift a register value to extract a bit filed value.
  \param[in] field  Name of the register bit field.
  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
  \return           Masked and shifted bit field value.
*//**
  \brief   Mask and shift a bit field value for use in a register bit range.
  \param[in] field  Name of the register bit field.
  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
  \return           Masked and shifted value.
*//**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_core_bitfield     Core register bit field macros
  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
  @{
 *//*@} end of group CMSIS_CoreDebug *//*!< CoreDebug DEMCR: VC_CORERESET Mask *//*<< CoreDebug_DEMCR_VC_CORERESET_Pos*//*!< CoreDebug DEMCR: VC_CORERESET Position *//*!< CoreDebug DEMCR: VC_MMERR Mask *//*!< CoreDebug DEMCR: VC_MMERR Position *//*!< CoreDebug DEMCR: VC_NOCPERR Mask *//*!< CoreDebug DEMCR: VC_NOCPERR Position *//*!< CoreDebug DEMCR: VC_CHKERR Mask *//*!< CoreDebug DEMCR: VC_CHKERR Position *//*!< CoreDebug DEMCR: VC_STATERR Mask *//*!< CoreDebug DEMCR: VC_STATERR Position *//*!< CoreDebug DEMCR: VC_BUSERR Mask *//*!< CoreDebug DEMCR: VC_BUSERR Position *//*!< CoreDebug DEMCR: VC_INTERR Mask *//*!< CoreDebug DEMCR: VC_INTERR Position *//*!< CoreDebug DEMCR: VC_HARDERR Mask *//*!< CoreDebug DEMCR: VC_HARDERR Position *//*!< CoreDebug DEMCR: MON_EN Mask *//*!< CoreDebug DEMCR: MON_EN Position *//*!< CoreDebug DEMCR: MON_PEND Mask *//*!< CoreDebug DEMCR: MON_PEND Position *//*!< CoreDebug DEMCR: MON_STEP Mask *//*!< CoreDebug DEMCR: MON_STEP Position *//*!< CoreDebug DEMCR: MON_REQ Mask *//*!< CoreDebug DEMCR: MON_REQ Position *//*!< CoreDebug DEMCR: TRCENA Mask *//*!< CoreDebug DEMCR: TRCENA Position *//* Debug Exception and Monitor Control Register Definitions *//*!< CoreDebug DCRSR: REGSEL Mask *//*<< CoreDebug_DCRSR_REGSEL_Pos*//*!< CoreDebug DCRSR: REGSEL Position *//*!< CoreDebug DCRSR: REGWnR Mask *//*!< CoreDebug DCRSR: REGWnR Position *//* Debug Core Register Selector Register Definitions *//*!< CoreDebug DHCSR: C_DEBUGEN Mask *//*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*//*!< CoreDebug DHCSR: C_DEBUGEN Position *//*!< CoreDebug DHCSR: C_HALT Mask *//*!< CoreDebug DHCSR: C_HALT Position *//*!< CoreDebug DHCSR: C_STEP Mask *//*!< CoreDebug DHCSR: C_STEP Position *//*!< CoreDebug DHCSR: C_MASKINTS Mask *//*!< CoreDebug DHCSR: C_MASKINTS Position *//*!< CoreDebug DHCSR: C_SNAPSTALL Mask *//*!< CoreDebug DHCSR: C_SNAPSTALL Position *//*!< CoreDebug DHCSR: S_REGRDY Mask *//*!< CoreDebug DHCSR: S_REGRDY Position *//*!< CoreDebug DHCSR: S_HALT Mask *//*!< CoreDebug DHCSR: S_HALT Position *//*!< CoreDebug DHCSR: S_SLEEP Mask *//*!< CoreDebug DHCSR: S_SLEEP Position *//*!< CoreDebug DHCSR: S_LOCKUP Mask *//*!< CoreDebug DHCSR: S_LOCKUP Position *//*!< CoreDebug DHCSR: S_RETIRE_ST Mask *//*!< CoreDebug DHCSR: S_RETIRE_ST Position *//*!< CoreDebug DHCSR: S_RESET_ST Mask *//*!< CoreDebug DHCSR: S_RESET_ST Position *//*!< CoreDebug DHCSR: DBGKEY Mask *//*!< CoreDebug DHCSR: DBGKEY Position *//* Debug Halting Control and Status Register Definitions *//*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register *//*!< Offset: 0x008 (R/W)  Debug Core Register Data Register *//*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register *//*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register *//**
  \brief  Structure type to access the Core Debug Register (CoreDebug).
 *//**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
  \brief    Type definitions for the Core Debug Registers
  @{
 *//*@} end of group CMSIS_MPU *//*!< MPU RASR: Region enable bit Disable Mask *//*<< MPU_RASR_ENABLE_Pos*//*!< MPU RASR: Region enable bit Position *//*!< MPU RASR: Region Size Field Mask *//*!< MPU RASR: Region Size Field Position *//*!< MPU RASR: Sub-Region Disable Mask *//*!< MPU RASR: Sub-Region Disable Position *//*!< MPU RASR: ATTRS.B Mask *//*!< MPU RASR: ATTRS.B Position *//*!< MPU RASR: ATTRS.C Mask *//*!< MPU RASR: ATTRS.C Position *//*!< MPU RASR: ATTRS.S Mask *//*!< MPU RASR: ATTRS.S Position *//*!< MPU RASR: ATTRS.TEX Mask *//*!< MPU RASR: ATTRS.TEX Position *//*!< MPU RASR: ATTRS.AP Mask *//*!< MPU RASR: ATTRS.AP Position *//*!< MPU RASR: ATTRS.XN Mask *//*!< MPU RASR: ATTRS.XN Position *//*!< MPU RASR: MPU Region Attribute field Mask *//*!< MPU RASR: MPU Region Attribute field Position *//* MPU Region Attribute and Size Register Definitions *//*!< MPU RBAR: REGION Mask *//*<< MPU_RBAR_REGION_Pos*//*!< MPU RBAR: REGION Position *//*!< MPU RBAR: VALID Mask *//*!< MPU RBAR: VALID Position *//*!< MPU RBAR: ADDR Mask *//*!< MPU RBAR: ADDR Position *//* MPU Region Base Address Register Definitions *//*!< MPU RNR: REGION Mask *//*<< MPU_RNR_REGION_Pos*//*!< MPU RNR: REGION Position *//* MPU Region Number Register Definitions *//*!< MPU CTRL: ENABLE Mask *//*<< MPU_CTRL_ENABLE_Pos*//*!< MPU CTRL: ENABLE Position *//*!< MPU CTRL: HFNMIENA Mask *//*!< MPU CTRL: HFNMIENA Position *//*!< MPU CTRL: PRIVDEFENA Mask *//*!< MPU CTRL: PRIVDEFENA Position *//* MPU Control Register Definitions *//*!< MPU TYPE: SEPARATE Mask *//*<< MPU_TYPE_SEPARATE_Pos*//*!< MPU TYPE: SEPARATE Position *//*!< MPU TYPE: DREGION Mask *//*!< MPU TYPE: DREGION Position *//*!< MPU TYPE: IREGION Mask *//*!< MPU TYPE: IREGION Position *//* MPU Type Register Definitions *//*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register *//*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register *//*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register *//*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register *//*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register *//*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register *//*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register *//*!< Offset: 0x00C (R/W)  MPU Region Base Address Register *//*!< Offset: 0x008 (R/W)  MPU Region RNRber Register *//*!< Offset: 0x004 (R/W)  MPU Control Register *//*!< Offset: 0x000 (R/ )  MPU Type Register *//**
  \brief  Structure type to access the Memory Protection Unit (MPU).
 *//**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
  \brief    Type definitions for the Memory Protection Unit (MPU)
  @{
 *//* end of group CMSIS_TPI *//*!< TPI DEVTYPE: MajorType Mask *//*!< TPI DEVTYPE: MajorType Position *//*!< TPI DEVTYPE: SubType Mask *//*<< TPI_DEVTYPE_SubType_Pos*//*!< TPI DEVTYPE: SubType Position *//* TPI DEVTYPE Register Definitions *//*!< TPI DEVID: NrTraceInput Mask *//*<< TPI_DEVID_NrTraceInput_Pos*//*!< TPI DEVID: NrTraceInput Position *//*!< TPI DEVID: AsynClkIn Mask *//*!< TPI DEVID: AsynClkIn Position *//*!< TPI DEVID: MinBufSz Mask *//*!< TPI DEVID: MinBufSz Position *//*!< TPI DEVID: PTINVALID Mask *//*!< TPI DEVID: PTINVALID Position *//*!< TPI DEVID: MANCVALID Mask *//*!< TPI DEVID: MANCVALID Position *//*!< TPI DEVID: NRZVALID Mask *//*!< TPI DEVID: NRZVALID Position *//* TPI DEVID Register Definitions *//*!< TPI ITCTRL: Mode Mask *//*<< TPI_ITCTRL_Mode_Pos*//*!< TPI ITCTRL: Mode Position *//* TPI Integration Mode Control Register Definitions *//*!< TPI ITATBCTR0: ATREADY1 Mask *//*<< TPI_ITATBCTR0_ATREADY1_Pos*//*!< TPI ITATBCTR0: ATREADY1 Position *//*!< TPI ITATBCTR0: ATREADY2 Mask *//*<< TPI_ITATBCTR0_ATREADY2_Pos*//*!< TPI ITATBCTR0: ATREADY2 Position *//* TPI ITATBCTR0 Register Definitions *//*!< TPI FIFO1: ITM0 Mask *//*<< TPI_FIFO1_ITM0_Pos*//*!< TPI FIFO1: ITM0 Position *//*!< TPI FIFO1: ITM1 Mask *//*!< TPI FIFO1: ITM1 Position *//*!< TPI FIFO1: ITM2 Mask *//*!< TPI FIFO1: ITM2 Position *//*!< TPI FIFO1: ETM_bytecount Mask *//*!< TPI FIFO1: ETM_bytecount Position *//*!< TPI FIFO1: ETM_ATVALID Mask *//*!< TPI FIFO1: ETM_ATVALID Position *//*!< TPI FIFO1: ITM_bytecount Mask *//*!< TPI FIFO1: ITM_bytecount Position *//*!< TPI FIFO1: ITM_ATVALID Mask *//*!< TPI FIFO1: ITM_ATVALID Position *//* TPI Integration ITM Data Register Definitions (FIFO1) *//*!< TPI ITATBCTR2: ATREADY1 Mask *//*<< TPI_ITATBCTR2_ATREADY1_Pos*//*!< TPI ITATBCTR2: ATREADY1 Position *//*!< TPI ITATBCTR2: ATREADY2 Mask *//*<< TPI_ITATBCTR2_ATREADY2_Pos*//*!< TPI ITATBCTR2: ATREADY2 Position *//* TPI ITATBCTR2 Register Definitions *//*!< TPI FIFO0: ETM0 Mask *//*<< TPI_FIFO0_ETM0_Pos*//*!< TPI FIFO0: ETM0 Position *//*!< TPI FIFO0: ETM1 Mask *//*!< TPI FIFO0: ETM1 Position *//*!< TPI FIFO0: ETM2 Mask *//*!< TPI FIFO0: ETM2 Position *//*!< TPI FIFO0: ETM_bytecount Mask *//*!< TPI FIFO0: ETM_bytecount Position *//*!< TPI FIFO0: ETM_ATVALID Mask *//*!< TPI FIFO0: ETM_ATVALID Position *//*!< TPI FIFO0: ITM_bytecount Mask *//*!< TPI FIFO0: ITM_bytecount Position *//*!< TPI FIFO0: ITM_ATVALID Mask *//*!< TPI FIFO0: ITM_ATVALID Position *//* TPI Integration ETM Data Register Definitions (FIFO0) *//*!< TPI TRIGGER: TRIGGER Mask *//*<< TPI_TRIGGER_TRIGGER_Pos*//*!< TPI TRIGGER: TRIGGER Position *//* TPI TRIGGER Register Definitions *//*!< TPI FFCR: EnFCont Mask *//*!< TPI FFCR: EnFCont Position *//*!< TPI FFCR: TrigIn Mask *//*!< TPI FFCR: TrigIn Position *//* TPI Formatter and Flush Control Register Definitions *//*!< TPI FFSR: FlInProg Mask *//*<< TPI_FFSR_FlInProg_Pos*//*!< TPI FFSR: FlInProg Position *//*!< TPI FFSR: FtStopped Mask *//*!< TPI FFSR: FtStopped Position *//*!< TPI FFSR: TCPresent Mask *//*!< TPI FFSR: TCPresent Position *//*!< TPI FFSR: FtNonStop Mask *//*!< TPI FFSR: FtNonStop Position *//* TPI Formatter and Flush Status Register Definitions *//*!< TPI SPPR: TXMODE Mask *//*<< TPI_SPPR_TXMODE_Pos*//*!< TPI SPPR: TXMODE Position *//* TPI Selected Pin Protocol Register Definitions *//*!< TPI ACPR: PRESCALER Mask *//*<< TPI_ACPR_PRESCALER_Pos*//*!< TPI ACPR: PRESCALER Position *//* TPI Asynchronous Clock Prescaler Register Definitions *//*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE *//*!< Offset: 0xFC8 (R/ )  TPIU_DEVID *//*!< Offset: 0xFA4 (R/W)  Claim tag clear *//*!< Offset: 0xFA0 (R/W)  Claim tag set *//*!< Offset: 0xF00 (R/W)  Integration Mode Control *//*!< Offset: 0xEFC (R/ )  Integration ITM Data *//*!< Offset: 0xEF8 (R/ )  ITATBCTR0 *//*!< Offset: 0xEF0 (R/ )  ITATBCTR2 *//*!< Offset: 0xEEC (R/ )  Integration ETM Data *//*!< Offset: 0xEE8 (R/ )  TRIGGER Register *//*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register *//*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register *//*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register *//*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register *//*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register *//*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register *//*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register *//**
  \brief  Structure type to access the Trace Port Interface Register (TPI).
 *//**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
  \brief    Type definitions for the Trace Port Interface (TPI)
  @{
 *//* end of group CMSIS_DWT *//*!< DWT FUNCTION: FUNCTION Mask *//*<< DWT_FUNCTION_FUNCTION_Pos*//*!< DWT FUNCTION: FUNCTION Position *//*!< DWT FUNCTION: EMITRANGE Mask *//*!< DWT FUNCTION: EMITRANGE Position *//*!< DWT FUNCTION: CYCMATCH Mask *//*!< DWT FUNCTION: CYCMATCH Position *//*!< DWT FUNCTION: DATAVMATCH Mask *//*!< DWT FUNCTION: DATAVMATCH Position *//*!< DWT FUNCTION: LNK1ENA Mask *//*!< DWT FUNCTION: LNK1ENA Position *//*!< DWT FUNCTION: DATAVSIZE Mask *//*!< DWT FUNCTION: DATAVSIZE Position *//*!< DWT FUNCTION: DATAVADDR0 Mask *//*!< DWT FUNCTION: DATAVADDR0 Position *//*!< DWT FUNCTION: DATAVADDR1 Mask *//*!< DWT FUNCTION: DATAVADDR1 Position *//*!< DWT FUNCTION: MATCHED Mask *//*!< DWT FUNCTION: MATCHED Position *//* DWT Comparator Function Register Definitions *//*!< DWT MASK: MASK Mask *//*<< DWT_MASK_MASK_Pos*//*!< DWT MASK: MASK Position *//* DWT Comparator Mask Register Definitions *//*!< DWT FOLDCNT: FOLDCNT Mask *//*<< DWT_FOLDCNT_FOLDCNT_Pos*//*!< DWT FOLDCNT: FOLDCNT Position *//* DWT Folded-instruction Count Register Definitions *//*!< DWT LSUCNT: LSUCNT Mask *//*<< DWT_LSUCNT_LSUCNT_Pos*//*!< DWT LSUCNT: LSUCNT Position *//* DWT LSU Count Register Definitions *//*!< DWT SLEEPCNT: SLEEPCNT Mask *//*<< DWT_SLEEPCNT_SLEEPCNT_Pos*//*!< DWT SLEEPCNT: SLEEPCNT Position *//* DWT Sleep Count Register Definitions *//*!< DWT EXCCNT: EXCCNT Mask *//*<< DWT_EXCCNT_EXCCNT_Pos*//*!< DWT EXCCNT: EXCCNT Position *//* DWT Exception Overhead Count Register Definitions *//*!< DWT CPICNT: CPICNT Mask *//*<< DWT_CPICNT_CPICNT_Pos*//*!< DWT CPICNT: CPICNT Position *//* DWT CPI Count Register Definitions *//*!< DWT CTRL: CYCCNTENA Mask *//*<< DWT_CTRL_CYCCNTENA_Pos*//*!< DWT CTRL: CYCCNTENA Position *//*!< DWT CTRL: POSTPRESET Mask *//*!< DWT CTRL: POSTPRESET Position *//*!< DWT CTRL: POSTINIT Mask *//*!< DWT CTRL: POSTINIT Position *//*!< DWT CTRL: CYCTAP Mask *//*!< DWT CTRL: CYCTAP Position *//*!< DWT CTRL: SYNCTAP Mask *//*!< DWT CTRL: SYNCTAP Position *//*!< DWT CTRL: PCSAMPLENA Mask *//*!< DWT CTRL: PCSAMPLENA Position *//*!< DWT CTRL: EXCTRCENA Mask *//*!< DWT CTRL: EXCTRCENA Position *//*!< DWT CTRL: CPIEVTENA Mask *//*!< DWT CTRL: CPIEVTENA Position *//*!< DWT CTRL: EXCEVTENA Mask *//*!< DWT CTRL: EXCEVTENA Position *//*!< DWT CTRL: SLEEPEVTENA Mask *//*!< DWT CTRL: SLEEPEVTENA Position *//*!< DWT CTRL: LSUEVTENA Mask *//*!< DWT CTRL: LSUEVTENA Position *//*!< DWT CTRL: FOLDEVTENA Mask *//*!< DWT CTRL: FOLDEVTENA Position *//*!< DWT CTRL: CYCEVTENA Mask *//*!< DWT CTRL: CYCEVTENA Position *//*!< DWT CTRL: NOPRFCNT Mask *//*!< DWT CTRL: NOPRFCNT Position *//*!< DWT CTRL: NOCYCCNT Mask *//*!< DWT CTRL: NOCYCCNT Position *//*!< DWT CTRL: NOEXTTRIG Mask *//*!< DWT CTRL: NOEXTTRIG Position *//*!< DWT CTRL: NOTRCPKT Mask *//*!< DWT CTRL: NOTRCPKT Position *//*!< DWT CTRL: NUMCOMP Mask *//*!< DWT CTRL: NUMCOMP Position *//* DWT Control Register Definitions *//*!< Offset: 0x058 (R/W)  Function Register 3 *//*!< Offset: 0x054 (R/W)  Mask Register 3 *//*!< Offset: 0x050 (R/W)  Comparator Register 3 *//*!< Offset: 0x048 (R/W)  Function Register 2 *//*!< Offset: 0x044 (R/W)  Mask Register 2 *//*!< Offset: 0x040 (R/W)  Comparator Register 2 *//*!< Offset: 0x038 (R/W)  Function Register 1 *//*!< Offset: 0x034 (R/W)  Mask Register 1 *//*!< Offset: 0x030 (R/W)  Comparator Register 1 *//*!< Offset: 0x028 (R/W)  Function Register 0 *//*!< Offset: 0x024 (R/W)  Mask Register 0 *//*!< Offset: 0x020 (R/W)  Comparator Register 0 *//*!< Offset: 0x01C (R/ )  Program Counter Sample Register *//*!< Offset: 0x018 (R/W)  Folded-instruction Count Register *//*!< Offset: 0x014 (R/W)  LSU Count Register *//*!< Offset: 0x010 (R/W)  Sleep Count Register *//*!< Offset: 0x00C (R/W)  Exception Overhead Count Register *//*!< Offset: 0x008 (R/W)  CPI Count Register *//*!< Offset: 0x004 (R/W)  Cycle Count Register *//*!< Offset: 0x000 (R/W)  Control Register *//**
  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
 *//**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
  @{
 *//* end of group CMSIS_ITM *//*!< ITM LSR: Present Mask *//*<< ITM_LSR_Present_Pos*//*!< ITM LSR: Present Position *//*!< ITM LSR: Access Mask *//*!< ITM LSR: Access Position *//*!< ITM LSR: ByteAcc Mask *//*!< ITM LSR: ByteAcc Position *//* ITM Lock Status Register Definitions *//*!< ITM TCR: ITM Enable bit Mask *//*<< ITM_TCR_ITMENA_Pos*//*!< ITM TCR: ITM Enable bit Position *//*!< ITM TCR: TSENA Mask *//*!< ITM TCR: TSENA Position *//*!< ITM TCR: SYNCENA Mask *//*!< ITM TCR: SYNCENA Position *//*!< ITM TCR: DWTENA Mask *//*!< ITM TCR: DWTENA Position *//*!< ITM TCR: SWOENA Mask *//*!< ITM TCR: SWOENA Position *//*!< ITM TCR: TSPrescale Mask *//*!< ITM TCR: TSPrescale Position *//*!< ITM TCR: Global timestamp frequency Mask *//*!< ITM TCR: Global timestamp frequency Position *//*!< ITM TCR: ATBID Mask *//*!< ITM TCR: ATBID Position *//*!< ITM TCR: BUSY Mask *//*!< ITM TCR: BUSY Position *//* ITM Trace Control Register Definitions *//*!< ITM TPR: PRIVMASK Mask *//*<< ITM_TPR_PRIVMASK_Pos*//*!< ITM TPR: PRIVMASK Position *//* ITM Trace Privilege Register Definitions *//*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 *//*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 *//*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 *//*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 *//*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 *//*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 *//*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 *//*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 *//*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 *//*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 *//*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 *//*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 *//*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register *//*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register *//*!< Offset: 0xE80 (R/W)  ITM Trace Control Register *//*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register *//*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register *//*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers *//*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit *//*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit *//*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit *//**
  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 *//**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
  @{
 *//*@} end of group CMSIS_SysTick *//*!< SysTick CALIB: TENMS Mask *//*<< SysTick_CALIB_TENMS_Pos*//*!< SysTick CALIB: TENMS Position *//*!< SysTick CALIB: SKEW Mask *//*!< SysTick CALIB: SKEW Position *//*!< SysTick CALIB: NOREF Mask *//*!< SysTick CALIB: NOREF Position *//* SysTick Calibration Register Definitions *//*!< SysTick VAL: CURRENT Mask *//*<< SysTick_VAL_CURRENT_Pos*//*!< SysTick VAL: CURRENT Position *//* SysTick Current Register Definitions *//*!< SysTick LOAD: RELOAD Mask *//*<< SysTick_LOAD_RELOAD_Pos*//*!< SysTick LOAD: RELOAD Position *//* SysTick Reload Register Definitions *//*!< SysTick CTRL: ENABLE Mask *//*<< SysTick_CTRL_ENABLE_Pos*//*!< SysTick CTRL: ENABLE Position *//*!< SysTick CTRL: TICKINT Mask *//*!< SysTick CTRL: TICKINT Position *//*!< SysTick CTRL: CLKSOURCE Mask *//*!< SysTick CTRL: CLKSOURCE Position *//*!< SysTick CTRL: COUNTFLAG Mask *//*!< SysTick CTRL: COUNTFLAG Position *//* SysTick Control / Status Register Definitions *//*!< Offset: 0x00C (R/ )  SysTick Calibration Register *//*!< Offset: 0x008 (R/W)  SysTick Current Value Register *//*!< Offset: 0x004 (R/W)  SysTick Reload Value Register *//*!< Offset: 0x000 (R/W)  SysTick Control and Status Register *//**
  \brief  Structure type to access the System Timer (SysTick).
 *//**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
  \brief    Type definitions for the System Timer Registers.
  @{
 *//*@} end of group CMSIS_SCnotSCB *//*!< ACTLR: DISMCYCINT Mask *//*<< SCnSCB_ACTLR_DISMCYCINT_Pos*//*!< ACTLR: DISMCYCINT Position *//*!< ACTLR: DISDEFWBUF Mask *//*!< ACTLR: DISDEFWBUF Position *//*!< ACTLR: DISFOLD Mask *//*!< ACTLR: DISFOLD Position *//*!< ACTLR: DISFPCA Mask *//*!< ACTLR: DISFPCA Position *//*!< ACTLR: DISOOFP Mask *//*!< ACTLR: DISOOFP Position *//* Auxiliary Control Register Definitions *//*!< ICTR: INTLINESNUM Mask *//*<< SCnSCB_ICTR_INTLINESNUM_Pos*//*!< ICTR: INTLINESNUM Position *//* Interrupt Controller Type Register Definitions *//*!< Offset: 0x008 (R/W)  Auxiliary Control Register *//*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register *//**
  \brief  Structure type to access the System Control and ID Register not in the SCB.
 *//**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
  \brief    Type definitions for the System Control and ID Register not in the SCB
  @{
 *//*@} end of group CMSIS_SCB *//*!< SCB DFSR: HALTED Mask *//*<< SCB_DFSR_HALTED_Pos*//*!< SCB DFSR: HALTED Position *//*!< SCB DFSR: BKPT Mask *//*!< SCB DFSR: BKPT Position *//*!< SCB DFSR: DWTTRAP Mask *//*!< SCB DFSR: DWTTRAP Position *//*!< SCB DFSR: VCATCH Mask *//*!< SCB DFSR: VCATCH Position *//*!< SCB DFSR: EXTERNAL Mask *//*!< SCB DFSR: EXTERNAL Position *//* SCB Debug Fault Status Register Definitions *//*!< SCB HFSR: VECTTBL Mask *//*!< SCB HFSR: VECTTBL Position *//*!< SCB HFSR: FORCED Mask *//*!< SCB HFSR: FORCED Position *//*!< SCB HFSR: DEBUGEVT Mask *//*!< SCB HFSR: DEBUGEVT Position *//* SCB Hard Fault Status Register Definitions *//*!< SCB CFSR (UFSR): UNDEFINSTR Mask *//*!< SCB CFSR (UFSR): UNDEFINSTR Position *//*!< SCB CFSR (UFSR): INVSTATE Mask *//*!< SCB CFSR (UFSR): INVSTATE Position *//*!< SCB CFSR (UFSR): INVPC Mask *//*!< SCB CFSR (UFSR): INVPC Position *//*!< SCB CFSR (UFSR): NOCP Mask *//*!< SCB CFSR (UFSR): NOCP Position *//*!< SCB CFSR (UFSR): UNALIGNED Mask *//*!< SCB CFSR (UFSR): UNALIGNED Position *//*!< SCB CFSR (UFSR): DIVBYZERO Mask *//*!< SCB CFSR (UFSR): DIVBYZERO Position *//* UsageFault Status Register (part of SCB Configurable Fault Status Register) *//*!< SCB CFSR (BFSR): IBUSERR Mask *//*!< SCB CFSR (BFSR): IBUSERR Position *//*!< SCB CFSR (BFSR): PRECISERR Mask *//*!< SCB CFSR (BFSR): PRECISERR Position *//*!< SCB CFSR (BFSR): IMPRECISERR Mask *//*!< SCB CFSR (BFSR): IMPRECISERR Position *//*!< SCB CFSR (BFSR): UNSTKERR Mask *//*!< SCB CFSR (BFSR): UNSTKERR Position *//*!< SCB CFSR (BFSR): STKERR Mask *//*!< SCB CFSR (BFSR): STKERR Position *//*!< SCB CFSR (BFSR): BFARVALID Mask *//*!< SCB CFSR (BFSR): BFARVALID Position *//* BusFault Status Register (part of SCB Configurable Fault Status Register) *//*!< SCB CFSR (MMFSR): IACCVIOL Mask *//*<< SCB_CFSR_IACCVIOL_Pos*//*!< SCB CFSR (MMFSR): IACCVIOL Position *//*!< SCB CFSR (MMFSR): DACCVIOL Mask *//*!< SCB CFSR (MMFSR): DACCVIOL Position *//*!< SCB CFSR (MMFSR): MUNSTKERR Mask *//*!< SCB CFSR (MMFSR): MUNSTKERR Position *//*!< SCB CFSR (MMFSR): MSTKERR Mask *//*!< SCB CFSR (MMFSR): MSTKERR Position *//*!< SCB CFSR (MMFSR): MMARVALID Mask *//*!< SCB CFSR (MMFSR): MMARVALID Position *//* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) *//*!< SCB CFSR: Memory Manage Fault Status Register Mask *//*<< SCB_CFSR_MEMFAULTSR_Pos*//*!< SCB CFSR: Memory Manage Fault Status Register Position *//*!< SCB CFSR: Bus Fault Status Register Mask *//*!< SCB CFSR: Bus Fault Status Register Position *//*!< SCB CFSR: Usage Fault Status Register Mask *//*!< SCB CFSR: Usage Fault Status Register Position *//* SCB Configurable Fault Status Register Definitions *//*!< SCB SHCSR: MEMFAULTACT Mask *//*<< SCB_SHCSR_MEMFAULTACT_Pos*//*!< SCB SHCSR: MEMFAULTACT Position *//*!< SCB SHCSR: BUSFAULTACT Mask *//*!< SCB SHCSR: BUSFAULTACT Position *//*!< SCB SHCSR: USGFAULTACT Mask *//*!< SCB SHCSR: USGFAULTACT Position *//*!< SCB SHCSR: SVCALLACT Mask *//*!< SCB SHCSR: SVCALLACT Position *//*!< SCB SHCSR: MONITORACT Mask *//*!< SCB SHCSR: MONITORACT Position *//*!< SCB SHCSR: PENDSVACT Mask *//*!< SCB SHCSR: PENDSVACT Position *//*!< SCB SHCSR: SYSTICKACT Mask *//*!< SCB SHCSR: SYSTICKACT Position *//*!< SCB SHCSR: USGFAULTPENDED Mask *//*!< SCB SHCSR: USGFAULTPENDED Position *//*!< SCB SHCSR: MEMFAULTPENDED Mask *//*!< SCB SHCSR: MEMFAULTPENDED Position *//*!< SCB SHCSR: BUSFAULTPENDED Mask *//*!< SCB SHCSR: BUSFAULTPENDED Position *//*!< SCB SHCSR: SVCALLPENDED Mask *//*!< SCB SHCSR: SVCALLPENDED Position *//*!< SCB SHCSR: MEMFAULTENA Mask *//*!< SCB SHCSR: MEMFAULTENA Position *//*!< SCB SHCSR: BUSFAULTENA Mask *//*!< SCB SHCSR: BUSFAULTENA Position *//*!< SCB SHCSR: USGFAULTENA Mask *//*!< SCB SHCSR: USGFAULTENA Position *//* SCB System Handler Control and State Register Definitions *//*!< SCB CCR: NONBASETHRDENA Mask *//*<< SCB_CCR_NONBASETHRDENA_Pos*//*!< SCB CCR: NONBASETHRDENA Position *//*!< SCB CCR: USERSETMPEND Mask *//*!< SCB CCR: USERSETMPEND Position *//*!< SCB CCR: UNALIGN_TRP Mask *//*!< SCB CCR: UNALIGN_TRP Position *//*!< SCB CCR: DIV_0_TRP Mask *//*!< SCB CCR: DIV_0_TRP Position *//*!< SCB CCR: BFHFNMIGN Mask *//*!< SCB CCR: BFHFNMIGN Position *//*!< SCB CCR: STKALIGN Mask *//*!< SCB CCR: STKALIGN Position *//* SCB Configuration Control Register Definitions *//*!< SCB SCR: SLEEPONEXIT Mask *//*!< SCB SCR: SLEEPONEXIT Position *//*!< SCB SCR: SLEEPDEEP Mask *//*!< SCB SCR: SLEEPDEEP Position *//*!< SCB SCR: SEVONPEND Mask *//*!< SCB SCR: SEVONPEND Position *//* SCB System Control Register Definitions *//*!< SCB AIRCR: VECTRESET Mask *//*<< SCB_AIRCR_VECTRESET_Pos*//*!< SCB AIRCR: VECTRESET Position *//*!< SCB AIRCR: VECTCLRACTIVE Mask *//*!< SCB AIRCR: VECTCLRACTIVE Position *//*!< SCB AIRCR: SYSRESETREQ Mask *//*!< SCB AIRCR: SYSRESETREQ Position *//*!< SCB AIRCR: PRIGROUP Mask *//*!< SCB AIRCR: PRIGROUP Position *//*!< SCB AIRCR: ENDIANESS Mask *//*!< SCB AIRCR: ENDIANESS Position *//*!< SCB AIRCR: VECTKEYSTAT Mask *//*!< SCB AIRCR: VECTKEYSTAT Position *//*!< SCB AIRCR: VECTKEY Mask *//*!< SCB AIRCR: VECTKEY Position *//* SCB Application Interrupt and Reset Control Register Definitions *//*!< SCB VTOR: TBLOFF Mask *//*!< SCB VTOR: TBLOFF Position *//*!< SCB VTOR: TBLBASE Mask *//*!< SCB VTOR: TBLBASE Position *//* core r2p1 *//* SCB Vector Table Offset Register Definitions *//*!< SCB ICSR: VECTACTIVE Mask *//*<< SCB_ICSR_VECTACTIVE_Pos*//*!< SCB ICSR: VECTACTIVE Position *//*!< SCB ICSR: RETTOBASE Mask *//*!< SCB ICSR: RETTOBASE Position *//*!< SCB ICSR: VECTPENDING Mask *//*!< SCB ICSR: VECTPENDING Position *//*!< SCB ICSR: ISRPENDING Mask *//*!< SCB ICSR: ISRPENDING Position *//*!< SCB ICSR: ISRPREEMPT Mask *//*!< SCB ICSR: ISRPREEMPT Position *//*!< SCB ICSR: PENDSTCLR Mask *//*!< SCB ICSR: PENDSTCLR Position *//*!< SCB ICSR: PENDSTSET Mask *//*!< SCB ICSR: PENDSTSET Position *//*!< SCB ICSR: PENDSVCLR Mask *//*!< SCB ICSR: PENDSVCLR Position *//*!< SCB ICSR: PENDSVSET Mask *//*!< SCB ICSR: PENDSVSET Position *//*!< SCB ICSR: NMIPENDSET Mask *//*!< SCB ICSR: NMIPENDSET Position *//* SCB Interrupt Control State Register Definitions *//*!< SCB CPUID: REVISION Mask *//*<< SCB_CPUID_REVISION_Pos*//*!< SCB CPUID: REVISION Position *//*!< SCB CPUID: PARTNO Mask *//*!< SCB CPUID: PARTNO Position *//*!< SCB CPUID: ARCHITECTURE Mask *//*!< SCB CPUID: ARCHITECTURE Position *//*!< SCB CPUID: VARIANT Mask *//*!< SCB CPUID: VARIANT Position *//*!< SCB CPUID: IMPLEMENTER Mask *//*!< SCB CPUID: IMPLEMENTER Position *//* SCB CPUID Register Definitions *//*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register *//*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register *//*!< Offset: 0x050 (R/ )  Memory Model Feature Register *//*!< Offset: 0x04C (R/ )  Auxiliary Feature Register *//*!< Offset: 0x048 (R/ )  Debug Feature Register *//*!< Offset: 0x040 (R/ )  Processor Feature Register *//*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register *//*!< Offset: 0x038 (R/W)  BusFault Address Register *//*!< Offset: 0x034 (R/W)  MemManage Fault Address Register *//*!< Offset: 0x030 (R/W)  Debug Fault Status Register *//*!< Offset: 0x02C (R/W)  HardFault Status Register *//*!< Offset: 0x028 (R/W)  Configurable Fault Status Register *//*!< Offset: 0x024 (R/W)  System Handler Control and State Register *//*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) *//*!< Offset: 0x014 (R/W)  Configuration Control Register *//*!< Offset: 0x010 (R/W)  System Control Register *//*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register *//*!< Offset: 0x008 (R/W)  Vector Table Offset Register *//*!< Offset: 0x004 (R/W)  Interrupt Control and State Register *//*!< Offset: 0x000 (R/ )  CPUID Base Register *//**
  \brief  Structure type to access the System Control Block (SCB).
 *//**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SCB     System Control Block (SCB)
  \brief    Type definitions for the System Control Block Registers
  @{
 *//*@} end of group CMSIS_NVIC *//*!< STIR: INTLINESNUM Mask *//*<< NVIC_STIR_INTID_Pos*//*!< STIR: INTLINESNUM Position *//* Software Triggered Interrupt Register Definitions *//*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register *//*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) *//*!< Offset: 0x200 (R/W)  Interrupt Active bit Register *//*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register *//*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *//*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register *//*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register *//**
  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 *//**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
  \brief      Type definitions for the NVIC Registers
  @{
 *//*@} end of group CMSIS_CORE *//*!< CONTROL: nPRIV Mask *//*<< CONTROL_nPRIV_Pos*//*!< CONTROL: nPRIV Position *//*!< CONTROL: SPSEL Mask *//*!< CONTROL: SPSEL Position *//* CONTROL Register Definitions *//*!< Type      used for word access *//*!< Structure used for bit  access *//*!< bit:  2..31  Reserved *//*!< bit:      1  Stack to be used *//*!< bit:      0  Execution privilege in Thread mode *//**
  \brief  Union type to access the Control Registers (CONTROL).
 *//*!< xPSR: ISR Mask *//*<< xPSR_ISR_Pos*//*!< xPSR: ISR Position *//*!< xPSR: ICI/IT part 1 Mask *//*!< xPSR: ICI/IT part 1 Position *//*!< xPSR: T Mask *//*!< xPSR: T Position *//*!< xPSR: ICI/IT part 2 Mask *//*!< xPSR: ICI/IT part 2 Position *//*!< xPSR: Q Mask *//*!< xPSR: Q Position *//*!< xPSR: V Mask *//*!< xPSR: V Position *//*!< xPSR: C Mask *//*!< xPSR: C Position *//*!< xPSR: Z Mask *//*!< xPSR: Z Position *//*!< xPSR: N Mask *//*!< xPSR: N Position *//* xPSR Register Definitions *//*!< bit:     31  Negative condition code flag *//*!< bit:     30  Zero condition code flag *//*!< bit:     29  Carry condition code flag *//*!< bit:     28  Overflow condition code flag *//*!< bit:     27  Saturation condition flag *//*!< bit: 25..26  ICI/IT part 2 *//*!< bit:     24  Thumb bit *//*!< bit: 16..23  Reserved *//*!< bit: 10..15  ICI/IT part 1 *//*!< bit:      9  Reserved *//*!< bit:  0.. 8  Exception number *//**
  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 *//*!< IPSR: ISR Mask *//*<< IPSR_ISR_Pos*//*!< IPSR: ISR Position *//* IPSR Register Definitions *//*!< bit:  9..31  Reserved *//**
  \brief  Union type to access the Interrupt Program Status Register (IPSR).
 *//*!< APSR: Q Mask *//*!< APSR: Q Position *//*!< APSR: V Mask *//*!< APSR: V Position *//*!< APSR: C Mask *//*!< APSR: C Position *//*!< APSR: Z Mask *//*!< APSR: Z Position *//*!< APSR: N Mask *//*!< APSR: N Position *//* APSR Register Definitions *//*!< bit:  0..26  Reserved *//**
  \brief  Union type to access the Application Program Status Register (APSR).
 *//**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_CORE  Status and Control Registers
  \brief      Core Register type definitions.
  @{
 *//**
  \defgroup CMSIS_core_register Defines and Type Definitions
  \brief Type definitions and defines for Cortex-M processor based devices.
*//*******************************************************************************
 *                 Register Abstraction
  Core Register contain:
  - Core Register
  - Core NVIC Register
  - Core SCB Register
  - Core SysTick Register
  - Core Debug Register
  - Core MPU Register
 ******************************************************************************//*@} end of group Cortex_M3 *//*! Defines 'read / write' structure member permissions *//*! Defines 'write only' structure member permissions *//*! Defines 'read only' structure member permissions *//* following defines should be used for structure members *//*!< Defines 'read / write' permissions *//*!< Defines 'write only' permissions *//*!< Defines 'read only' permissions *//**
    \defgroup CMSIS_glob_defs CMSIS Global Defines

    <strong>IO Type Qualifiers</strong> are used
    \li to specify the access to peripheral variables.
    \li for automatic generation of peripheral register debug information.
*//* IO definitions (access restrictions to peripheral registers) *//* check device defines and use defaults *//* __CORE_CM3_H_GENERIC *//** __FPU_USED indicates whether an FPU is used or not.
    This core does not support an FPU at all
*//*!< Cortex-M Core *//*!< \deprecated CMSIS HAL version number *//*!< \deprecated [15:0]  CMSIS HAL sub version *//*!< \deprecated [31:16] CMSIS HAL main version *//* CMSIS CM3 definitions *//**
  \ingroup Cortex_M3
  @{
 *//*******************************************************************************
 *                 CMSIS definitions
 ******************************************************************************//**
  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  CMSIS violates the following MISRA-C:2004 rules:

   \li Required Rule 8.5, object/function definition in header file.<br>
     Function definitions in header files are used to allow 'inlining'.

   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
     Unions are used for effective representation of core registers.

   \li Advisory Rule 19.7, Function-like macro defined.<br>
     Function-like macros are used to allow more efficient code.
 *//**
 * @file     core_cm3.h
 * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
 * @version  V5.1.1
 * @date     27. March 2020
 ******************************************************************************//Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/CMSIS/CMSDK_CM3.h<core_cm3.h>CMSDK_WATCHDOG_TypeDefCMSDK_PL230_TypeDefCMSDK_SYSCON_TypeDefCMSDK_GPIO_TypeDefCMSDK_DUALTIMER_SINGLE_TypeDefCMSDK_DUALTIMER_BOTH_TypeDefCMSDK_TIMER_TypeDefCMSDK_UART_TypeDefIRQn_TypeNonMaskableInt_IRQn-14HardFault_IRQn-13MemoryManagement_IRQn-12BusFault_IRQn-11UsageFault_IRQn-10SVCall_IRQn-5DebugMonitor_IRQn-4PendSV_IRQn-2UARTRX0_IRQnUARTTX0_IRQnUARTRX1_IRQnUARTTX1_IRQnUARTRX2_IRQnUARTTX2_IRQnPORT0_ALL_IRQnPORT1_ALL_IRQnTIMER0_IRQnTIMER1_IRQnDUALTIMER_IRQnSPI_IRQnUARTOVF_IRQnETHERNET_IRQnI2S_IRQnTSC_IRQnPORT2_ALL_IRQnPORT3_ALL_IRQnUARTRX3_IRQnUARTTX3_IRQnUARTRX4_IRQnUARTTX4_IRQnADCSPI_IRQnSHIELDSPI_IRQnPORT0_0_IRQnPORT0_1_IRQnPORT0_2_IRQnPORT0_3_IRQnPORT0_4_IRQnPORT0_5_IRQnPORT0_6_IRQnPORT0_7_IRQnITOPITCRuint32_t[191]unsigned long[191]191LOCKuint32_t[762]unsigned long[762]762MASKINTSTATRAWINTSTATINTCLRVALUEERR_CLRuint32_t[3]unsigned long[3]CHNL_PRIORITY_CLRCHNL_PRIORITY_SETCHNL_PRI_ALT_CLRCHNL_PRI_ALT_SETCHNL_ENABLE_CLRCHNL_ENABLE_SETCHNL_REQ_MASK_CLRCHNL_REQ_MASK_SETCHNL_USEBURST_CLRCHNL_USEBURST_SETCHNL_SW_REQUESTDMA_WAITONREQ_STATUSALT_CTRL_BASE_PTRCTRL_BASE_PTRDMA_CFGDMA_STATUSRSTINFOEMICTRLRESETOPPMUCTRLREMAPvolatile uint32_t[256]UB_MASKEDLB_MASKEDuint32_t[241]unsigned long[241]241(unknown field)INTPOLCLRINTPOLSETINTTYPECLRINTTYPESETINTENCLRINTENSETALTFUNCCLRALTFUNCSETOUTENABLECLROUTENABLESETDATAOUTDATAINTCLEARINTSTATUSTimerBGLoadTimerMISTimerRISTimerIntClrTimerControlTimerValueTimerLoaduint32_t[945]unsigned long[945]945Timer2BGLoadTimer2MISTimer2RISTimer2IntClrTimer2ControlTimer2ValueTimer2LoadTimer1BGLoadTimer1MISTimer1RISTimer1IntClrTimer1ControlTimer1ValueTimer1LoadRELOADBAUDDIVSTATECMSDK_SYSCON((CMSDK_SYSCON_TypeDef *) CMSDK_SYSCTRL_BASE )CMSDK_GPIO3((CMSDK_GPIO_TypeDef *) CMSDK_GPIO3_BASE )CMSDK_GPIO2((CMSDK_GPIO_TypeDef *) CMSDK_GPIO2_BASE )CMSDK_GPIO1((CMSDK_GPIO_TypeDef *) CMSDK_GPIO1_BASE )CMSDK_GPIO0((CMSDK_GPIO_TypeDef *) CMSDK_GPIO0_BASE )CMSDK_DMA((CMSDK_PL230_TypeDef *) CMSDK_PL230_BASE )CMSDK_WATCHDOG((CMSDK_WATCHDOG_TypeDef *) CMSDK_WATCHDOG_BASE )CMSDK_DUALTIMER2((CMSDK_DUALTIMER_SINGLE_TypeDef *) CMSDK_DUALTIMER_2_BASE )CMSDK_DUALTIMER1((CMSDK_DUALTIMER_SINGLE_TypeDef *) CMSDK_DUALTIMER_1_BASE )CMSDK_DUALTIMER((CMSDK_DUALTIMER_BOTH_TypeDef *) CMSDK_DUALTIMER_BASE )CMSDK_TIMER1((CMSDK_TIMER_TypeDef *) CMSDK_TIMER1_BASE )CMSDK_TIMER0((CMSDK_TIMER_TypeDef *) CMSDK_TIMER0_BASE )CMSDK_UART4((CMSDK_UART_TypeDef *) CMSDK_UART4_BASE )CMSDK_UART3((CMSDK_UART_TypeDef *) CMSDK_UART3_BASE )CMSDK_UART2((CMSDK_UART_TypeDef *) CMSDK_UART2_BASE )CMSDK_UART1((CMSDK_UART_TypeDef *) CMSDK_UART1_BASE )CMSDK_UART0((CMSDK_UART_TypeDef *) CMSDK_UART0_BASE )CMSDK_SYSCTRL_BASE(CMSDK_AHB_BASE + 0xF000UL)CMSDK_GPIO3_BASE(CMSDK_AHB_BASE + 0x3000UL)CMSDK_GPIO2_BASE(CMSDK_AHB_BASE + 0x2000UL)CMSDK_GPIO1_BASE(CMSDK_AHB_BASE + 0x1000UL)CMSDK_GPIO0_BASE(CMSDK_AHB_BASE + 0x0000UL)CMSDK_PL230_BASE(CMSDK_APB_BASE + 0xF000UL)CMSDK_UART4_BASE(CMSDK_APB_BASE + 0x9000UL)CMSDK_WATCHDOG_BASE(CMSDK_APB_BASE + 0x8000UL)CMSDK_UART3_BASE(CMSDK_APB_BASE + 0x7000UL)CMSDK_UART2_BASE(CMSDK_APB_BASE + 0x6000UL)CMSDK_UART1_BASE(CMSDK_APB_BASE + 0x5000UL)CMSDK_UART0_BASE(CMSDK_APB_BASE + 0x4000UL)CMSDK_DUALTIMER_2_BASE(CMSDK_DUALTIMER_BASE + 0x20UL)CMSDK_DUALTIMER_1_BASE(CMSDK_DUALTIMER_BASE)CMSDK_DUALTIMER_BASE(CMSDK_APB_BASE + 0x2000UL)CMSDK_TIMER1_BASE(CMSDK_APB_BASE + 0x1000UL)CMSDK_TIMER0_BASE(CMSDK_APB_BASE + 0x0000UL)CMSDK_AHB_BASE(0x40010000UL)CMSDK_APB_BASE(0x40000000UL)CMSDK_RAM_BASE(0x20000000UL)CMSDK_PERIPH_BASECMSDK_SRAM_BASECMSDK_FLASH_BASE(0x00000000UL)CMSDK_Watchdog_INTEGTESTOUTSET_Msk(0x1ul << CMSDK_Watchdog_INTEGTESTOUTSET_Pos)CMSDK_Watchdog_INTEGTESTOUTSET_PosCMSDK_Watchdog_INTEGTESTEN_Msk(0x1ul << CMSDK_Watchdog_INTEGTESTEN_Pos)CMSDK_Watchdog_INTEGTESTEN_PosCMSDK_Watchdog_LOCK_Msk(0x1ul << CMSDK_Watchdog_LOCK_Pos)CMSDK_Watchdog_LOCK_PosCMSDK_Watchdog_MASKINTSTAT_Msk(0x1ul << CMSDK_Watchdog_MASKINTSTAT_Pos)CMSDK_Watchdog_MASKINTSTAT_PosCMSDK_Watchdog_RAWINTSTAT_Msk(0x1ul << CMSDK_Watchdog_RAWINTSTAT_Pos)CMSDK_Watchdog_RAWINTSTAT_PosCMSDK_Watchdog_INTCLR_Msk(0x1ul << CMSDK_Watchdog_INTCLR_Pos)CMSDK_Watchdog_INTCLR_PosCMSDK_Watchdog_CTRL_INTEN_Msk(0x1ul << CMSDK_Watchdog_CTRL_INTEN_Pos)CMSDK_Watchdog_CTRL_INTEN_PosCMSDK_Watchdog_CTRL_RESEN_Msk(0x1ul << CMSDK_Watchdog_CTRL_RESEN_Pos)CMSDK_Watchdog_CTRL_RESEN_PosCMSDK_Watchdog_VALUE_Msk(0xFFFFFFFFul << CMSDK_Watchdog_VALUE_Pos)CMSDK_Watchdog_VALUE_PosCMSDK_Watchdog_LOAD_Msk(0xFFFFFFFFul << CMSDK_Watchdog_LOAD_Pos)CMSDK_Watchdog_LOAD_PosCMSDK_PL230_ERR_CLR_Msk(0x00000001ul << CMSDK_PL230_ERR_CLR_Pos)CMSDK_PL230_ERR_CLR_PosCMSDK_PL230_CHNL_PRIORITY_CLR_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_PRIORITY_CLR_Pos)CMSDK_PL230_CHNL_PRIORITY_CLR_PosCMSDK_PL230_CHNL_PRIORITY_SET_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_PRIORITY_SET_Pos)CMSDK_PL230_CHNL_PRIORITY_SET_PosCMSDK_PL230_CHNL_PRI_ALT_CLR_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_PRI_ALT_CLR_Pos)CMSDK_PL230_CHNL_PRI_ALT_CLR_PosCMSDK_PL230_CHNL_PRI_ALT_SET_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_PRI_ALT_SET_Pos)CMSDK_PL230_CHNL_PRI_ALT_SET_PosCMSDK_PL230_CHNL_ENABLE_CLR_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_ENABLE_CLR_Pos)CMSDK_PL230_CHNL_ENABLE_CLR_PosCMSDK_PL230_CHNL_ENABLE_SET_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_ENABLE_SET_Pos)CMSDK_PL230_CHNL_ENABLE_SET_PosCMSDK_PL230_CHNL_REQ_MASK_CLR_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_REQ_MASK_CLR_Pos)CMSDK_PL230_CHNL_REQ_MASK_CLR_PosCMSDK_PL230_CHNL_REQ_MASK_SET_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_REQ_MASK_SET_Pos)CMSDK_PL230_CHNL_REQ_MASK_SET_PosCMSDK_PL230_CHNL_USEBURST_CLR_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_USEBURST_CLR_Pos)CMSDK_PL230_CHNL_USEBURST_CLR_PosCMSDK_PL230_CHNL_USEBURST_SET_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_USEBURST_SET_Pos)CMSDK_PL230_CHNL_USEBURST_SET_PosCMSDK_PL230_CHNL_SW_REQUEST_Msk(0xFFFFFFFFul << CMSDK_PL230_CHNL_SW_REQUEST_Pos)CMSDK_PL230_CHNL_SW_REQUEST_PosCMSDK_PL230_DMA_WAITONREQ_STATUS_Msk(0xFFFFFFFFul << CMSDK_PL230_DMA_WAITONREQ_STATUS_Pos)CMSDK_PL230_DMA_WAITONREQ_STATUS_PosCMSDK_PL230_ALT_CTRL_BASE_PTR_Msk(0xFFFFFFFFul << CMSDK_PL230_ALT_CTRL_BASE_PTR_Pos)CMSDK_PL230_ALT_CTRL_BASE_PTR_PosCMSDK_PL230_CTRL_BASE_PTR_Msk(0x0FFFFFFFul << CMSDK_PL230_CTRL_BASE_PTR_Pos)CMSDK_PL230_CTRL_BASE_PTR_PosPL230_DMA_CHNL_BITS + 5CMSDK_PL230_DMA_CFG_CPCPRIV_Msk(0x00000001ul << CMSDK_PL230_DMA_CFG_CPCPRIV_Pos)CMSDK_PL230_DMA_CFG_CPCPRIV_PosCMSDK_PL230_DMA_CFG_CPCBUF_Msk(0x00000001ul << CMSDK_PL230_DMA_CFG_CPCBUF_Pos)CMSDK_PL230_DMA_CFG_CPCBUF_PosCMSDK_PL230_DMA_CFG_CPCCACHE_Msk(0x00000001ul << CMSDK_PL230_DMA_CFG_CPCCACHE_Pos)CMSDK_PL230_DMA_CFG_CPCCACHE_PosCMSDK_PL230_DMA_CFG_MSTREN_Msk(0x00000001ul << CMSDK_PL230_DMA_CFG_MSTREN_Pos)CMSDK_PL230_DMA_CFG_MSTREN_PosCMSDK_PL230_DMA_STATUS_TEST_STATUS_Msk(0x00000001ul << CMSDK_PL230_DMA_STATUS_TEST_STATUS_Pos)CMSDK_PL230_DMA_STATUS_TEST_STATUS_PosCMSDK_PL230_DMA_STATUS_CHNLS_MINUS1_Msk(0x0000001Ful << CMSDK_PL230_DMA_STATUS_CHNLS_MINUS1_Pos)CMSDK_PL230_DMA_STATUS_CHNLS_MINUS1_PosCMSDK_PL230_DMA_STATUS_STATE_Msk(0x0000000Ful << CMSDK_PL230_DMA_STATUS_STATE_Pos)CMSDK_PL230_DMA_STATUS_STATE_PosCMSDK_PL230_DMA_STATUS_MSTREN_Msk(0x00000001ul << CMSDK_PL230_DMA_STATUS_MSTREN_Pos)CMSDK_PL230_DMA_STATUS_MSTREN_PosPL230_DMA_CHNL_BITSCMSDK_SYSCON_RSTINFO_LOCKUPRESET_Msk(0x00001ul << CMSDK_SYSCON_RSTINFO_LOCKUPRESET_Pos)CMSDK_SYSCON_RSTINFO_LOCKUPRESET_PosCMSDK_SYSCON_RSTINFO_WDOGRESETREQ_Msk(0x00001ul << CMSDK_SYSCON_RSTINFO_WDOGRESETREQ_Pos)CMSDK_SYSCON_RSTINFO_WDOGRESETREQ_PosCMSDK_SYSCON_RSTINFO_SYSRESETREQ_Msk(0x00001ul << CMSDK_SYSCON_RSTINFO_SYSRESETREQ_Pos)CMSDK_SYSCON_RSTINFO_SYSRESETREQ_PosCMSDK_SYSCON_EMICTRL_RCYC_Msk(0x00007ul << CMSDK_SYSCON_EMICTRL_RCYC_Pos)CMSDK_SYSCON_EMICTRL_RCYC_PosCMSDK_SYSCON_EMICTRL_WCYC_Msk(0x00003ul << CMSDK_SYSCON_EMICTRL_WCYC_Pos)CMSDK_SYSCON_EMICTRL_WCYC_PosCMSDK_SYSCON_EMICTRL_TACYC_Msk(0x00007ul << CMSDK_SYSCON_EMICTRL_TACYC_Pos)CMSDK_SYSCON_EMICTRL_TACYC_PosCMSDK_SYSCON_EMICTRL_SIZE_Msk(0x00001ul << CMSDK_SYSCON_EMICTRL_SIZE_Pos)CMSDK_SYSCON_EMICTRL_SIZE_PosCMSDK_SYSCON_LOCKUPRST_RESETOP_Msk(0x01ul << CMSDK_SYSCON_LOCKUPRST_RESETOP_Pos)CMSDK_SYSCON_LOCKUPRST_RESETOP_PosCMSDK_SYSCON_PMUCTRL_EN_Msk(0x01ul << CMSDK_SYSCON_PMUCTRL_EN_Pos)CMSDK_SYSCON_PMUCTRL_EN_PosCMSDK_SYSCON_REMAP_Msk(0x01ul << CMSDK_SYSCON_REMAP_Pos)CMSDK_SYSCON_REMAP_PosCMSDK_GPIO_MASKHIGHBYTE_Msk(0xFF00ul << CMSDK_GPIO_MASKHIGHBYTE_Pos)CMSDK_GPIO_MASKHIGHBYTE_PosCMSDK_GPIO_MASKLOWBYTE_Msk(0x00FFul << CMSDK_GPIO_MASKLOWBYTE_Pos)CMSDK_GPIO_MASKLOWBYTE_PosCMSDK_GPIO_INTCLEAR_Msk(0xFFul << CMSDK_GPIO_INTCLEAR_Pos)CMSDK_GPIO_INTCLEAR_PosCMSDK_GPIO_INTSTATUS_Msk(0xFFul << CMSDK_GPIO_INTSTATUS_Pos)CMSDK_GPIO_INTSTATUS_PosCMSDK_GPIO_INTPOLCLR_Msk(0xFFFFul << CMSDK_GPIO_INTPOL_Pos)CMSDK_GPIO_INTPOLCLR_PosCMSDK_GPIO_INTPOLSET_MskCMSDK_GPIO_INTPOLSET_PosCMSDK_GPIO_INTTYPECLR_Msk(0xFFFFul << CMSDK_GPIO_INTTYPE_Pos)CMSDK_GPIO_INTTYPECLR_PosCMSDK_GPIO_INTTYPESET_MskCMSDK_GPIO_INTTYPESET_PosCMSDK_GPIO_INTENCLR_Msk(0xFFFFul << CMSDK_GPIO_INTEN_Pos)CMSDK_GPIO_INTENCLR_PosCMSDK_GPIO_INTENSET_MskCMSDK_GPIO_INTENSET_PosCMSDK_GPIO_ALTFUNCCLR_Msk(0xFFFFul << CMSDK_GPIO_ALTFUNC_Pos)CMSDK_GPIO_ALTFUNCCLR_PosCMSDK_GPIO_ALTFUNCSET_MskCMSDK_GPIO_ALTFUNCSET_PosCMSDK_GPIO_OUTENCLR_Msk(0xFFFFul << CMSDK_GPIO_OUTEN_Pos)CMSDK_GPIO_OUTENCLR_PosCMSDK_GPIO_OUTENSET_MskCMSDK_GPIO_OUTENSET_PosCMSDK_GPIO_DATAOUT_Msk(0xFFFFul << CMSDK_GPIO_DATAOUT_Pos)CMSDK_GPIO_DATAOUT_PosCMSDK_GPIO_DATA_Msk(0xFFFFul << CMSDK_GPIO_DATA_Pos)CMSDK_GPIO_DATA_PosCMSDK_DUALTIMER_BGLOAD_Msk(0xFFFFFFFFul << CMSDK_DUALTIMER_BGLOAD_Pos)CMSDK_DUALTIMER_BGLOAD_PosCMSDK_DUALTIMER_MASKINTSTAT_Msk(0x1ul << CMSDK_DUALTIMER_MASKINTSTAT_Pos)CMSDK_DUALTIMER_MASKINTSTAT_PosCMSDK_DUALTIMER_RAWINTSTAT_Msk(0x1ul << CMSDK_DUALTIMER_RAWINTSTAT_Pos)CMSDK_DUALTIMER_RAWINTSTAT_PosCMSDK_DUALTIMER_INTCLR_Msk(0x1ul << CMSDK_DUALTIMER_INTCLR_Pos)CMSDK_DUALTIMER_INTCLR_PosCMSDK_DUALTIMER_CTRL_ONESHOOT_Msk(0x1ul << CMSDK_DUALTIMER_CTRL_ONESHOOT_Pos)CMSDK_DUALTIMER_CTRL_ONESHOOT_PosCMSDK_DUALTIMER_CTRL_SIZE_Msk(0x1ul << CMSDK_DUALTIMER_CTRL_SIZE_Pos)CMSDK_DUALTIMER_CTRL_SIZE_PosCMSDK_DUALTIMER_CTRL_PRESCALE_Msk(0x3ul << CMSDK_DUALTIMER_CTRL_PRESCALE_Pos)CMSDK_DUALTIMER_CTRL_PRESCALE_PosCMSDK_DUALTIMER_CTRL_INTEN_Msk(0x1ul << CMSDK_DUALTIMER_CTRL_INTEN_Pos)CMSDK_DUALTIMER_CTRL_INTEN_PosCMSDK_DUALTIMER_CTRL_MODE_Msk(0x1ul << CMSDK_DUALTIMER_CTRL_MODE_Pos)CMSDK_DUALTIMER_CTRL_MODE_PosCMSDK_DUALTIMER_CTRL_EN_Msk(0x1ul << CMSDK_DUALTIMER_CTRL_EN_Pos)CMSDK_DUALTIMER_CTRL_EN_PosCMSDK_DUALTIMER_VALUE_Msk(0xFFFFFFFFul << CMSDK_DUALTIMER_VALUE_Pos)CMSDK_DUALTIMER_VALUE_PosCMSDK_DUALTIMER_LOAD_Msk(0xFFFFFFFFul << CMSDK_DUALTIMER_LOAD_Pos)CMSDK_DUALTIMER_LOAD_PosCMSDK_DUALTIMER2_BGLOAD_Msk(0xFFFFFFFFul << CMSDK_DUALTIMER2_BGLOAD_Pos)CMSDK_DUALTIMER2_BGLOAD_PosCMSDK_DUALTIMER2_MASKINTSTAT_Msk(0x1ul << CMSDK_DUALTIMER2_MASKINTSTAT_Pos)CMSDK_DUALTIMER2_MASKINTSTAT_PosCMSDK_DUALTIMER2_RAWINTSTAT_Msk(0x1ul << CMSDK_DUALTIMER2_RAWINTSTAT_Pos)CMSDK_DUALTIMER2_RAWINTSTAT_PosCMSDK_DUALTIMER2_INTCLR_Msk(0x1ul << CMSDK_DUALTIMER2_INTCLR_Pos)CMSDK_DUALTIMER2_INTCLR_PosCMSDK_DUALTIMER2_CTRL_ONESHOOT_Msk(0x1ul << CMSDK_DUALTIMER2_CTRL_ONESHOOT_Pos)CMSDK_DUALTIMER2_CTRL_ONESHOOT_PosCMSDK_DUALTIMER2_CTRL_SIZE_Msk(0x1ul << CMSDK_DUALTIMER2_CTRL_SIZE_Pos)CMSDK_DUALTIMER2_CTRL_SIZE_PosCMSDK_DUALTIMER2_CTRL_PRESCALE_Msk(0x3ul << CMSDK_DUALTIMER2_CTRL_PRESCALE_Pos)CMSDK_DUALTIMER2_CTRL_PRESCALE_PosCMSDK_DUALTIMER2_CTRL_INTEN_Msk(0x1ul << CMSDK_DUALTIMER2_CTRL_INTEN_Pos)CMSDK_DUALTIMER2_CTRL_INTEN_PosCMSDK_DUALTIMER2_CTRL_MODE_Msk(0x1ul << CMSDK_DUALTIMER2_CTRL_MODE_Pos)CMSDK_DUALTIMER2_CTRL_MODE_PosCMSDK_DUALTIMER2_CTRL_EN_Msk(0x1ul << CMSDK_DUALTIMER2_CTRL_EN_Pos)CMSDK_DUALTIMER2_CTRL_EN_PosCMSDK_DUALTIMER2_VALUE_Msk(0xFFFFFFFFul << CMSDK_DUALTIMER2_VALUE_Pos)CMSDK_DUALTIMER2_VALUE_PosCMSDK_DUALTIMER2_LOAD_Msk(0xFFFFFFFFul << CMSDK_DUALTIMER2_LOAD_Pos)CMSDK_DUALTIMER2_LOAD_PosCMSDK_DUALTIMER1_BGLOAD_Msk(0xFFFFFFFFul << CMSDK_DUALTIMER1_BGLOAD_Pos)CMSDK_DUALTIMER1_BGLOAD_PosCMSDK_DUALTIMER1_MASKINTSTAT_Msk(0x1ul << CMSDK_DUALTIMER1_MASKINTSTAT_Pos)CMSDK_DUALTIMER1_MASKINTSTAT_PosCMSDK_DUALTIMER1_RAWINTSTAT_Msk(0x1ul << CMSDK_DUALTIMER1_RAWINTSTAT_Pos)CMSDK_DUALTIMER1_RAWINTSTAT_PosCMSDK_DUALTIMER1_INTCLR_Msk(0x1ul << CMSDK_DUALTIMER1_INTCLR_Pos)CMSDK_DUALTIMER1_INTCLR_PosCMSDK_DUALTIMER1_CTRL_ONESHOOT_Msk(0x1ul << CMSDK_DUALTIMER1_CTRL_ONESHOOT_Pos)CMSDK_DUALTIMER1_CTRL_ONESHOOT_PosCMSDK_DUALTIMER1_CTRL_SIZE_Msk(0x1ul << CMSDK_DUALTIMER1_CTRL_SIZE_Pos)CMSDK_DUALTIMER1_CTRL_SIZE_PosCMSDK_DUALTIMER1_CTRL_PRESCALE_Msk(0x3ul << CMSDK_DUALTIMER1_CTRL_PRESCALE_Pos)CMSDK_DUALTIMER1_CTRL_PRESCALE_PosCMSDK_DUALTIMER1_CTRL_INTEN_Msk(0x1ul << CMSDK_DUALTIMER1_CTRL_INTEN_Pos)CMSDK_DUALTIMER1_CTRL_INTEN_PosCMSDK_DUALTIMER1_CTRL_MODE_Msk(0x1ul << CMSDK_DUALTIMER1_CTRL_MODE_Pos)CMSDK_DUALTIMER1_CTRL_MODE_PosCMSDK_DUALTIMER1_CTRL_EN_Msk(0x1ul << CMSDK_DUALTIMER1_CTRL_EN_Pos)CMSDK_DUALTIMER1_CTRL_EN_PosCMSDK_DUALTIMER1_VALUE_Msk(0xFFFFFFFFul << CMSDK_DUALTIMER1_VALUE_Pos)CMSDK_DUALTIMER1_VALUE_PosCMSDK_DUALTIMER1_LOAD_Msk(0xFFFFFFFFul << CMSDK_DUALTIMER1_LOAD_Pos)CMSDK_DUALTIMER1_LOAD_PosCMSDK_TIMER_INTCLEAR_Msk(0x01ul << CMSDK_TIMER_INTCLEAR_Pos)CMSDK_TIMER_INTCLEAR_PosCMSDK_TIMER_INTSTATUS_Msk(0x01ul << CMSDK_TIMER_INTSTATUS_Pos)CMSDK_TIMER_INTSTATUS_PosCMSDK_TIMER_RELOAD_VAL_Msk(0xFFFFFFFFul << CMSDK_TIMER_RELOAD_VAL_Pos)CMSDK_TIMER_RELOAD_VAL_PosCMSDK_TIMER_VAL_CURRENT_Msk(0xFFFFFFFFul << CMSDK_TIMER_VAL_CURRENT_Pos)CMSDK_TIMER_VAL_CURRENT_PosCMSDK_TIMER_CTRL_EN_Msk(0x01ul << CMSDK_TIMER_CTRL_EN_Pos)CMSDK_TIMER_CTRL_EN_PosCMSDK_TIMER_CTRL_SELEXTEN_Msk(0x01ul << CMSDK_TIMER_CTRL_SELEXTEN_Pos)CMSDK_TIMER_CTRL_SELEXTEN_PosCMSDK_TIMER_CTRL_SELEXTCLK_Msk(0x01ul << CMSDK_TIMER_CTRL_SELEXTCLK_Pos)CMSDK_TIMER_CTRL_SELEXTCLK_PosCMSDK_TIMER_CTRL_IRQEN_Msk(0x01ul << CMSDK_TIMER_CTRL_IRQEN_Pos)CMSDK_TIMER_CTRL_IRQEN_PosCMSDK_UART_BAUDDIV_Msk(0xFFFFFul << CMSDK_UART_BAUDDIV_Pos)CMSDK_UART_BAUDDIV_PosCMSDK_UART_CTRL_TXIRQ_Msk(0x01ul << CMSDK_UART_CTRL_TXIRQ_Pos)CMSDK_UART_CTRL_TXIRQ_PosCMSDK_UART_CTRL_RXIRQ_Msk(0x01ul << CMSDK_UART_CTRL_RXIRQ_Pos)CMSDK_UART_CTRL_RXIRQ_PosCMSDK_UART_CTRL_TXORIRQ_Msk(0x01ul << CMSDK_UART_CTRL_TXORIRQ_Pos)CMSDK_UART_CTRL_TXORIRQ_PosCMSDK_UART_CTRL_RXORIRQ_Msk(0x01ul << CMSDK_UART_INTSTATUS_RXORIRQ_Pos)CMSDK_UART_INTSTATUS_RXORIRQ_PosCMSDK_UART_CTRL_TXEN_Msk(0x01ul << CMSDK_UART_CTRL_TXEN_Pos)CMSDK_UART_CTRL_TXEN_PosCMSDK_UART_CTRL_RXEN_Msk(0x01ul << CMSDK_UART_CTRL_RXEN_Pos)CMSDK_UART_CTRL_RXEN_PosCMSDK_UART_CTRL_TXIRQEN_Msk(0x01ul << CMSDK_UART_CTRL_TXIRQEN_Pos)CMSDK_UART_CTRL_TXIRQEN_PosCMSDK_UART_CTRL_RXIRQEN_Msk(0x01ul << CMSDK_UART_CTRL_RXIRQEN_Pos)CMSDK_UART_CTRL_RXIRQEN_PosCMSDK_UART_CTRL_TXORIRQEN_Msk(0x01ul << CMSDK_UART_CTRL_TXORIRQEN_Pos)CMSDK_UART_CTRL_TXORIRQEN_PosCMSDK_UART_CTRL_RXORIRQEN_Msk(0x01ul << CMSDK_UART_CTRL_RXORIRQEN_Pos)CMSDK_UART_CTRL_RXORIRQEN_PosCMSDK_UART_CTRL_HSTM_Msk(0x01ul << CMSDK_UART_CTRL_HSTM_Pos)CMSDK_UART_CTRL_HSTM_PosCMSDK_UART_STATE_TXBF_Msk(0x1ul << CMSDK_UART_STATE_TXBF_Pos )CMSDK_UART_STATE_TXBF_PosCMSDK_UART_STATE_RXBF_Msk(0x1ul << CMSDK_UART_STATE_RXBF_Pos)CMSDK_UART_STATE_RXBF_PosCMSDK_UART_STATE_TXOR_Msk(0x1ul << CMSDK_UART_STATE_TXOR_Pos)CMSDK_UART_STATE_TXOR_PosCMSDK_UART_STATE_RXOR_Msk(0x1ul << CMSDK_UART_STATE_RXOR_Pos)CMSDK_UART_STATE_RXOR_PosCMSDK_UART_DATA_Msk(0xFFul << CMSDK_UART_DATA_Pos)CMSDK_UART_DATA_Pos0x0201CMSDK_CM3_Hdefined ( __CC_ARM   )defined(__ICCARM__)defined(__TMS470__)defined(__TASKING__)/* CMSDK_CM3_H *//* ================================================================================ *//* ================             Peripheral declaration             ================ *//* AHB peripherals                                                                  *//* APB peripherals                                                                  *//* Peripheral and SRAM base address                                                 *//* ================              Peripheral memory map             ================ *//* anonymous unions are enabled by default *//* leave anonymous unions enabled *//* --------------------  End of section using anonymous unions  ------------------- *//* CMSDK_Watchdog INTEGTESTOUTSET: Integration Test Output Set Mask *//* CMSDK_Watchdog INTEGTESTOUTSET: Integration Test Output Set Position *//* CMSDK_Watchdog INTEGTESTEN: Integration Test Enable Mask *//* CMSDK_Watchdog INTEGTESTEN: Integration Test Enable Position *//* CMSDK_Watchdog LOCK: LOCK Mask *//* CMSDK_Watchdog LOCK: LOCK Position *//* CMSDK_Watchdog MASKINTSTAT: Mask Int Status Mask *//* CMSDK_Watchdog MASKINTSTAT: Mask Int Status Position *//* CMSDK_Watchdog RAWINTSTAT: Raw Int Status Mask *//* CMSDK_Watchdog RAWINTSTAT: Raw Int Status Position *//* CMSDK_Watchdog INTCLR: Int Clear Mask *//* CMSDK_Watchdog INTCLR: Int Clear Position *//* CMSDK_Watchdog CTRL_INTEN: Int Enable Mask *//* CMSDK_Watchdog CTRL_INTEN: Int Enable Position *//* CMSDK_Watchdog CTRL_RESEN: Enable Reset Output Mask *//* CMSDK_Watchdog CTRL_RESEN: Enable Reset Output Position *//* CMSDK_Watchdog VALUE: VALUE Mask *//* CMSDK_Watchdog VALUE: VALUE Position *//* CMSDK_Watchdog LOAD: LOAD Mask *//* CMSDK_Watchdog LOAD: LOAD Position *//* Offset: 0xF04 ( /W) Watchdog Integration Test Output Set Register *//* Offset: 0xF00 (R/W) Watchdog Integration Test Control Register *//* Offset: 0xC00 (R/W) Watchdog Lock Register *//* Offset: 0x014 (R/ ) Watchdog Interrupt Status Register *//* Offset: 0x010 (R/ ) Watchdog Raw Interrupt Status Register *//* Offset: 0x00C ( /W) Watchdog Clear Interrupt Register *//* Offset: 0x008 (R/W) Watchdog Control Register *//* Offset: 0x004 (R/ ) Watchdog Value Register *//* Offset: 0x000 (R/W) Watchdog Load Register *//*------------------- Watchdog ----------------------------------------------*//* CMSDK_PL230 ERR: CLR Mask *//* CMSDK_PL230 ERR: CLR Position *//* CMSDK_PL230 CHNL_PRIORITY: CLR Mask *//* CMSDK_PL230 CHNL_PRIORITY: CLR Position *//* CMSDK_PL230 CHNL_PRIORITY: SET Mask *//* CMSDK_PL230 CHNL_PRIORITY: SET Position *//* CMSDK_PL230 CHNL_PRI_ALT: CLR Mask *//* CMSDK_PL230 CHNL_PRI_ALT: CLR Position *//* CMSDK_PL230 CHNL_PRI_ALT: SET Mask *//* CMSDK_PL230 CHNL_PRI_ALT: SET Position *//* CMSDK_PL230 CHNL_ENABLE: CLR Mask *//* CMSDK_PL230 CHNL_ENABLE: CLR Position *//* CMSDK_PL230 CHNL_ENABLE: SET Mask *//* CMSDK_PL230 CHNL_ENABLE: SET Position *//* CMSDK_PL230 CHNL_REQ_MASK: CLR Mask *//* CMSDK_PL230 CHNL_REQ_MASK: CLR Position *//* CMSDK_PL230 CHNL_REQ_MASK: SET Mask *//* CMSDK_PL230 CHNL_REQ_MASK: SET Position *//* CMSDK_PL230 CHNL_USEBURST: CLR Mask *//* CMSDK_PL230 CHNL_USEBURST: CLR Position *//* CMSDK_PL230 CHNL_USEBURST: SET Mask *//* CMSDK_PL230 CHNL_USEBURST: SET Position *//* CMSDK_PL230 CHNL_SW_REQUEST: CHNL_SW_REQUEST Mask *//* CMSDK_PL230 CHNL_SW_REQUEST: CHNL_SW_REQUEST Position *//* CMSDK_PL230 DMA_WAITONREQ_STATUS: DMA_WAITONREQ_STATUS Mask *//* CMSDK_PL230 DMA_WAITONREQ_STATUS: DMA_WAITONREQ_STATUS Position *//* CMSDK_PL230 STATUS: MSTREN Mask *//* CMSDK_PL230 STATUS: MSTREN Position *//* CMSDK_PL230 STATUS: BASE_PTR Mask *//* CMSDK_PL230 STATUS: BASE_PTR Position *//* CMSDK_PL230 DMA CFG: CPCPRIV Mask *//* CMSDK_PL230 DMA CFG: CPCPRIV Position *//* CMSDK_PL230 DMA CFG: CPCBUF Mask *//* CMSDK_PL230 DMA CFG: CPCBUF Position *//* CMSDK_PL230 DMA CFG: CPCCACHE Mask *//* CMSDK_PL230 DMA CFG: CPCCACHE Position *//* CMSDK_PL230 DMA CFG: MSTREN Mask *//* CMSDK_PL230 DMA CFG: MSTREN Position *//* CMSDK_PL230 DMA STATUS: TEST_STATUS Mask *//* CMSDK_PL230 DMA STATUS: TEST_STATUS Position *//* CMSDK_PL230 DMA STATUS: CHNLS_MINUS1 Mask *//* CMSDK_PL230 DMA STATUS: CHNLS_MINUS1 Position *//* CMSDK_PL230 DMA STATUS: STATE Mask *//* CMSDK_PL230 DMA STATUS: STATE Position *//* CMSDK_PL230 DMA STATUS: MSTREN Mask *//* CMSDK_PL230 DMA STATUS: MSTREN Position *//* Offset: 0x04C Bus Error Clear Register  (R/W) *//* Offset: 0x03C ( /W) Channel Priority Clear Register *//* Offset: 0x038 (R/W) Channel Priority Set Register *//* Offset: 0x034 ( /W) Channel Primary-Alterante Clear Register *//* Offset: 0x030 (R/W) Channel Primary-Alterante Set Register *//* Offset: 0x02C ( /W) Channel Enable Clear Register *//* Offset: 0x028 (R/W) Channel Enable Set Register *//* Offset: 0x024 ( /W) Channel Request Mask Clear Register *//* Offset: 0x020 (R/W) Channel Request Mask Set Register *//* Offset: 0x01C ( /W) Channel UseBurst Clear Register *//* Offset: 0x018 (R/W) Channel UseBurst Set Register *//* Offset: 0x014 ( /W) Channel Software Request Register *//* Offset: 0x010 (R/ ) Channel Wait On Request Status Register *//* Offset: 0x00C (R/ ) Channel Alternate Control Data Base Pointer Register *//* Offset: 0x008 (R/W) Channel Control Data Base Pointer Register *//* Offset: 0x004 ( /W) DMA configuration Register *//* Offset: 0x000 (R/W) DMA status Register *//*------------- PL230 uDMA (PL230) --------------------------------------*//* CMSDK_SYSCON RSTINFO: LOCKUPRESET Mask *//* CMSDK_SYSCON RSTINFO: WDOGRESETREQ Mask *//* CMSDK_SYSCON RSTINFO: SYSRESETREQ Mask *//* CMSDK_SYSCON EMICTRL: READCYCLE Mask *//* CMSDK_SYSCON EMICTRL: WRITECYCLE Mask *//* CMSDK_SYSCON EMICTRL: TURNAROUNDCYCLE Mask *//* CMSDK_SYSCON EMICTRL: SIZE Mask *//* CMSDK_SYSCON SYS_CTRL: LOCKUP RESET ENABLE Mask *//* CMSDK_SYSCON PMUCTRL: PMUCTRL ENABLE Mask *//* CMSDK_SYSCON MEME_CTRL: REMAP Mask *//* Offset: 0x010 (R/W) Reset Information Register *//* Offset: 0x00C (R/W) EMI Control Register *//* Offset: 0x008 (R/W) Reset Option Register *//* Offset: 0x004 (R/W) PMU Control Register *//* Offset: 0x000 (R/W) Remap Control Register *//*------------- System Control (SYSCON) --------------------------------------*//* CMSDK_GPIO MASKHIGHBYTE: MASKHIGHBYTE Mask *//* CMSDK_GPIO MASKHIGHBYTE: MASKHIGHBYTE Position *//* CMSDK_GPIO MASKLOWBYTE: MASKLOWBYTE Mask *//* CMSDK_GPIO MASKLOWBYTE: MASKLOWBYTE Position *//* CMSDK_GPIO INTCLEAR: INTCLEAR Mask *//* CMSDK_GPIO INTCLEAR: INTCLEAR Position *//* CMSDK_GPIO INTSTATUS: INTSTATUS Mask *//* CMSDK_GPIO INTSTATUS: INTSTATUS Position *//* CMSDK_GPIO INTPOL: INTPOL Mask *//* CMSDK_GPIO INTPOL: INTPOL Position *//* CMSDK_GPIO INTTYPE: INTTYPE Mask *//* CMSDK_GPIO INTTYPE: INTTYPE Position *//* CMSDK_GPIO INTEN: INTEN Mask *//* CMSDK_GPIO INTEN: INTEN Position *//* CMSDK_GPIO ALTFUNC: ALTFUNC Mask *//* CMSDK_GPIO ALTFUNC: ALTFUNC Position *//* CMSDK_GPIO OUTEN: OUTEN Mask *//* CMSDK_GPIO OUTEN: OUTEN Position *//* CMSDK_GPIO DATAOUT: DATAOUT Mask *//* CMSDK_GPIO DATAOUT: DATAOUT Position *//* CMSDK_GPIO DATA: DATA Mask *//* CMSDK_GPIO DATA: DATA Position *//* Offset: 0x800 - 0xBFC Upper byte Masked Access Register (R/W) *//* Offset: 0x400 - 0x7FC Lower byte Masked Access Register (R/W) *//* Offset: 0x038 ( /W) Interrupt Clear Register *//* Offset: 0x038 (R/ ) Interrupt Status Register *//* Offset: 0x034 (R/W) Interrupt Polarity Clear Register *//* Offset: 0x030 (R/W) Interrupt Polarity Set Register *//* Offset: 0x02C (R/W) Interrupt Type Clear Register *//* Offset: 0x028 (R/W) Interrupt Type Set Register *//* Offset: 0x024 (R/W) Interrupt Enable Clear Register *//* Offset: 0x020 (R/W) Interrupt Enable Set Register *//* Offset: 0x01C (R/W) Alternate Function Clear Register *//* Offset: 0x018 (R/W) Alternate Function Set Register *//* Offset: 0x014 (R/W) Output Enable Clear Register *//* Offset: 0x010 (R/W) Output Enable Set Register *//* Offset: 0x004 (R/W) Data Output Latch Register *//* Offset: 0x000 (R/W) DATA Register *//*-------------------- General Purpose Input Output (GPIO) -------------------*//* CMSDK_DUALTIMER BGLOAD: Background Load Mask *//* CMSDK_DUALTIMER BGLOAD: Background Load Position *//* CMSDK_DUALTIMER MASKINTSTAT: Mask Int Status Mask *//* CMSDK_DUALTIMER MASKINTSTAT: Mask Int Status Position *//* CMSDK_DUALTIMER RAWINTSTAT: Raw Int Status Mask *//* CMSDK_DUALTIMER RAWINTSTAT: Raw Int Status Position *//* CMSDK_DUALTIMER INTCLR: INT Clear  Mask *//* CMSDK_DUALTIMER INTCLR: INT Clear Position *//* CMSDK_DUALTIMER CTRL_ONESHOOT: CTRL ONESHOOT Mask *//* CMSDK_DUALTIMER CTRL_ONESHOOT: CTRL ONESHOOT Position *//* CMSDK_DUALTIMER CTRL_SIZE: CTRL SIZE Mask *//* CMSDK_DUALTIMER CTRL_SIZE: CTRL SIZE Position *//* CMSDK_DUALTIMER CTRL_PRESCALE: CTRL PRESCALE Mask *//* CMSDK_DUALTIMER CTRL_PRESCALE: CTRL PRESCALE Position *//* CMSDK_DUALTIMER CTRL_INTEN: CTRL Int Enable Mask *//* CMSDK_DUALTIMER CTRL_INTEN: CTRL Int Enable Position *//* CMSDK_DUALTIMER CTRL_MODE: CTRL MODE Mask *//* CMSDK_DUALTIMER CTRL_MODE: CTRL MODE Position *//* CMSDK_DUALTIMER CTRL_EN: CTRL Enable Mask *//* CMSDK_DUALTIMER CTRL_EN: CTRL Enable Position *//* CMSDK_DUALTIMER VALUE: VALUE Mask *//* CMSDK_DUALTIMER VALUE: VALUE Position *//* CMSDK_DUALTIMER LOAD: LOAD Mask *//* CMSDK_DUALTIMER LOAD: LOAD Position *//* Offset: 0x000 (R/W) Background Load Register *//* Offset: 0x000 (R/W) Timer Masked Interrupt Status *//* Offset: 0x000 (R/W) Timer Raw Interrupt Status *//* Offset: 0x000 (R/W) Timer Interrupt Clear *//* Offset: 0x000 (R/W) Timer Control *//* Offset: 0x000 (R/W) Timer Counter Current Value *//* Offset: 0x000 (R/W) Timer Load *//* CMSDK_DUALTIMER2 BGLOAD: Background Load Mask *//* CMSDK_DUALTIMER2 BGLOAD: Background Load Position *//* CMSDK_DUALTIMER2 MASKINTSTAT: Mask Int Status Mask *//* CMSDK_DUALTIMER2 MASKINTSTAT: Mask Int Status Position *//* CMSDK_DUALTIMER2 RAWINTSTAT: Raw Int Status Mask *//* CMSDK_DUALTIMER2 RAWINTSTAT: Raw Int Status Position *//* CMSDK_DUALTIMER2 INTCLR: INT Clear  Mask *//* CMSDK_DUALTIMER2 INTCLR: INT Clear Position *//* CMSDK_DUALTIMER2 CTRL_ONESHOOT: CTRL ONESHOOT Mask *//* CMSDK_DUALTIMER2 CTRL_ONESHOOT: CTRL ONESHOOT Position *//* CMSDK_DUALTIMER2 CTRL_SIZE: CTRL SIZE Mask *//* CMSDK_DUALTIMER2 CTRL_SIZE: CTRL SIZE Position *//* CMSDK_DUALTIMER2 CTRL_PRESCALE: CTRL PRESCALE Mask *//* CMSDK_DUALTIMER2 CTRL_PRESCALE: CTRL PRESCALE Position *//* CMSDK_DUALTIMER2 CTRL_INTEN: CTRL Int Enable Mask *//* CMSDK_DUALTIMER2 CTRL_INTEN: CTRL Int Enable Position *//* CMSDK_DUALTIMER2 CTRL_MODE: CTRL MODE Mask *//* CMSDK_DUALTIMER2 CTRL_MODE: CTRL MODE Position *//* CMSDK_DUALTIMER2 CTRL_EN: CTRL Enable Mask *//* CMSDK_DUALTIMER2 CTRL_EN: CTRL Enable Position *//* CMSDK_DUALTIMER2 VALUE: VALUE Mask *//* CMSDK_DUALTIMER2 VALUE: VALUE Position *//* CMSDK_DUALTIMER2 LOAD: LOAD Mask *//* CMSDK_DUALTIMER2 LOAD: LOAD Position *//* CMSDK_DUALTIMER1 BGLOAD: Background Load Mask *//* CMSDK_DUALTIMER1 BGLOAD: Background Load Position *//* CMSDK_DUALTIMER1 MASKINTSTAT: Mask Int Status Mask *//* CMSDK_DUALTIMER1 MASKINTSTAT: Mask Int Status Position *//* CMSDK_DUALTIMER1 RAWINTSTAT: Raw Int Status Mask *//* CMSDK_DUALTIMER1 RAWINTSTAT: Raw Int Status Position *//* CMSDK_DUALTIMER1 INTCLR: INT Clear  Mask *//* CMSDK_DUALTIMER1 INTCLR: INT Clear Position *//* CMSDK_DUALTIMER1 CTRL_ONESHOOT: CTRL ONESHOOT Mask *//* CMSDK_DUALTIMER1 CTRL_ONESHOOT: CTRL ONESHOOT Position *//* CMSDK_DUALTIMER1 CTRL_SIZE: CTRL SIZE Mask *//* CMSDK_DUALTIMER1 CTRL_SIZE: CTRL SIZE Position *//* CMSDK_DUALTIMER1 CTRL_PRESCALE: CTRL PRESCALE Mask *//* CMSDK_DUALTIMER1 CTRL_PRESCALE: CTRL PRESCALE Position *//* CMSDK_DUALTIMER1 CTRL_INTEN: CTRL Int Enable Mask *//* CMSDK_DUALTIMER1 CTRL_INTEN: CTRL Int Enable Position *//* CMSDK_DUALTIMER1 CTRL_MODE: CTRL MODE Mask *//* CMSDK_DUALTIMER1 CTRL_MODE: CTRL MODE Position *//* CMSDK_DUALTIMER1 CTRL_EN: CTRL Enable Mask *//* CMSDK_DUALTIMER1 CTRL_EN: CTRL Enable Position *//* CMSDK_DUALTIMER1 VALUE: VALUE Mask *//* CMSDK_DUALTIMER1 VALUE: VALUE Position *//* CMSDK_DUALTIMER1 LOAD: LOAD Mask *//* CMSDK_DUALTIMER1 LOAD: LOAD Position *//* Offset: 0xF04 ( /W) Integration Test Output Set Register *//* Offset: 0xF00 (R/W) Integration Test Control Register *//* Offset: 0x038 (R/W) Background Load Register *//* Offset: 0x034 (R/ ) Timer 2 Masked Interrupt Status *//* Offset: 0x030 (R/ ) Timer 2 Raw Interrupt Status *//* Offset: 0x02C ( /W) Timer 2 Interrupt Clear *//* Offset: 0x028 (R/W) Timer 2 Control *//* Offset: 0x024 (R/ ) Timer 2 Counter Current Value *//* Offset: 0x020 (R/W) Timer 2 Load *//* Offset: 0x018 (R/W) Background Load Register *//* Offset: 0x014 (R/ ) Timer 1 Masked Interrupt Status *//* Offset: 0x010 (R/ ) Timer 1 Raw Interrupt Status *//* Offset: 0x00C ( /W) Timer 1 Interrupt Clear *//* Offset: 0x008 (R/W) Timer 1 Control *//* Offset: 0x004 (R/ ) Timer 1 Counter Current Value *//* Offset: 0x000 (R/W) Timer 1 Load *//*------------- Timer (TIM) --------------------------------------------------*//* CMSDK_TIMER INTCLEAR: INTCLEAR Mask *//* CMSDK_TIMER INTCLEAR: INTCLEAR Position *//* CMSDK_TIMER INTSTATUS: INTSTATUSMask *//* CMSDK_TIMER INTSTATUS: INTSTATUSPosition *//* CMSDK_TIMER RELOAD: RELOAD Mask *//* CMSDK_TIMER RELOAD: RELOAD Position *//* CMSDK_TIMER VALUE: CURRENT Mask *//* CMSDK_TIMER VALUE: CURRENT Position *//* CMSDK_TIMER CTRL: EN Mask *//* CMSDK_TIMER CTRL: EN Position *//* CMSDK_TIMER CTRL: SELEXTEN Mask *//* CMSDK_TIMER CTRL: SELEXTEN Position *//* CMSDK_TIMER CTRL: SELEXTCLK Mask *//* CMSDK_TIMER CTRL: SELEXTCLK Position *//* CMSDK_TIMER CTRL: IRQEN Mask *//* CMSDK_TIMER CTRL: IRQEN Position *//* CMSDK_TIMER CTRL Register Definitions *//* Offset: 0x00C ( /W) Interrupt Clear Register *//* Offset: 0x00C (R/ ) Interrupt Status Register *//* Offset: 0x008 (R/W) Reload Value Register *//* Offset: 0x004 (R/W) Current Value Register *//* Offset: 0x000 (R/W) Control Register *//*----------------------------- Timer (TIMER) -------------------------------*//* CMSDK_UART BAUDDIV: BAUDDIV Mask *//* CMSDK_UART BAUDDIV: BAUDDIV Position *//* CMSDK_UART CTRL: TXIRQ Mask *//* CMSDK_UART CTRL: TXIRQ Position *//* CMSDK_UART CTRL: RXIRQ Mask *//* CMSDK_UART CTRL: RXIRQ Position *//* CMSDK_UART CTRL: TXORIRQ Mask *//* CMSDK_UART CTRL: TXORIRQ Position *//* CMSDK_UART CTRL: RXORIRQ Mask *//* CMSDK_UART CTRL: RXORIRQ Position *//* CMSDK_UART CTRL: TXEN Mask *//* CMSDK_UART CTRL: TXEN Position *//* CMSDK_UART CTRL: RXEN Mask *//* CMSDK_UART CTRL: RXEN Position *//* CMSDK_UART CTRL: TXIRQEN Mask *//* CMSDK_UART CTRL: TXIRQEN Position *//* CMSDK_UART CTRL: RXIRQEN Mask *//* CMSDK_UART CTRL: RXIRQEN Position *//* CMSDK_UART CTRL: TXORIRQEN Mask *//* CMSDK_UART CTRL: TXORIRQEN Position *//* CMSDK_UART CTRL: RXORIRQEN Mask *//* CMSDK_UART CTRL: RXORIRQEN Position *//* CMSDK_UART CTRL: HSTM Mask *//* CMSDK_UART CTRL: HSTM Position *//* CMSDK_UART STATE: TXBF Mask *//* CMSDK_UART STATE: TXBF Position *//* CMSDK_UART STATE: RXBF Mask *//* CMSDK_UART STATE: RXBF Position *//* CMSDK_UART STATE: TXOR Mask *//* CMSDK_UART STATE: TXOR Position *//* CMSDK_UART STATE: RXOR Mask *//* CMSDK_UART STATE: RXOR Position *//* CMSDK_UART DATA: DATA Mask *//* CMSDK_UART_DATA_Pos: DATA Position *//* CMSDK_UART DATA Register Definitions *//* Offset: 0x010 (R/W) Baudrate Divider Register *//* Offset: 0x00C ( /W) Interrupt Clear Register  *//* Offset: 0x008 (R/W) Control Register *//* Offset: 0x004 (R/W) Status Register  *//* Offset: 0x000 (R/W) Data Register    *//*------------- Universal Asynchronous Receiver Transmitter (UART) -----------*//* -------------------  Start of section using anonymous unions  ------------------ *//* ================       Device Specific Peripheral Section       ================ *//* Processor and core peripherals                  *//* Set to 1 if different SysTick Config is used    *//* Number of Bits used for Priority Levels         *//* MPU present or not                              *//* Core revision r2p1                              *//* --------  Configuration of the Cortex-M3 Processor and Core Peripherals  ------- *//* ================      Processor and Core Peripheral Section     ================ *//*!<  GPIO Port 0 pin 7 Interrupt                      *//*!<  GPIO Port 0 pin 6 Interrupt                      *//*!<  GPIO Port 0 pin 5 Interrupt                      *//*!<  GPIO Port 0 pin 4 Interrupt                      *//*!<  GPIO Port 0 pin 3 Interrupt                      *//*!<  GPIO Port 0 pin 2 Interrupt                      *//*!<  GPIO Port 0 pin 1 Interrupt                      *//*!<  GPIO Port 0 pin 0 Interrupt                      *//*!< SHIELD SPI Combined Interrupt                     *//*!< SHIELD ADC SPI Interrupt                          *//*!< UART 4 TX Interrupt                               *//*!< UART 4 RX Interrupt                               *//*!< UART 3 TX Interrupt                               *//*!< UART 3 RX Interrupt                               *//*!< Port 3 combined Interrupt                         *//*!< Port 2 combined Interrupt                         *//*!< Touch Screen Interrupt                            *//*!< I2S Interrupt                                     *//*!< Ethernet Interrupt                                *//*!< UART 0,1,2 Overflow Interrupt                     *//*!< SPI Interrupt                                     *//*!< Dual Timer Interrupt                              *//*!< TIMER 1 Interrupt                                 *//*!< TIMER 0 Interrupt                                 *//*!< Port 1 combined Interrupt                         *//*!< Port 0 combined Interrupt                         *//*!< UART 2 TX Interrupt                               *//*!< UART 2 RX Interrupt                               *//*!< UART 1 TX Interrupt                               *//*!< UART 1 RX Interrupt                               *//*!< UART 0 TX Interrupt                               *//*!< UART 0 RX Interrupt                               *//******  CMSDK Specific Interrupt Numbers *********************************************************//* 15 System Tick Interrupt           *//* 14 Pend SV Interrupt               *//* 12 Debug Monitor Interrupt         *//* 11 SV Call Interrupt               *//*  6 Usage Fault Interrupt           *//*  5 Bus Fault Interrupt             *//*  4 Memory Management Interrupt     *//*  3 HardFault Interrupt             *//*  2 Non Maskable Interrupt          *//* -------------------  Cortex-M3 Processor Exceptions Numbers  ------------------- *//* -------------------------  Interrupt Number Definition  ------------------------ *//* MPS2 CMSIS Library
*
* Copyright (c) 2006-2016 ARM Limited
* SPDX-License-Identifier: BSD-3-Clause
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice,
* this list of conditions and the following disclaimer.
*
* 2. Redistributions in binary form must reproduce the above copyright notice,
* this list of conditions and the following disclaimer in the documentation
* and/or other materials provided with the distribution.
*
* 3. Neither the name of the copyright holder nor the names of its contributors
* may be used to endorse or promote products derived from this software without
* specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************
* @file     CMSDK_CM3.h
* @brief    CMSIS Core Peripheral Access Layer Header File for
*           CMSDK_CM3 Device
*
*******************************************************************************/4748495051/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/init/startup.c"CMSIS/core_cm3.h""CMSIS/CMSDK_CM3.h"<string.h><stdlib.h>Debug_HandlerUsageFault_HandlerBusFault_HandlerMemMang_HandlerHardFault_HandlerDefault_HandlerprvGetRegistersFromStackr0r1r2r3r12lrpcpsrReset_Handleroptimize"O0"mainuart_initxPortSysTickHandlerxPortPendSVHandlervPortSVCHandlerconst uint32_t *[]unsigned long *[]isr_vector.isr_vector".isr_vector"char[12]sectionconst uint32_t *[30]unsigned long *[30]_ebss_sbss_edata_sdata_sidata_estack/* SYS_EXIT *//* ADP_Stopped_ApplicationExit, a clean exit *//* Force qemu to exit using ARM Semihosting *//* Ethernet   13                 *//* uart overflow 1, 2,3          *//* SPI0 SPI1                     *//* Dial Timer                    *//* Timer 1                       *//* Timer 0                       *//* GPIO 2 combined interrupt     *//* GPIO 0 combined interrupt     *//* uart 2 transmit            5  *//* uart 2 receive             4  *//* uart1 transmit             3  *//* uart1 receive              2  *//* uart0 transmit             1  *//* uart0 receive              0  *//* SysTick_Handler           -1  *//* PendSV handler            -2  *//* reserved                  -3  *//* DebugMon_Handler          -4  *//* SVC_Handler               -5  *//* reserved                  -6  *//* reserved                  -7  *//* reserved                  -8  *//* reserved                  -9  *//* UsageFault_Handler        -10 *//* BusFault_Handler          -11 *//* MemManage_Handler         -12 *//* HardFault_Handler         -13 *//* NMI_Handler               -14 *//* Reset                     -15 *//* remove the warning: variable <x> is set but not used *//* When the following line is hit, the variables contain the register values. *//* Program status register. *//* Program counter. *//* Link register. *//* These are volatile to try and prevent the compiler/linker optimising them
 * away as the variables never actually get used.  If the debugger won't show the
 * values of the variables, make them global my moving their declaration outside
 * of this function. *//* jump to board initialisation *//* zero out .bss section *//* copy .data section from flash to RAM *//* set stack pointer *//* Prevent optimization so gcc does not replace code with memcpy *//Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/initstatuspulFaultStackAddress__APP_MAIN_H__/* __APP_MAIN_H__ *//**
 * @brief Main app entry point.
 */vConfigureTimerForRunTimeStatsulGetRunTimeCounterValueconfigENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY( 1 )configMAC_INTERRUPT_PRIORITYconfigMAX_SYSCALL_INTERRUPT_PRIORITYconfigKERNEL_INTERRUPT_PRIORITYprojCOVERAGE_TESTportGET_RUN_TIME_COUNTER_VALUE()ulGetRunTimeCounterValue()portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()vConfigureTimerForRunTimeStats()configUSE_QUEUE_SETSconfigNUM_THREAD_LOCAL_STORAGE_POINTERSconfigUSE_APPLICATION_TASK_TAGconfigGENERATE_RUN_TIME_STATSconfigUSE_STATS_FORMATTING_FUNCTIONSINCLUDE_xTaskAbortDelayINCLUDE_xTimerPendFunctionCallINCLUDE_xSemaphoreGetMutexHolderINCLUDE_eTaskGetStateINCLUDE_xTaskGetHandleINCLUDE_xTaskGetIdleTaskHandleINCLUDE_xTimerGetTimerDaemonTaskHandleINCLUDE_xTaskGetSchedulerStateINCLUDE_uxTaskGetStackHighWaterMark2INCLUDE_uxTaskGetStackHighWaterMarkINCLUDE_vTaskDelayINCLUDE_vTaskDelayUntilINCLUDE_vTaskSuspendINCLUDE_vTaskCleanUpResourcesINCLUDE_vTaskDeleteINCLUDE_uxTaskPriorityGetINCLUDE_vTaskPrioritySet( configMINIMAL_STACK_SIZE )configUSE_TIMERSconfigUSE_RECURSIVE_MUTEXESconfigUSE_MUTEXESconfigUSE_MALLOC_FAILED_HOOKconfigALLOW_UNPRIVILEGED_CRITICAL_SECTIONSconfigCHECK_FOR_STACK_OVERFLOWconfigSTREAM_BUFFER_TRIGGER_LEVEL_TEST_MARGINconfigNUM_TX_DESCRIPTORSconfigSUPPORT_STATIC_ALLOCATIONconfigSUPPORT_DYNAMIC_ALLOCATIONconfigUSE_COUNTING_SEMAPHORESconfigTIMER_TASK_PRIORITY( configMAX_PRIORITIES - 1 )configTIMER_QUEUE_LENGTHconfigMAX_PRIORITIES( 10 )configIDLE_SHOULD_YIELDconfigUSE_16_BIT_TICKSconfigUSE_TRACE_FACILITYconfigMAX_TASK_NAME_LENconfigTOTAL_HEAP_SIZE( ( size_t ) ( 1024 ) )( ( unsigned short ) 256 )configTICK_RATE_HZ( ( TickType_t ) 1000 )configCPU_CLOCK_HZ( ( unsigned long ) 20000000 )configUSE_DAEMON_TASK_STARTUP_HOOKconfigUSE_TICK_HOOKconfigUSE_IDLE_HOOKconfigUSE_PORT_OPTIMISED_TASK_SELECTIONconfigUSE_TIME_SLICINGconfigUSE_PREEMPTIONconfigQUEUE_REGISTRY_SIZEconfigASSERT(x)if( ( x ) == 0 ) vAssertCalled()configASSERT_DEFINEDFREERTOS_CONFIG_HHEAP3vLoggingPrintfvAssertCalled/* FREERTOS_CONFIG_H *//* Prototype for the function used to print out.  In this case it prints to the
 |     10 console before the network is connected then a UDP port after the network has
 |      9 connected. *//* equivalent to 0xa0, or priority 5. *//* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
 * See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. *//* Prototype of function that initialises the run time counter. *//* Prototype of function that returns run time counter. *//* Run time stats gathering configuration options. *//* Set the following definitions to 1 to include the API function, or zero
 * to exclude the API function. *//*-----------------------------------------------------------
* Application specific definitions.
*
* These definitions should be adjusted for your particular hardware and
* application requirements.
*
* THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
* FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
*
* See https://www.freertos.org/a00110.html
*----------------------------------------------------------*/pcFormatStringTaskFunction_tpdBIG_ENDIANpdFREERTOS_BIG_ENDIANpdLITTLE_ENDIANpdFREERTOS_LITTLE_ENDIANpdFREERTOS_ERRNO_ECANCELED140pdFREERTOS_ERRNO_EILSEQ138pdFREERTOS_ERRNO_ENOMEDIUM135pdFREERTOS_ERRNO_ENOTCONN128pdFREERTOS_ERRNO_EISCONN127pdFREERTOS_ERRNO_EADDRNOTAVAIL125pdFREERTOS_ERRNO_EALREADY120pdFREERTOS_ERRNO_EINPROGRESS119pdFREERTOS_ERRNO_ETIMEDOUT116pdFREERTOS_ERRNO_EADDRINUSE112pdFREERTOS_ERRNO_ENOPROTOOPT109pdFREERTOS_ERRNO_ENOBUFS105pdFREERTOS_ERRNO_EOPNOTSUPPpdFREERTOS_ERRNO_ENAMETOOLONG91pdFREERTOS_ERRNO_ENOTEMPTY90pdFREERTOS_ERRNO_ENMFILE89pdFREERTOS_ERRNO_EFTYPE79pdFREERTOS_ERRNO_EBADEpdFREERTOS_ERRNO_EUNATCHpdFREERTOS_ERRNO_EROFSpdFREERTOS_ERRNO_ESPIPEpdFREERTOS_ERRNO_ENOSPCpdFREERTOS_ERRNO_EINVALpdFREERTOS_ERRNO_EISDIRpdFREERTOS_ERRNO_ENOTDIRpdFREERTOS_ERRNO_ENODEVpdFREERTOS_ERRNO_EXDEVpdFREERTOS_ERRNO_EEXISTpdFREERTOS_ERRNO_EBUSYpdFREERTOS_ERRNO_EFAULTpdFREERTOS_ERRNO_EACCESpdFREERTOS_ERRNO_ENOMEMpdFREERTOS_ERRNO_EWOULDBLOCKpdFREERTOS_ERRNO_EAGAINpdFREERTOS_ERRNO_EBADFpdFREERTOS_ERRNO_ENXIOpdFREERTOS_ERRNO_EIOpdFREERTOS_ERRNO_EINTRpdFREERTOS_ERRNO_ENOENTpdFREERTOS_ERRNO_NONEpdINTEGRITY_CHECK_VALUE0x5a5a5a5aULconfigUSE_LIST_DATA_INTEGRITY_CHECK_BYTESerrQUEUE_YIELD( -5 )errQUEUE_BLOCKED( -4 )errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY( -1 )errQUEUE_FULL( ( BaseType_t ) 0 )errQUEUE_EMPTYpdFAIL( pdFALSE )pdPASS( pdTRUE )pdTRUE( ( BaseType_t ) 1 )pdFALSEpdMS_TO_TICKS(xTimeInMs)( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000U ) )PROJDEFS_HpdMS_TO_TICKS( configUSE_16_BIT_TICKS == 1 )/* PROJDEFS_H *//* Re-defining endian values for generic naming. *//* The following endian values are used by FreeRTOS+ components, not FreeRTOS
 * itself. *//* Operation canceled. *//* An invalid UTF-16 sequence was encountered. *//* No medium inserted *//* Socket is not connected *//* Socket is already connected *//* Address not available *//* Socket already connected *//* Connection already in progress *//* Connection timed out *//* Address already in use *//* Protocol not available *//* No buffer space available *//* Operation not supported on transport endpoint *//* File or path name too long *//* Directory not empty *//* No more files *//* Inappropriate file type or format *//* Invalid exchange *//* Protocol driver not attached *//* Read only file system *//* Illegal seek *//* No space left on device *//* Invalid argument *//* Is a directory *//* Not a directory *//* No such device *//* Cross-device link *//* File exists *//* Mount device busy *//* Bad address *//* Permission denied *//* Not enough memory *//* Operation would block *//* No more processes *//* Bad file number *//* No such device or address *//* I/O error *//* Interrupted system call *//* No such file or directory *//* No errors *//* The following errno values are used by FreeRTOS+ components, not FreeRTOS
 * itself. *//* Macros used for basic data corruption checks. *//* FreeRTOS error definitions. *//* Converts a time in milliseconds to a time in ticks.  This macro can be
 * overridden by a macro of the same name defined in FreeRTOSConfig.h in case the
 * definition here is not suitable for your application. *//*
 * Defines the prototype to which task functions must conform.  Defined in this
 * file to ensure the type is known before portable.h is included.
 *//*
 * FreeRTOS Kernel V10.5.1
 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * https://www.FreeRTOS.org
 * https://github.com/FreeRTOS
 *
 *//Users/mac/Downloads/FreeRTOS/Source/include/Users/mac/Downloads/FreeRTOS/SourceDEPRECATED_DEFINITIONS_HOPEN_WATCOM_INDUSTRIAL_PC_PORTOPEN_WATCOM_FLASH_LITE_186_PORTGCC_MEGA_AVRIAR_MEGA_AVRMPLAB_PIC24_PORTMPLAB_DSPIC_PORTMPLAB_PIC18F_PORTMPLAB_PIC32MX_PORT_FEDPICCSDCC_CYGNALGCC_ARM7GCC_ARM7_ECLIPSEROWLEY_LPC23xxIAR_MSP430GCC_MSP430ROWLEY_MSP430ARM7_LPC21xx_KEIL_RVDSSAM7_GCCSAM7_IARSAM9XE_IARLPC2000_IARSTR71X_IARSTR75X_IARSTR75X_GCCSTR91X_IARGCC_H8SGCC_AT91FR40008RVDS_ARMCM3_LM3S102GCC_ARMCM3_LM3S102GCC_ARMCM3IAR_ARM_CM3IAR_ARMCM3_LMHCS12_CODE_WARRIORMICROBLAZE_GCCTERN_EEGCC_HCS12GCC_MCF5235COLDFIRE_V2_GCCCOLDFIRE_V2_CODEWARRIORGCC_PPC405GCC_PPC440_16FX_SOFTUNEBCC_INDUSTRIAL_PC_PORTBCC_FLASH_LITE_186_PORT__AVR32_AVR32A____ICCAVR32____CORE____CORE__ == __AVR32A____91467D__96340__IAR_V850ES_Fx3____IAR_V850ES_Jx3____IAR_V850ES_Jx3_L____IAR_V850ES_Jx2____IAR_V850ES_Hx2____IAR_78K0R_Kx3____IAR_78K0R_Kx3L__/* DEPRECATED_DEFINITIONS_H *//* A short file name has to be used in place of the normal
 * FreeRTOSConfig.h when using the Borland compiler. *//* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
 * pre-processor definition was used to ensure the pre-processor found the correct
 * portmacro.h file for the port being used.  That scheme was deprecated in favour
 * of setting the compiler's include path such that it found the correct
 * portmacro.h file - removing the need for the constant and allowing the
 * portmacro.h file to be located anywhere in relation to the port being used.  The
 * definitions below remain in the code for backward compatibility only.  New
 * projects should not use them. */vPortSetBASEPRIulPortRaiseBASEPRIulOriginalBASEPRIulNewBASEPRIvPortRaiseBASEPRIxPortIsInsideInterruptulCurrentInterruptxReturnvResetPrivilegexIsPrivilegedvPortValidateInterruptPriorityvPortExitCriticalvPortEnterCriticalxMPU_SETTINGSMPU_SETTINGSxMPU_REGION_REGISTERSMPU_REGION_REGISTERSTickType_tUBaseType_tBaseType_tStackType_txMPU_REGION_REGISTERS[4]MPU_REGION_REGISTERS[4]portTOTAL_NUM_REGIONS_IN_TCBxRegionulRegionAttributeulRegionBaseAddressportMEMORY_BARRIER()__asm volatile ( "" ::: "memory" )portRESET_PRIVILEGE()vResetPrivilege()portRAISE_PRIVILEGE()__asm volatile ( "svc %0 \n" ::"i" ( portSVC_RAISE_PRIVILEGE ) : "memory" );portIS_PRIVILEGED()xIsPrivileged()portFORCE_INLINEinline __attribute__( ( always_inline ) )portINLINE__inlineportNOP()portASSERT_IF_INTERRUPT_PRIORITY_INVALID()vPortValidateInterruptPriority()portTASK_FUNCTION(vFunction,pvParameters)void vFunction( void * pvParameters )portTASK_FUNCTION_PROTO(vFunction,pvParameters)portEXIT_CRITICAL()vPortExitCritical()portENTER_CRITICAL()vPortEnterCritical()portENABLE_INTERRUPTS()vPortSetBASEPRI( 0 )portDISABLE_INTERRUPTS()vPortRaiseBASEPRI()portCLEAR_INTERRUPT_MASK_FROM_ISR(x)vPortSetBASEPRI( x )portSET_INTERRUPT_MASK_FROM_ISR()ulPortRaiseBASEPRI()portYIELD_FROM_ISR(x)portEND_SWITCHING_ISR( x )portEND_SWITCHING_ISR(xSwitchRequired)do { if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; } while( 0 )portNVIC_PENDSVSET_BIT( 1UL << 28UL )portNVIC_INT_CTRL_REG( *( ( volatile uint32_t * ) 0xe000ed04 ) )portYIELD_WITHIN_API(){ portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; __asm volatile ( "dsb" ::: "memory" ); __asm volatile ( "isb" ); }portYIELD()__asm volatile ( "	SVC	%0	\n"::"i" ( portSVC_YIELD ) : "memory" )portSVC_RAISE_PRIVILEGEportSVC_YIELDportSVC_START_SCHEDULERportDONT_DISCARD__attribute__( ( used ) )portBYTE_ALIGNMENTportTICK_PERIOD_MS( ( TickType_t ) 1000 / configTICK_RATE_HZ )portSTACK_GROWTHportSWITCH_TO_USER_MODE()__asm volatile ( " mrs r0, control \n orr r0, #1 \n msr control, r0 " ::: "r0", "memory" )( portNUM_CONFIGURABLE_REGIONS + 1 )portNUM_CONFIGURABLE_REGIONS( ( portLAST_CONFIGURABLE_REGION - portFIRST_CONFIGURABLE_REGION ) + 1 )portLAST_CONFIGURABLE_REGION( 2UL )portFIRST_CONFIGURABLE_REGION( 0UL )portPRIVILEGED_RAM_REGION( 7UL )portPRIVILEGED_FLASH_REGION( 6UL )portUNPRIVILEGED_FLASH_REGION( 5UL )portSTACK_REGION( 4UL )portGENERAL_PERIPHERALS_REGION( 3UL )portMPU_REGION_EXECUTE_NEVER( 0x01UL << 28UL )portMPU_REGION_CACHEABLE_BUFFERABLE( 0x07UL << 16UL )portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY( 0x02UL << 24UL )portMPU_REGION_PRIVILEGED_READ_WRITE( 0x01UL << 24UL )portMPU_REGION_READ_ONLY( 0x06UL << 24UL )portMPU_REGION_PRIVILEGED_READ_ONLY( 0x05UL << 24UL )portMPU_REGION_READ_WRITE( 0x03UL << 24UL )portPRIVILEGE_BIT( 0x80000000UL )portUSING_MPU_WRAPPERSportTICK_TYPE_IS_ATOMICportMAX_DELAY( TickType_t ) 0xffffffffULportBASE_TYPEportSTACK_TYPEportSHORTportLONGportDOUBLEportFLOATportCHARPORTMACRO_HconfigUSE_PORT_OPTIMISED_TASK_SELECTION == 1( configMAX_PRIORITIES > 32 )configASSERT/* PORTMACRO_H *//* This return will not be reached but is necessary to prevent compiler
         * warnings. *//* Obtain the number of the currently executing interrupt. *//**
 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
 * register.
 *//**
 * @brief Raise an SVC request to raise privilege.
 *//**
 * @brief Checks whether or not the processor is privileged.
 *
 * @return 1 if the processor is already privileged, 0 otherwise.
 *//* portNOP() is not required by this port. *//* configUSE_PORT_OPTIMISED_TASK_SELECTION *//* Store/clear the ready priorities in a bit map. *//* Check the configuration. *//* Generic helper function. *//* Architecture specific optimisations. *//* Task function macros as described on the FreeRTOS.org WEB site.  These are
 * not necessary for to use this port.  They are defined so the common demo files
 * (which build with all the ports) will build. *//* Critical section management. *//* Barriers are normally not required but do ensure the code is completely \
         * within the specified behaviour for the architecture. *//* Set a PendSV to request a context switch. *//* Scheduler utilities. *//* SVC numbers for various services. *//* Architecture specifics. *//* Plus 1 to create space for the stack region. *//* Plus one to make space for the stack region. *//* MPU specific constants. *//* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
 * not need to be guarded with a critical section. *//* Type definitions. *//*-----------------------------------------------------------
 * Port specific definitions.
 *
 * The settings in this file configure FreeRTOS correctly for the
 * given hardware and compiler.
 *
 * These settings should not be altered.
 *-----------------------------------------------------------
 *//Users/mac/Downloads/FreeRTOS/Source/portable/GCC/ARM_CM3_MPU/Users/mac/Downloads/FreeRTOS/Source/portable/GCC/Users/mac/Downloads/FreeRTOS/Source/portableulNewMaskValueFREERTOS_SYSTEM_CALLPRIVILEGED_DATA__attribute__( ( section( "privileged_data" ) ) )PRIVILEGED_FUNCTIONxStreamBufferGenericCreateStaticMPU_xStreamBufferGenericCreateStaticxStreamBufferGenericCreateMPU_xStreamBufferGenericCreatexStreamBufferSetTriggerLevelMPU_xStreamBufferSetTriggerLevelxStreamBufferBytesAvailableMPU_xStreamBufferBytesAvailablexStreamBufferSpacesAvailableMPU_xStreamBufferSpacesAvailablexStreamBufferResetMPU_xStreamBufferResetxStreamBufferIsEmptyMPU_xStreamBufferIsEmptyxStreamBufferIsFullMPU_xStreamBufferIsFullvStreamBufferDeleteMPU_vStreamBufferDeletexStreamBufferNextMessageLengthBytesMPU_xStreamBufferNextMessageLengthBytesxStreamBufferReceiveMPU_xStreamBufferReceivexStreamBufferSendMPU_xStreamBufferSendvEventGroupDeleteMPU_vEventGroupDeletexEventGroupSyncMPU_xEventGroupSyncxEventGroupSetBitsMPU_xEventGroupSetBitsxEventGroupClearBitsMPU_xEventGroupClearBitsxEventGroupWaitBitsMPU_xEventGroupWaitBitsxEventGroupCreateStaticMPU_xEventGroupCreateStaticxEventGroupCreateMPU_xEventGroupCreatexTimerGenericCommandMPU_xTimerGenericCommandxTimerGetExpiryTimeMPU_xTimerGetExpiryTimexTimerGetPeriodMPU_xTimerGetPerioduxTimerGetReloadModeMPU_uxTimerGetReloadModevTimerSetReloadModeMPU_vTimerSetReloadModepcTimerGetNameMPU_pcTimerGetNamexTimerGetTimerDaemonTaskHandleMPU_xTimerGetTimerDaemonTaskHandlexTimerIsTimerActiveMPU_xTimerIsTimerActivevTimerSetTimerIDMPU_vTimerSetTimerIDpvTimerGetTimerIDMPU_pvTimerGetTimerIDpcQueueGetNameMPU_pcQueueGetNamevQueueUnregisterQueueMPU_vQueueUnregisterQueuevQueueAddToRegistryMPU_vQueueAddToRegistryxQueueGenericResetMPU_xQueueGenericResetxQueueSelectFromSetMPU_xQueueSelectFromSetxQueueRemoveFromSetMPU_xQueueRemoveFromSetxQueueAddToSetMPU_xQueueAddToSetxQueueCreateSetMPU_xQueueCreateSetxQueueGenericCreateStaticMPU_xQueueGenericCreateStaticxQueueGenericCreateMPU_xQueueGenericCreatexQueueGiveMutexRecursiveMPU_xQueueGiveMutexRecursivexQueueTakeMutexRecursiveMPU_xQueueTakeMutexRecursivexQueueGetMutexHolderMPU_xQueueGetMutexHolderxQueueCreateCountingSemaphoreStaticMPU_xQueueCreateCountingSemaphoreStaticxQueueCreateCountingSemaphoreMPU_xQueueCreateCountingSemaphorexQueueCreateMutexStaticMPU_xQueueCreateMutexStaticxQueueCreateMutexMPU_xQueueCreateMutexvQueueDeleteMPU_vQueueDeleteuxQueueSpacesAvailableMPU_uxQueueSpacesAvailableuxQueueMessagesWaitingMPU_uxQueueMessagesWaitingxQueueSemaphoreTakeMPU_xQueueSemaphoreTakexQueuePeekMPU_xQueuePeekxQueueReceiveMPU_xQueueReceivexQueueGenericSendMPU_xQueueGenericSendxTaskGetSchedulerStateMPU_xTaskGetSchedulerStatexTaskCheckForTimeOutMPU_xTaskCheckForTimeOutvTaskSetTimeOutStateMPU_vTaskSetTimeOutStatexTaskGetCurrentTaskHandleMPU_xTaskGetCurrentTaskHandlexTaskCatchUpTicksMPU_xTaskCatchUpTicksulTaskGenericNotifyValueClearMPU_ulTaskGenericNotifyValueClearxTaskGenericNotifyStateClearMPU_xTaskGenericNotifyStateClearulTaskGenericNotifyTakeMPU_ulTaskGenericNotifyTakexTaskGenericNotifyWaitMPU_xTaskGenericNotifyWaitxTaskGenericNotifyMPU_xTaskGenericNotifyulTaskGetIdleRunTimePercentMPU_ulTaskGetIdleRunTimePercentulTaskGetIdleRunTimeCounterMPU_ulTaskGetIdleRunTimeCountervTaskGetRunTimeStatsMPU_vTaskGetRunTimeStatsvTaskListMPU_vTaskListuxTaskGetSystemStateMPU_uxTaskGetSystemStatexTaskGetIdleTaskHandleMPU_xTaskGetIdleTaskHandlexTaskCallApplicationTaskHookMPU_xTaskCallApplicationTaskHookpvTaskGetThreadLocalStoragePointerMPU_pvTaskGetThreadLocalStoragePointervTaskSetThreadLocalStoragePointerMPU_vTaskSetThreadLocalStoragePointerxTaskGetApplicationTaskTagMPU_xTaskGetApplicationTaskTagvTaskSetApplicationTaskTagMPU_vTaskSetApplicationTaskTaguxTaskGetStackHighWaterMark2MPU_uxTaskGetStackHighWaterMark2uxTaskGetStackHighWaterMarkMPU_uxTaskGetStackHighWaterMarkxTaskGetHandleMPU_xTaskGetHandlepcTaskGetNameMPU_pcTaskGetNameuxTaskGetNumberOfTasksMPU_uxTaskGetNumberOfTasksxTaskGetTickCountMPU_xTaskGetTickCountxTaskResumeAllMPU_xTaskResumeAllvTaskSuspendAllMPU_vTaskSuspendAllvTaskResumeMPU_vTaskResumevTaskSuspendMPU_vTaskSuspendvTaskPrioritySetMPU_vTaskPrioritySetvTaskGetInfoMPU_vTaskGetInfoeTaskGetStateMPU_eTaskGetStateuxTaskPriorityGetMPU_uxTaskPriorityGetxTaskAbortDelayMPU_xTaskAbortDelayxTaskDelayUntilMPU_xTaskDelayUntilvTaskDelayMPU_vTaskDelayvTaskDeleteMPU_vTaskDeletexTaskCreateStaticMPU_xTaskCreateStaticxTaskCreateMPU_xTaskCreateMPU_WRAPPERS_H( portUSING_MPU_WRAPPERS == 1 )MPU_WRAPPERS_INCLUDED_FROM_API_FILE( configQUEUE_REGISTRY_SIZE > 0 )/* MPU_WRAPPERS_H *//* portUSING_MPU_WRAPPERS *//* MPU_WRAPPERS_INCLUDED_FROM_API_FILE *//* Ensure API functions go in the privileged execution section. *//* Remove the privileged function macro, but keep the PRIVILEGED_DATA
 * macro so applications can place data in privileged access sections
 * (useful when using statically allocated objects). *//* Map standard message/stream_buffer.h API functions to the MPU
 * equivalents. *//* Map standard event_group.h API functions to the MPU equivalents. *//* Map standard timer.h API functions to the MPU equivalents. *//* Map standard queue.h API functions to the MPU equivalents. *//* Map standard task.h API functions to the MPU equivalents. *//*
 * Map standard (non MPU) API functions to equivalents that start
 * "MPU_".  This will cause the application code to call the MPU_
 * version, which wraps the non-MPU version with privilege promoting
 * then demoting code, so the kernel code always runs will full
 * privileges.
 *//* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
 * included from queue.c or task.c to prevent it from having an effect within
 * those files. *//* This file redefines API functions to be called through a wrapper macro, but
 * only for ports that are using the MPU. */"mpu_wrappers.h""portmacro.h""deprecated_definitions.h"vPortStoreTaskMPUSettingsxMPU_SETTINGS *MPU_SETTINGS *const xMEMORY_REGIONconst xMEMORY_REGION *xMEMORY_REGION *const xMEMORY_REGION *constvPortEndSchedulerxPortStartSchedulerxPortGetMinimumEverFreeHeapSizexPortGetFreeHeapSizevPortInitialiseBlocksvPortFreepvPortCallocpvPortMallocvPortGetHeapStatsHeapStats_t *xHeapStats *vPortDefineHeapRegionsconst HeapRegion_tconst HeapRegion_t *HeapRegion *const HeapRegion_t *constpxPortInitialiseStackHeapStats_txHeapStatsHeapRegion_tHeapRegionxNumberOfSuccessfulFreesxNumberOfSuccessfulAllocationsxMinimumEverFreeBytesRemainingxNumberOfFreeBlocksxSizeOfSmallestFreeBlockInBytesxSizeOfLargestFreeBlockInBytesxAvailableHeapSpaceInBytesxSizeInBytesuint8_t *pucStartAddressvPortFreeStackpvPortMallocStackconfigSTACK_ALLOCATION_FROM_SEPARATE_HEAPportARCH_NAMEportHAS_STACK_OVERFLOW_CHECKINGportBYTE_ALIGNMENT_MASK( 0x0007 )PORTABLE_HportENTER_CRITICALportBYTE_ALIGNMENT == 32portBYTE_ALIGNMENT == 16portBYTE_ALIGNMENT == 8portBYTE_ALIGNMENT == 4portBYTE_ALIGNMENT == 2portBYTE_ALIGNMENT == 1( portHAS_STACK_OVERFLOW_CHECKING == 1 )( configSTACK_ALLOCATION_FROM_SEPARATE_HEAP == 1 )( configUSE_MALLOC_FAILED_HOOK == 1 )xMEMORY_REGION/* PORTABLE_H *//* *INDENT-ON* *//* *INDENT-OFF* *//*
 * The structures and methods of manipulating the MPU are contained within the
 * port layer.
 *
 * Fills the xMPUSettings structure with the memory region information
 * contained in xRegions.
 *//*
 * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
 * the hardware is left in its original condition after the scheduler stops
 * executing.
 *//*
 * Setup the hardware ready for the scheduler to take control.  This generally
 * sets up a tick interrupt and sets timers for the correct tick frequency.
 *//*lint !e526 Symbol not defined as it is an application callback. *//**
 * task.h
 * @code{c}
 * void vApplicationMallocFailedHook( void )
 * @endcode
 *
 * This hook function is called when allocation failed.
 *//*
 * Map to the memory management routines required for the port.
 *//*
 * Returns a HeapStats_t structure filled with information about the current
 * heap state.
 *//*
 * Used to define multiple heap regions for use by heap_5.c.  This function
 * must be called before any calls to pvPortMalloc() - not creating a task,
 * queue, semaphore, mutex, software timer, event group, etc. will result in
 * pvPortMalloc being called.
 *
 * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
 * defines a region of memory that can be used as the heap.  The array is
 * terminated by a HeapRegions_t structure that has a size of 0.  The region
 * with the lowest start address must appear first in the array.
 *//* The number of calls to vPortFree() that has successfully freed a block of memory. *//* The number of calls to pvPortMalloc() that have returned a valid memory block. *//* The minimum amount of total free memory (sum of all free blocks) there has been in the heap since the system booted. *//* The number of free memory blocks within the heap at the time vPortGetHeapStats() is called. *//* The minimum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. *//* The maximum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. *//* The total heap size currently available - this is the sum of all the free blocks, not the largest block that can be allocated. *//* Used to pass information about the heap out of vPortGetHeapStats(). *//* Used by heap_5.c to define the start address and size of each memory region
 * that together comprise the total FreeRTOS heap space. *//* if ( portUSING_MPU_WRAPPERS == 1 ) *//*
 * Setup the stack of a new task so it is ready to be placed under the
 * scheduler control.  The registers have to be placed on the stack in
 * the order that the port expects to find them.
 *
 *//* Defaults to 0 for backward compatibility. *//* if portBYTE_ALIGNMENT == 32 *//* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
 * did not result in a portmacro.h header file being included - and it should be
 * included here.  In this case the path to the correct portmacro.h header file
 * must be set in the compiler's include path. *//* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
 * pre-processor definition was used to ensure the pre-processor found the correct
 * portmacro.h file for the port being used.  That scheme was deprecated in favour
 * of setting the compiler's include path such that it found the correct
 * portmacro.h file - removing the need for the constant and allowing the
 * portmacro.h file to be located anywhere in relation to the port being used.
 * Purely for reasons of backward compatibility the old method is still valid, but
 * to make it clear that new projects should not use it, support for the port
 * specific constants has been moved into the deprecated_definitions.h header
 * file. *//*-----------------------------------------------------------
* Portable layer API.  Each function must be defined for each port.
*----------------------------------------------------------*/xMPUSettingsxRegionspxBottomOfStackulStackDepthpvxNumxSizepxHeapStatspxHeapRegionspxTopOfStackpxCodepvParametersxRunPrivileged"portable.h""projdefs.h""FreeRTOSConfig.h"StaticMessageBuffer_tStaticStreamBuffer_txSTATIC_STREAM_BUFFERStaticTimer_txSTATIC_TIMERStaticEventGroup_txSTATIC_EVENT_GROUPStaticSemaphore_tStaticQueue_txSTATIC_QUEUEStaticTask_txSTATIC_TCBStaticList_txSTATIC_LISTStaticMiniListItem_txSTATIC_MINI_LIST_ITEMStaticListItem_txSTATIC_LIST_ITEMuxDummy4ucDummy3void *[3]pvDummy2size_t[4]unsigned int[4]uxDummy1ucDummy8uxDummy7pvDummy6pvDummy5xDummy3xDummy2pvDummy1ucDummy4uxDummy3xDummy1ucDummy9uxDummy8pvDummy7ucDummy6uint8_t[2]unsigned char[2]ucDummy5UBaseType_t[3]StaticList_t[2]xSTATIC_LIST[2]uuxDummy2ucDummy21uxDummy20uint8_t[1]configTASK_NOTIFICATION_ARRAY_ENTRIESucDummy19ulDummy18ulDummy16void *[1]pvDummy15pxDummy14UBaseType_t[2]uxDummy12uxDummy10uint8_t[10]unsigned char[10]ucDummy7pxDummy6uxDummy5StaticListItem_t[2]xSTATIC_LIST_ITEM[2]pxDummy1xDummy4pvDummy3void *[2]void *[4]tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE( ( ( portUSING_MPU_WRAPPERS == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) || ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) )configRUN_ADDITIONAL_TESTSconfigRUN_FREERTOS_SECURE_ONLYconfigENABLE_TRUSTZONEconfigENABLE_MVEconfigENABLE_FPUconfigENABLE_MPUconfigUSE_TASK_FPU_SUPPORTpxContainerpvContainerxListList_txListItemListItem_tpdTASK_CODEtmrTIMER_CALLBACKTimerCallbackFunction_txTaskGetIdleRunTimeCountervTaskGetTaskInfopcQueueGetQueueNamepcTimerGetTimerNamepcTaskGetTaskNameportTICK_RATE_MSpdTASK_HOOK_CODETaskHookFunction_txCoRoutineHandleCoRoutineHandle_txTimerHandleTimerHandle_txTaskStatusTypeTaskStatus_txTaskParametersTaskParameters_txMemoryRegionMemoryRegion_txTimeOutTypeTimeOut_txQueueSetMemberHandleQueueSetMemberHandle_txQueueSetHandleQueueSetHandle_txSemaphoreHandleSemaphoreHandle_txQueueHandleQueueHandle_txTaskHandleTaskHandle_tportTickTypeeTaskStateGetconfigMIN(a,b)( ( ( a ) < ( b ) ) ? ( a ) : ( b ) )configMAX(a,b)( ( ( a ) > ( b ) ) ? ( a ) : ( b ) )configPRINTF(X)configENABLE_BACKWARD_COMPATIBILITYportTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR(x)( void ) ( x )portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR()portTICK_TYPE_EXIT_CRITICAL()portTICK_TYPE_ENTER_CRITICAL()configINITIAL_TICK_COUNTconfigMESSAGE_BUFFER_LENGTH_TYPEconfigRUN_TIME_COUNTER_TYPEconfigSTACK_DEPTH_TYPEconfigUSE_SB_COMPLETED_CALLBACKconfigUSE_POSIX_ERRNOconfigUSE_TASK_NOTIFICATIONSconfigAPPLICATION_ALLOCATED_HEAPportASSERT_IF_IN_ISR()mtCOVERAGE_TEST_DELAY()mtCOVERAGE_TEST_MARKER()configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONSportALLOCATE_SECURE_CONTEXT(ulSecureStackSize)portTASK_USES_FLOATING_POINT()configPOST_SLEEP_PROCESSING(x)configPRE_SLEEP_PROCESSING(x)configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING(x)configUSE_TICKLESS_IDLEconfigEXPECTED_IDLE_TIME_BEFORE_SLEEPportSUPPRESS_TICKS_AND_SLEEP(xExpectedIdleTime)traceSTREAM_BUFFER_RECEIVE_FROM_ISR(xStreamBuffer,xReceivedLength)traceSTREAM_BUFFER_RECEIVE_FAILED(xStreamBuffer)traceSTREAM_BUFFER_RECEIVE(xStreamBuffer,xReceivedLength)traceBLOCKING_ON_STREAM_BUFFER_RECEIVE(xStreamBuffer)traceSTREAM_BUFFER_SEND_FROM_ISR(xStreamBuffer,xBytesSent)traceSTREAM_BUFFER_SEND_FAILED(xStreamBuffer)traceSTREAM_BUFFER_SEND(xStreamBuffer,xBytesSent)traceBLOCKING_ON_STREAM_BUFFER_SEND(xStreamBuffer)traceSTREAM_BUFFER_RESET(xStreamBuffer)traceSTREAM_BUFFER_DELETE(xStreamBuffer)traceSTREAM_BUFFER_CREATE(pxStreamBuffer,xIsMessageBuffer)traceSTREAM_BUFFER_CREATE_STATIC_FAILED(xReturn,xIsMessageBuffer)traceSTREAM_BUFFER_CREATE_FAILED(xIsMessageBuffer)traceTASK_NOTIFY_GIVE_FROM_ISR(uxIndexToNotify)traceTASK_NOTIFY_FROM_ISR(uxIndexToNotify)traceTASK_NOTIFY(uxIndexToNotify)traceTASK_NOTIFY_WAIT(uxIndexToWait)traceTASK_NOTIFY_WAIT_BLOCK(uxIndexToWait)traceTASK_NOTIFY_TAKE(uxIndexToWait)traceTASK_NOTIFY_TAKE_BLOCK(uxIndexToWait)traceQUEUE_REGISTRY_ADD(xQueue,pcQueueName)tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend,pvParameter1,ulParameter2,ret)tracePEND_FUNC_CALL(xFunctionToPend,pvParameter1,ulParameter2,ret)traceEVENT_GROUP_DELETE(xEventGroup)traceEVENT_GROUP_SET_BITS_FROM_ISR(xEventGroup,uxBitsToSet)traceEVENT_GROUP_SET_BITS(xEventGroup,uxBitsToSet)traceEVENT_GROUP_CLEAR_BITS_FROM_ISR(xEventGroup,uxBitsToClear)traceEVENT_GROUP_CLEAR_BITS(xEventGroup,uxBitsToClear)traceEVENT_GROUP_WAIT_BITS_END(xEventGroup,uxBitsToWaitFor,xTimeoutOccurred)( void ) ( xTimeoutOccurred )traceEVENT_GROUP_WAIT_BITS_BLOCK(xEventGroup,uxBitsToWaitFor)traceEVENT_GROUP_SYNC_END(xEventGroup,uxBitsToSet,uxBitsToWaitFor,xTimeoutOccurred)traceEVENT_GROUP_SYNC_BLOCK(xEventGroup,uxBitsToSet,uxBitsToWaitFor)traceEVENT_GROUP_CREATE_FAILED()traceEVENT_GROUP_CREATE(xEventGroup)traceFREE(pvAddress,uiSize)traceMALLOC(pvAddress,uiSize)traceTIMER_COMMAND_RECEIVED(pxTimer,xMessageID,xMessageValue)traceTIMER_EXPIRED(pxTimer)traceTIMER_COMMAND_SEND(xTimer,xMessageID,xMessageValueValue,xReturn)traceTIMER_CREATE_FAILED()traceTIMER_CREATE(pxNewTimer)traceTASK_INCREMENT_TICK(xTickCount)traceTASK_RESUME_FROM_ISR(pxTaskToResume)traceTASK_RESUME(pxTaskToResume)traceTASK_SUSPEND(pxTaskToSuspend)traceTASK_PRIORITY_SET(pxTask,uxNewPriority)traceTASK_DELAY()traceTASK_DELAY_UNTIL(x)traceTASK_DELETE(pxTaskToDelete)traceTASK_CREATE_FAILED()traceTASK_CREATE(pxNewTCB)traceQUEUE_DELETE(pxQueue)traceQUEUE_PEEK_FROM_ISR_FAILED(pxQueue)traceQUEUE_RECEIVE_FROM_ISR_FAILED(pxQueue)traceQUEUE_RECEIVE_FROM_ISR(pxQueue)traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue)traceQUEUE_SEND_FROM_ISR(pxQueue)traceQUEUE_RECEIVE_FAILED(pxQueue)traceQUEUE_PEEK_FROM_ISR(pxQueue)traceQUEUE_PEEK_FAILED(pxQueue)traceQUEUE_PEEK(pxQueue)traceQUEUE_RECEIVE(pxQueue)traceQUEUE_SEND_FAILED(pxQueue)traceQUEUE_SEND(pxQueue)traceQUEUE_SET_SENDtraceQUEUE_SENDtraceCREATE_COUNTING_SEMAPHORE_FAILED()traceCREATE_COUNTING_SEMAPHORE()traceTAKE_MUTEX_RECURSIVE_FAILED(pxMutex)traceTAKE_MUTEX_RECURSIVE(pxMutex)traceGIVE_MUTEX_RECURSIVE_FAILED(pxMutex)traceGIVE_MUTEX_RECURSIVE(pxMutex)traceCREATE_MUTEX_FAILED()traceCREATE_MUTEX(pxNewQueue)traceQUEUE_CREATE_FAILED(ucQueueType)traceQUEUE_CREATE(pxNewQueue)tracePOST_MOVED_TASK_TO_READY_STATE(pxTCB)traceMOVED_TASK_TO_READY_STATE(pxTCB)configINCLUDE_FREERTOS_TASK_C_ADDITIONS_HconfigRECORD_STACK_HIGH_ADDRESStraceBLOCKING_ON_QUEUE_SEND(pxQueue)traceBLOCKING_ON_QUEUE_PEEK(pxQueue)traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue)traceTASK_PRIORITY_DISINHERIT(pxTCBOfMutexHolder,uxOriginalPriority)traceTASK_PRIORITY_INHERIT(pxTCBOfMutexHolder,uxInheritedPriority)traceTASK_SWITCHED_OUT()traceLOW_POWER_IDLE_END()traceLOW_POWER_IDLE_BEGIN()traceINCREASE_TICK_COUNT(x)traceTASK_SWITCHED_IN()traceEND()traceSTART()portPOINTER_SIZE_TYPEconfigUSE_MINI_LIST_ITEMportSETUP_TCB(pxTCB)( void ) ( pxTCB )portPRE_TASK_DELETE_HOOK(pvTaskToDelete,pxYieldPending)portCLEAN_UP_TCB(pxTCB)portSOFTWARE_BARRIER()configPRECONDITION_DEFINEDconfigPRECONDITION(X)configASSERT( X )portCRITICAL_NESTING_IN_TCBconfigUSE_ALTERNATIVE_APIINCLUDE_xTaskGetCurrentTaskHandleINCLUDE_xTaskResumeFromISRINCLUDE_xQueueGetMutexHolderINCLUDE_xTaskDelayUntilconfigUSE_CO_ROUTINESconfigUSE_C_RUNTIME_TLS_SUPPORTconfigUSE_NEWLIB_REENTRANTINC_FREERTOS_H( configUSE_NEWLIB_REENTRANT == 1 )configTLS_BLOCK_TYPEconfigINIT_TLS_BLOCKconfigSET_TLS_BLOCKconfigDEINIT_TLS_BLOCK( ( configUSE_NEWLIB_REENTRANT == 0 ) && ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) )configMAX_PRIORITIES < 1configUSE_CO_ROUTINES != 0configMAX_CO_ROUTINE_PRIORITIESconfigMAX_TASK_NAME_LEN < 1configPRECONDITIONportMEMORY_BARRIERportSOFTWARE_BARRIERconfigUSE_TIMERS == 1portSET_INTERRUPT_MASK_FROM_ISRportCLEAR_INTERRUPT_MASK_FROM_ISRportCLEAN_UP_TCBportPRE_TASK_DELETE_HOOKportSETUP_TCB( configQUEUE_REGISTRY_SIZE < 1 )traceSTARTtraceENDtraceTASK_SWITCHED_INtraceINCREASE_TICK_COUNTtraceLOW_POWER_IDLE_BEGINtraceLOW_POWER_IDLE_ENDtraceTASK_SWITCHED_OUTtraceTASK_PRIORITY_INHERITtraceTASK_PRIORITY_DISINHERITtraceBLOCKING_ON_QUEUE_RECEIVEtraceBLOCKING_ON_QUEUE_PEEKtraceBLOCKING_ON_QUEUE_SENDtraceMOVED_TASK_TO_READY_STATEtracePOST_MOVED_TASK_TO_READY_STATEtraceQUEUE_CREATEtraceQUEUE_CREATE_FAILEDtraceCREATE_MUTEXtraceCREATE_MUTEX_FAILEDtraceGIVE_MUTEX_RECURSIVEtraceGIVE_MUTEX_RECURSIVE_FAILEDtraceTAKE_MUTEX_RECURSIVEtraceTAKE_MUTEX_RECURSIVE_FAILEDtraceCREATE_COUNTING_SEMAPHOREtraceCREATE_COUNTING_SEMAPHORE_FAILEDtraceQUEUE_SEND_FAILEDtraceQUEUE_RECEIVEtraceQUEUE_PEEKtraceQUEUE_PEEK_FAILEDtraceQUEUE_PEEK_FROM_ISRtraceQUEUE_RECEIVE_FAILEDtraceQUEUE_SEND_FROM_ISRtraceQUEUE_SEND_FROM_ISR_FAILEDtraceQUEUE_RECEIVE_FROM_ISRtraceQUEUE_RECEIVE_FROM_ISR_FAILEDtraceQUEUE_PEEK_FROM_ISR_FAILEDtraceQUEUE_DELETEtraceTASK_CREATEtraceTASK_CREATE_FAILEDtraceTASK_DELETEtraceTASK_DELAY_UNTILtraceTASK_DELAYtraceTASK_PRIORITY_SETtraceTASK_SUSPENDtraceTASK_RESUMEtraceTASK_RESUME_FROM_ISRtraceTASK_INCREMENT_TICKtraceTIMER_CREATEtraceTIMER_CREATE_FAILEDtraceTIMER_COMMAND_SENDtraceTIMER_EXPIREDtraceTIMER_COMMAND_RECEIVEDtraceMALLOCtraceFREEtraceEVENT_GROUP_CREATEtraceEVENT_GROUP_CREATE_FAILEDtraceEVENT_GROUP_SYNC_BLOCKtraceEVENT_GROUP_SYNC_ENDtraceEVENT_GROUP_WAIT_BITS_BLOCKtraceEVENT_GROUP_WAIT_BITS_ENDtraceEVENT_GROUP_CLEAR_BITStraceEVENT_GROUP_CLEAR_BITS_FROM_ISRtraceEVENT_GROUP_SET_BITStraceEVENT_GROUP_SET_BITS_FROM_ISRtraceEVENT_GROUP_DELETEtracePEND_FUNC_CALLtracePEND_FUNC_CALL_FROM_ISRtraceQUEUE_REGISTRY_ADDtraceTASK_NOTIFY_TAKE_BLOCKtraceTASK_NOTIFY_TAKEtraceTASK_NOTIFY_WAIT_BLOCKtraceTASK_NOTIFY_WAITtraceTASK_NOTIFYtraceTASK_NOTIFY_FROM_ISRtraceTASK_NOTIFY_GIVE_FROM_ISRtraceSTREAM_BUFFER_CREATE_FAILEDtraceSTREAM_BUFFER_CREATE_STATIC_FAILEDtraceSTREAM_BUFFER_CREATEtraceSTREAM_BUFFER_DELETEtraceSTREAM_BUFFER_RESETtraceBLOCKING_ON_STREAM_BUFFER_SENDtraceSTREAM_BUFFER_SENDtraceSTREAM_BUFFER_SEND_FAILEDtraceSTREAM_BUFFER_SEND_FROM_ISRtraceBLOCKING_ON_STREAM_BUFFER_RECEIVEtraceSTREAM_BUFFER_RECEIVEtraceSTREAM_BUFFER_RECEIVE_FAILEDtraceSTREAM_BUFFER_RECEIVE_FROM_ISR( configGENERATE_RUN_TIME_STATS == 1 )portCONFIGURE_TIMER_FOR_RUN_TIME_STATSportGET_RUN_TIME_COUNTER_VALUEportALT_GET_RUN_TIME_COUNTER_VALUEportYIELD_WITHIN_APIportSUPPRESS_TICKS_AND_SLEEPconfigEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSINGconfigPRE_SLEEP_PROCESSINGconfigPOST_SLEEP_PROCESSINGportTASK_USES_FLOATING_POINTportALLOCATE_SECURE_CONTEXTportASSERT_IF_INTERRUPT_PRIORITY_INVALIDmtCOVERAGE_TEST_MARKERmtCOVERAGE_TEST_DELAYportASSERT_IF_IN_ISRconfigTASK_NOTIFICATION_ARRAY_ENTRIES < 1( ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION != 1 ) )( configUSE_STATS_FORMATTING_FUNCTIONS > 0 )( ( configUSE_TRACE_FACILITY != 1 ) && ( configGENERATE_RUN_TIME_STATS != 1 ) )( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )( portTICK_TYPE_IS_ATOMIC == 0 )configPRINTFconfigMAXconfigMINconfigENABLE_BACKWARD_COMPATIBILITY == 1( configUSE_ALTERNATIVE_API != 0 )( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 1 )( configUSE_MINI_LIST_ITEM == 1 )( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )( portCRITICAL_NESTING_IN_TCB == 1 )( configUSE_TRACE_FACILITY == 1 )( configUSE_MUTEXES == 1 )( configUSE_APPLICATION_TASK_TAG == 1 )( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) )( configUSE_TASK_NOTIFICATIONS == 1 )( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )( INCLUDE_xTaskAbortDelay == 1 )( configUSE_POSIX_ERRNO == 1 )( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )( configUSE_QUEUE_SETS == 1 )( configUSE_SB_COMPLETED_CALLBACK == 1 )/* INC_FREERTOS_H *//* Message buffers are built on stream buffers. *//*
 * In line with software engineering best practice, especially when supplying a
 * library that is likely to change in future versions, FreeRTOS implements a
 * strict data hiding policy.  This means the stream buffer structure used
 * internally by FreeRTOS is not accessible to application code.  However, if
 * the application writer wants to statically allocate the memory required to
 * create a stream buffer then the size of the stream buffer object needs to be
 * known.  The StaticStreamBuffer_t structure below is provided for this
 * purpose.  Its size and alignment requirements are guaranteed to match those
 * of the genuine structure, no matter which architecture is being used, and
 * no matter how the values in FreeRTOSConfig.h are set.  Its contents are
 * somewhat obfuscated in the hope users will recognise that it would be unwise
 * to make direct use of the structure members.
 *//*
 * In line with software engineering best practice, especially when supplying a
 * library that is likely to change in future versions, FreeRTOS implements a
 * strict data hiding policy.  This means the software timer structure used
 * internally by FreeRTOS is not accessible to application code.  However, if
 * the application writer wants to statically allocate the memory required to
 * create a software timer then the size of the queue object needs to be known.
 * The StaticTimer_t structure below is provided for this purpose.  Its sizes
 * and alignment requirements are guaranteed to match those of the genuine
 * structure, no matter which architecture is being used, and no matter how the
 * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
 * the hope users will recognise that it would be unwise to make direct use of
 * the structure members.
 *//*
 * In line with software engineering best practice, especially when supplying a
 * library that is likely to change in future versions, FreeRTOS implements a
 * strict data hiding policy.  This means the event group structure used
 * internally by FreeRTOS is not accessible to application code.  However, if
 * the application writer wants to statically allocate the memory required to
 * create an event group then the size of the event group object needs to be
 * know.  The StaticEventGroup_t structure below is provided for this purpose.
 * Its sizes and alignment requirements are guaranteed to match those of the
 * genuine structure, no matter which architecture is being used, and no matter
 * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
 * obfuscated in the hope users will recognise that it would be unwise to make
 * direct use of the structure members.
 *//*
 * In line with software engineering best practice, especially when supplying a
 * library that is likely to change in future versions, FreeRTOS implements a
 * strict data hiding policy.  This means the Queue structure used internally by
 * FreeRTOS is not accessible to application code.  However, if the application
 * writer wants to statically allocate the memory required to create a queue
 * then the size of the queue object needs to be known.  The StaticQueue_t
 * structure below is provided for this purpose.  Its sizes and alignment
 * requirements are guaranteed to match those of the genuine structure, no
 * matter which architecture is being used, and no matter how the values in
 * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
 * users will recognise that it would be unwise to make direct use of the
 * structure members.
 *//*
 * In line with software engineering best practice, especially when supplying a
 * library that is likely to change in future versions, FreeRTOS implements a
 * strict data hiding policy.  This means the Task structure used internally by
 * FreeRTOS is not accessible to application code.  However, if the application
 * writer wants to statically allocate the memory required to create a task then
 * the size of the task object needs to be known.  The StaticTask_t structure
 * below is provided for this purpose.  Its sizes and alignment requirements are
 * guaranteed to match those of the genuine structure, no matter which
 * architecture is being used, and no matter how the values in FreeRTOSConfig.h
 * are set.  Its contents are somewhat obfuscated in the hope users will
 * recognise that it would be unwise to make direct use of the structure members.
 *//* See the comments above the struct xSTATIC_LIST_ITEM definition. *//* if ( configUSE_MINI_LIST_ITEM == 1 ) *//*
 * In line with software engineering best practice, FreeRTOS implements a strict
 * data hiding policy, so the real structures used by FreeRTOS to maintain the
 * state of tasks, queues, semaphores, etc. are not accessible to the application
 * code.  However, if the application writer wants to statically allocate such
 * an object then the size of the object needs to be known.  Dummy structures
 * that are guaranteed to have the same size and alignment requirements of the
 * real objects are used for this purpose.  The dummy list and list item
 * structures below are used for inclusion in such a dummy structure.
 *//* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
 * dynamically allocated RAM, in which case when any task is deleted it is known
 * that both the task's stack and TCB need to be freed.  Sometimes the
 * FreeRTOSConfig.h settings only allow a task to be created using statically
 * allocated RAM, in which case when any task is deleted it is known that neither
 * the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
 * settings allow a task to be created using either statically or dynamically
 * allocated RAM, in which case a member of the TCB is used to record whether the
 * stack and/or TCB were allocated statically or dynamically, so when a task is
 * deleted the RAM that was allocated dynamically is freed again and no attempt is
 * made to free the RAM that was allocated statically.
 * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
 * task to be created using either statically or dynamically allocated RAM.  Note
 * that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
 * a statically allocated stack and a dynamically allocated TCB.
 *
 * The following table lists various combinations of portUSING_MPU_WRAPPERS,
 * configSUPPORT_DYNAMIC_ALLOCATION and configSUPPORT_STATIC_ALLOCATION and
 * when it is possible to have both static and dynamic allocation:
 *  +-----+---------+--------+-----------------------------+-----------------------------------+------------------+-----------+
 * | MPU | Dynamic | Static |     Available Functions     |       Possible Allocations        | Both Dynamic and | Need Free |
 * |     |         |        |                             |                                   | Static Possible  |           |
 * +-----+---------+--------+-----------------------------+-----------------------------------+------------------+-----------+
 * | 0   | 0       | 1      | xTaskCreateStatic           | TCB - Static, Stack - Static      | No               | No        |
 * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
 * | 0   | 1       | 0      | xTaskCreate                 | TCB - Dynamic, Stack - Dynamic    | No               | Yes       |
 * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
 * | 0   | 1       | 1      | xTaskCreate,                | 1. TCB - Dynamic, Stack - Dynamic | Yes              | Yes       |
 * |     |         |        | xTaskCreateStatic           | 2. TCB - Static, Stack - Static   |                  |           |
 * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
 * | 1   | 0       | 1      | xTaskCreateStatic,          | TCB - Static, Stack - Static      | No               | No        |
 * |     |         |        | xTaskCreateRestrictedStatic |                                   |                  |           |
 * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
 * | 1   | 1       | 0      | xTaskCreate,                | 1. TCB - Dynamic, Stack - Dynamic | Yes              | Yes       |
 * |     |         |        | xTaskCreateRestricted       | 2. TCB - Dynamic, Stack - Static  |                  |           |
 * +-----|---------|--------|-----------------------------|-----------------------------------|------------------|-----------|
 * | 1   | 1       | 1      | xTaskCreate,                | 1. TCB - Dynamic, Stack - Dynamic | Yes              | Yes       |
 * |     |         |        | xTaskCreateStatic,          | 2. TCB - Dynamic, Stack - Static  |                  |           |
 * |     |         |        | xTaskCreateRestricted,      | 3. TCB - Static, Stack - Static   |                  |           |
 * |     |         |        | xTaskCreateRestrictedStatic |                                   |                  |           |
 * +-----+---------+--------+-----------------------------+-----------------------------------+------------------+-----------+
 *//* Set configRUN_FREERTOS_SECURE_ONLY to 1 to run the FreeRTOS ARMv8M port on
 * the Secure Side only. *//* Set configENABLE_TRUSTZONE to 1 enable TrustZone support and 0 to disable it.
 * This is currently used in ARMv8M ports. *//* Set configENABLE_MVE to 1 to enable MVE support and 0 to disable it. This is
 * currently used in ARMv8M ports. *//* Set configENABLE_FPU to 1 to enable FPU support and 0 to disable it. This is
 * currently used in ARMv8M ports. *//* Set configENABLE_MPU to 1 to enable MPU support and 0 to disable it. This is
 * currently used in ARMv8M ports. *//* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
 * if floating point hardware is otherwise supported by the FreeRTOS port in use.
 * This constant is not supported by all FreeRTOS ports that include floating
 * point support. *//* configENABLE_BACKWARD_COMPATIBILITY *//* For libraries that break the list data hiding, and access list structure
 * members directly (which is not supposed to be done). *//* Backward compatibility within the scheduler code only - these definitions
 * are not really required but are included for completeness. *//* The application writer has not provided their own MIN macro, so define
 * the following generic implementation. *//* The application writer has not provided their own MAX macro, so define
 * the following generic implementation. *//* configPRINTF() was not defined, so define it away to nothing.  To use
 * configPRINTF() then define it as follows (where MyPrintFunction() is
 * provided by the application writer):
 *
 * void MyPrintFunction(const char *pcFormat, ... );
 #define configPRINTF( X )   MyPrintFunction X
 *
 * Then call like a standard printf() function, but placing brackets around
 * all parameters so they are passed as a single parameter.  For example:
 * configPRINTF( ("Value = %d", MyVariable) ); *//* Definitions to allow backward compatibility with FreeRTOS versions prior to
 * V8 if desired. *//* if ( portTICK_TYPE_IS_ATOMIC == 0 ) *//* The tick type can be read atomically, so critical sections used when the
 * tick count is returned can be defined away. *//* Either variables of tick type cannot be read atomically, or
 * portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
 * the tick count is returned to the standard critical section macros. *//* Sanity check the configuration. *//* Defaults to size_t for backward compatibility, but can be overridden
 * in FreeRTOSConfig.h if lengths will always be less than the number of bytes
 * in a size_t. *//* Defaults to uint32_t for backward compatibility, but can be overridden in
 * FreeRTOSConfig.h if uint32_t is too restrictive. *//* Defaults to uint16_t for backward compatibility, but can be overridden
 * in FreeRTOSConfig.h if uint16_t is too restrictive. *//* Defaults to 1 for backward compatibility. *//* By default per-instance callbacks are not enabled for stream buffer or message buffer. *//* configGENERATE_RUN_TIME_STATS *//* portGET_RUN_TIME_COUNTER_VALUE *//* portALT_GET_RUN_TIME_COUNTER_VALUE *//* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS *//* The following event macros are embedded in the kernel API calls. *//* Task is about to block because it cannot write to a
 * queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
 * upon which the write was attempted.  pxCurrentTCB points to the TCB of the
 * task that attempted the write. *//* Task is about to block because it cannot read from a
 * queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
 * upon which the read was attempted.  pxCurrentTCB points to the TCB of the
 * task that attempted the read. *//* Called when a task releases a mutex, the holding of which had resulted in
 * the task inheriting the priority of a higher priority task.
 * pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
 * mutex.  uxOriginalPriority is the task's configured (base) priority. *//* Called when a task attempts to take a mutex that is already held by a
 * lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
 * that holds the mutex.  uxInheritedPriority is the priority the mutex holder
 * will inherit (the priority of the task that is attempting to obtain the
 * muted. *//* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
 * to the task control block of the task being switched out. *//* Called when returning to the Idle task after a tickless idle. *//* Called immediately before entering tickless idle. *//* Called before stepping the tick count after waking from tickless idle
 * sleep. *//* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
 * to the task control block of the selected task. *//* Use to close a trace, for example close a file into which trace has been
 * written. *//* Used to perform any necessary initialisation - for example, open a file
 * into which trace is to be written. *//* Remove any unused trace macros. *//* configUSE_TIMERS *//* configTIMER_TASK_STACK_DEPTH *//* configTIMER_QUEUE_LENGTH *//* configTIMER_TASK_PRIORITY *//* The timers module relies on xTaskGetSchedulerState(). *//* configPRECONDITION should be defined as configASSERT.
 * The CBMC proofs need a way to track assumptions and assertions.
 * A configPRECONDITION statement should express an implicit invariant or
 * assumption made.  A configASSERT statement should express an invariant that must
 * hold explicit before calling the code. *//* If INCLUDE_vTaskDelayUntil is set but INCLUDE_xTaskDelayUntil is not then
 * the project's FreeRTOSConfig.h probably pre-dates the introduction of
 * xTaskDelayUntil and setting INCLUDE_xTaskDelayUntil to whatever
 * INCLUDE_vTaskDelayUntil is set to will ensure backward compatibility.
 *//* INCLUDE_vTaskDelayUntil was replaced by INCLUDE_xTaskDelayUntil.  Backward
 * compatibility is maintained if only one or the other is defined, but
 * there is a conflict if both are defined. *//*
 * Check all the required application specific macros have been defined.
 * These macros are application specific and (as downloaded) are defined
 * within FreeRTOSConfig.h.
 *//* if ( ( configUSE_NEWLIB_REENTRANT == 0 ) && ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) ) *//* if ( configUSE_NEWLIB_REENTRANT == 1 ) *//* Note Newlib support has been included by popular demand, but is not
 * used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 * responsible for resulting newlib operation.  User must be familiar with
 * newlib and must provide system-wide implementations of the necessary
 * stubs. Be warned that (at the time of writing) the current newlib design
 * implements a system-wide malloc() that must be provided with locks.
 *
 * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 * for additional information. *//* Required if struct _reent is used. *//* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. *//* Definitions specific to the port being used. *//* Basic FreeRTOS definitions. *//* Application specific configuration options. *//* READ COMMENT ABOVE. *//*
 * If stdint.h cannot be located then:
 *   + If using GCC ensure the -nostdint options is *not* being used.
 *   + Ensure the project's include path includes the directory in which your
 *     compiler stores stdint.h.
 *   + Set any compiler options necessary for it to support C99, as technically
 *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
 *     other way).
 *   + The FreeRTOS download includes a simple stdint.h definition that can be
 *     used in cases where none is provided by the compiler.  The files only
 *     contains the typedefs required to build FreeRTOS.  Read the instructions
 *     in FreeRTOS/source/stdint.readme for more information.
 *//*
 * Include the generic headers required for the FreeRTOS port being used.
 */uxListRemoveListItem_t *xLIST_ITEM *ListItem_t *constvListInsertEndList_t *xLIST *List_t *constvListInsertvListInitialiseItemvListInitialisexLIST_ITEMxLISTMiniListItem_txMINI_LIST_ITEMxListEndpxPreviouspxNextxItemValuepxIndexvolatile UBaseType_tuxNumberOfItemspvOwnerlistLIST_IS_INITIALISED(pxList)( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )listLIST_ITEM_CONTAINER(pxListItem)( ( pxListItem )->pxContainer )listIS_CONTAINED_WITHIN(pxList,pxListItem)( ( ( pxListItem )->pxContainer == ( pxList ) ) ? ( pdTRUE ) : ( pdFALSE ) )listGET_OWNER_OF_HEAD_ENTRY(pxList)( ( &( ( pxList )->xListEnd ) )->pxNext->pvOwner )listINSERT_END(pxList,pxNewListItem){ ListItem_t * const pxIndex = ( pxList )->pxIndex; listTEST_LIST_INTEGRITY( ( pxList ) ); listTEST_LIST_ITEM_INTEGRITY( ( pxNewListItem ) ); ( pxNewListItem )->pxNext = pxIndex; ( pxNewListItem )->pxPrevious = pxIndex->pxPrevious; pxIndex->pxPrevious->pxNext = ( pxNewListItem ); pxIndex->pxPrevious = ( pxNewListItem ); ( pxNewListItem )->pxContainer = ( pxList ); ( ( pxList )->uxNumberOfItems )++; }listREMOVE_ITEM(pxItemToRemove){ List_t * const pxList = ( pxItemToRemove )->pxContainer; ( pxItemToRemove )->pxNext->pxPrevious = ( pxItemToRemove )->pxPrevious; ( pxItemToRemove )->pxPrevious->pxNext = ( pxItemToRemove )->pxNext; if( pxList->pxIndex == ( pxItemToRemove ) ) { pxList->pxIndex = ( pxItemToRemove )->pxPrevious; } ( pxItemToRemove )->pxContainer = NULL; ( pxList->uxNumberOfItems )--; }listGET_OWNER_OF_NEXT_ENTRY(pxTCB,pxList){ List_t * const pxConstList = ( pxList ); ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext; if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) ) { ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext; } ( pxTCB ) = ( pxConstList )->pxIndex->pvOwner; }listCURRENT_LIST_LENGTH(pxList)( ( pxList )->uxNumberOfItems )listLIST_IS_EMPTY(pxList)( ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) ? pdTRUE : pdFALSE )listGET_END_MARKER(pxList)( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )listGET_NEXT(pxListItem)( ( pxListItem )->pxNext )listGET_HEAD_ENTRY(pxList)( ( ( pxList )->xListEnd ).pxNext )listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxList)( ( ( pxList )->xListEnd ).pxNext->xItemValue )listGET_LIST_ITEM_VALUE(pxListItem)( ( pxListItem )->xItemValue )listSET_LIST_ITEM_VALUE(pxListItem,xValue)( ( pxListItem )->xItemValue = ( xValue ) )listGET_LIST_ITEM_OWNER(pxListItem)( ( pxListItem )->pvOwner )listSET_LIST_ITEM_OWNER(pxListItem,pxOwner)( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )listTEST_LIST_INTEGRITY(pxList)listTEST_LIST_ITEM_INTEGRITY(pxItem)listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList)listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList)listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem)listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem)listSECOND_LIST_INTEGRITY_CHECK_VALUElistFIRST_LIST_INTEGRITY_CHECK_VALUElistSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUElistFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUEconfigLIST_VOLATILELIST_H( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )/* ifndef LIST_H *//*
 * Remove an item from a list.  The list item has a pointer to the list that
 * it is in, so only the list item need be passed into the function.
 *
 * @param uxListRemove The item to be removed.  The item will remove itself from
 * the list pointed to by it's pxContainer parameter.
 *
 * @return The number of items that remain in the list after the list item has
 * been removed.
 *
 * \page uxListRemove uxListRemove
 * \ingroup LinkedList
 *//*
 * Insert a list item into a list.  The item will be inserted in a position
 * such that it will be the last item within the list returned by multiple
 * calls to listGET_OWNER_OF_NEXT_ENTRY.
 *
 * The list member pxIndex is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
 * Placing an item in a list using vListInsertEnd effectively places the item
 * in the list position pointed to by pxIndex.  This means that every other
 * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
 * the pxIndex parameter again points to the item being inserted.
 *
 * @param pxList The list into which the item is to be inserted.
 *
 * @param pxNewListItem The list item to be inserted into the list.
 *
 * \page vListInsertEnd vListInsertEnd
 * \ingroup LinkedList
 *//*
 * Insert a list item into a list.  The item will be inserted into the list in
 * a position determined by its item value (ascending item value order).
 *
 * @param pxList The list into which the item is to be inserted.
 *
 * @param pxNewListItem The item that is to be placed in the list.
 *
 * \page vListInsert vListInsert
 * \ingroup LinkedList
 *//*
 * Must be called before a list item is used.  This sets the list container to
 * null so the item does not think that it is already contained in a list.
 *
 * @param pxItem Pointer to the list item being initialised.
 *
 * \page vListInitialiseItem vListInitialiseItem
 * \ingroup LinkedList
 *//*
 * Must be called before a list is used!  This initialises all the members
 * of the list structure and inserts the xListEnd item into the list as a
 * marker to the back of the list.
 *
 * @param pxList Pointer to the list being initialised.
 *
 * \page vListInitialise vListInitialise
 * \ingroup LinkedList
 *//*
 * This provides a crude means of knowing if a list has been initialised, as
 * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
 * function.
 *//*
 * Return the list a list item is contained within (referenced from).
 *
 * @param pxListItem The list item being queried.
 * @return A pointer to the List_t object that references the pxListItem
 *//*
 * Check to see if a list item is within a list.  The list item maintains a
 * "container" pointer that points to the list it is in.  All this macro does
 * is check to see if the container and the list match.
 *
 * @param pxList The list we want to know if the list item is within.
 * @param pxListItem The list item we want to know if is in the list.
 * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
 *//*
 * Access function to obtain the owner of the first entry in a list.  Lists
 * are normally sorted in ascending item value order.
 *
 * This function returns the pxOwner member of the first item in the list.
 * The pxOwner parameter of a list item is a pointer to the object that owns
 * the list item.  In the scheduler this is normally a task control block.
 * The pxOwner parameter effectively creates a two way link between the list
 * item and its owner.
 *
 * @param pxList The list from which the owner of the head item is to be
 * returned.
 *
 * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
 * \ingroup LinkedList
 *//* Remember which list the item is in. *//* Insert a new list item into ( pxList ), but rather than sort the list, \
         * makes the new list item the last item to be removed by a call to \
         * listGET_OWNER_OF_NEXT_ENTRY(). *//* Only effective when configASSERT() is also defined, these tests may catch \
         * the list data structures being overwritten in memory.  They will not catch \
         * data errors caused by incorrect configuration or use of FreeRTOS. *//*
 * Inline version of vListInsertEnd() to provide slight optimisation for
 * xTaskIncrementTick().
 *
 * Insert a list item into a list.  The item will be inserted in a position
 * such that it will be the last item within the list returned by multiple
 * calls to listGET_OWNER_OF_NEXT_ENTRY.
 *
 * The list member pxIndex is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
 * Placing an item in a list using vListInsertEnd effectively places the item
 * in the list position pointed to by pxIndex.  This means that every other
 * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
 * the pxIndex parameter again points to the item being inserted.
 *
 * @param pxList The list into which the item is to be inserted.
 *
 * @param pxNewListItem The list item to be inserted into the list.
 *
 * \page listINSERT_END listINSERT_END
 * \ingroup LinkedList
 *//* Make sure the index is left pointing to a valid item. *//* The list item knows which list it is in.  Obtain the list from the list \
         * item. *//*
 * Version of uxListRemove() that does not return a value.  Provided as a slight
 * optimisation for xTaskIncrementTick() by being inline.
 *
 * Remove an item from a list.  The list item has a pointer to the list that
 * it is in, so only the list item need be passed into the function.
 *
 * @param uxListRemove The item to be removed.  The item will remove itself from
 * the list pointed to by it's pxContainer parameter.
 *
 * @return The number of items that remain in the list after the list item has
 * been removed.
 *
 * \page listREMOVE_ITEM listREMOVE_ITEM
 * \ingroup LinkedList
 *//* we don't return the marker used at the end of the list.  *//* Increment the index to the next item and return the item, ensuring *//*
 * Access function to obtain the owner of the next entry in a list.
 *
 * The list member pxIndex is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
 * and returns that entry's pxOwner parameter.  Using multiple calls to this
 * function it is therefore possible to move through every item contained in
 * a list.
 *
 * The pxOwner parameter of a list item is a pointer to the object that owns
 * the list item.  In the scheduler this is normally a task control block.
 * The pxOwner parameter effectively creates a two way link between the list
 * item and its owner.
 *
 * @param pxTCB pxTCB is set to the address of the owner of the next list item.
 * @param pxList The list from which the next item owner is to be returned.
 *
 * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
 * \ingroup LinkedList
 *//*
 * Access macro to return the number of items in the list.
 *//*
 * Access macro to determine if a list contains any items.  The macro will
 * only have the value true if the list is empty.
 *
 * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
 * \ingroup LinkedList
 *//*
 * Return the list item that marks the end of the list
 *
 * \page listGET_END_MARKER listGET_END_MARKER
 * \ingroup LinkedList
 *//*
 * Return the next list item.
 *
 * \page listGET_NEXT listGET_NEXT
 * \ingroup LinkedList
 *//*
 * Return the list item at the head of the list.
 *
 * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
 * \ingroup LinkedList
 *//*
 * Access macro to retrieve the value of the list item at the head of a given
 * list.
 *
 * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
 * \ingroup LinkedList
 *//*
 * Access macro to retrieve the value of the list item.  The value can
 * represent anything - for example the priority of a task, or the time at
 * which a task should be unblocked.
 *
 * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
 * \ingroup LinkedList
 *//*
 * Access macro to set the value of the list item.  In most cases the value is
 * used to sort the list in ascending order.
 *
 * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
 * \ingroup LinkedList
 *//*
 * Access macro to get the owner of a list item.  The owner of a list item
 * is the object (usually a TCB) that contains the list item.
 *
 * \page listGET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
 * \ingroup LinkedList
 *//*
 * Access macro to set the owner of a list item.  The owner of a list item
 * is the object (usually a TCB) that contains the list item.
 *
 * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
 * \ingroup LinkedList
 *//*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. *//*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. *//*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). *//*
 * Definition of the type of queue used by the scheduler.
 *//* For some reason lint wants this as two separate definitions. *//*< Pointer to the list in which this list item is placed (if any). *//*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. *//*< Pointer to the previous ListItem_t in the list. *//*< Pointer to the next ListItem_t in the list. *//*< The value being listed.  In most cases this is used to sort the list in ascending order. *//*
 * Definition of the only type of object that a list can contain.
 *//* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES *//* Define macros that will assert if one of the structure members does not
 * contain its expected value. *//* Define macros that set the new structure members to known values. *//* Define macros that add new members into the list structures. *//* if ( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 ) *//* Define the macros to do nothing. *//* Macros that can be used to place known values within the list structures,
 * then check that the known values do not get corrupted during the execution of
 * the application.   These may catch the list data structures being overwritten in
 * memory.  They will not catch data errors caused by incorrect configuration or
 * use of FreeRTOS.*//* configSUPPORT_CROSS_MODULE_OPTIMISATION *//*
 * The list structure members are modified from within interrupts, and therefore
 * by rights should be declared volatile.  However, they are only modified in a
 * functionally atomic way (within critical sections of with the scheduler
 * suspended) and are either passed by reference into a function or indexed via
 * a volatile variable.  Therefore, in all use cases tested so far, the volatile
 * qualifier can be omitted in order to provide a moderate performance
 * improvement without adversely affecting functional behaviour.  The assembly
 * instructions generated by the IAR, ARM and GCC compilers when the respective
 * compiler's options were set for maximum optimisation has been inspected and
 * deemed to be as intended.  That said, as compiler technology advances, and
 * especially if aggressive cross module optimisation is used (a use case that
 * has not been exercised to any great extend) then it is feasible that the
 * volatile qualifier will be needed for correct optimisation.  It is expected
 * that a compiler removing essential code because, without the volatile
 * qualifier on the list structure members and with aggressive cross module
 * optimisation, the compiler deemed the code unnecessary will result in
 * complete and obvious failure of the scheduler.  If this is ever experienced
 * then the volatile qualifier can be inserted in the relevant places within the
 * list structures by simply defining configLIST_VOLATILE to volatile in
 * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
 * If configLIST_VOLATILE is not defined then the preprocessor directives below
 * will simply #define configLIST_VOLATILE away completely.
 *
 * To use volatile list structure members then add the following line to
 * FreeRTOSConfig.h (without the quotes):
 * "#define configLIST_VOLATILE volatile"
 *//*
 * This is the list implementation used by the scheduler.  While it is tailored
 * heavily for the schedulers needs, it is also available for use by
 * application code.
 *
 * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
 * numeric value (xItemValue).  Most of the time the lists are sorted in
 * ascending item value order.
 *
 * Lists are created already containing one list item.  The value of this
 * item is the maximum possible that can be stored, it is therefore always at
 * the end of the list and acts as a marker.  The list member pxHead always
 * points to this marker - even though it is at the tail of the list.  This
 * is because the tail contains a wrap back pointer to the true head of
 * the list.
 *
 * In addition to it's value, each list item contains a pointer to the next
 * item in the list (pxNext), a pointer to the list it is in (pxContainer)
 * and a pointer to back to the object that contains it.  These later two
 * pointers are included for efficiency of list manipulation.  There is
 * effectively a two way link between the object containing the list item and
 * the list item itself.
 *
 *
 * \page ListIntroduction List Implementation
 * \ingroup FreeRTOSIntro
 */pxItemToRemovepxListpxNewListItempxItem"list.h"vTaskInternalSetTimeOutStateTimeOut_t *xTIME_OUT *TimeOut_t *constpvTaskIncrementMutexHeldCounteTaskConfirmSleepModeStatusvTaskStepTickvTaskSetTaskNumberconst UBaseType_tuxTaskGetTaskNumbervTaskPriorityDisinheritAfterTimeoutconst TaskHandle_ttskTaskControlBlock *xTaskPriorityDisinheritxTaskPriorityInheritvTaskMissedYielduxTaskResetEventItemValuevTaskSwitchContextvTaskRemoveFromUnorderedEventListconst TickType_txTaskRemoveFromEventListconst List_tconst List_t *const List_t *constvTaskPlaceOnEventListRestrictedconst BaseType_tvTaskPlaceOnUnorderedEventListvTaskPlaceOnEventListxTaskIncrementTickTickType_t *TickType_t *constvTaskGenericNotifyGiveFromISRBaseType_t *xTaskGenericNotifyFromISRTaskStatus_t *xTASK_STATUS *TaskStatus_t *constxTaskGetApplicationTaskTagFromISRxTaskGetTickCountFromISRvTaskEndSchedulervTaskStartSchedulerxTaskResumeFromISRuxTaskPriorityGetFromISRvTaskAllocateMPURegionsconst MemoryRegion_tconst MemoryRegion_t *const MemoryRegion_t *constxTaskCreateRestrictedStaticconst TaskParameters_tconst TaskParameters_t *xTASK_PARAMETERS *const TaskParameters_t *constTaskHandle_t *tskTaskControlBlock **xTaskCreateRestrictedconst char *constvoid *constStackType_t *constStaticTask_t *constconst uint16_tTaskHandle_t *consteSleepModeStatus(unnamed enum)eAbortSleepeStandardSleepeNoTasksWaitingTimeoutxTASK_STATUSxTASK_PARAMETERSxTIME_OUTeNotifyActioneNoActioneSetBitseIncrementeSetValueWithOverwriteeSetValueWithoutOverwriteeTaskStateeRunningeReadyeBlockedeSuspendedeDeletedeInvalidtskTaskControlBlockusStackHighWaterMarkpxStackBaseulRunTimeCounteruxBasePriorityuxCurrentPriorityeCurrentStatexTaskNumberxHandlepxTaskBufferMemoryRegion_t[3]xMEMORY_REGION[3]puxStackBufferuxPriorityusStackDepthpcNamepvTaskCodeulParametersulLengthInBytespvBaseAddressxTimeOnEnteringxOverflowCountulTaskNotifyValueClearIndexed(xTask,uxIndexToClear,ulBitsToClear)ulTaskGenericNotifyValueClear( ( xTask ), ( uxIndexToClear ), ( ulBitsToClear ) )ulTaskNotifyValueClear(xTask,ulBitsToClear)ulTaskGenericNotifyValueClear( ( xTask ), ( tskDEFAULT_INDEX_TO_NOTIFY ), ( ulBitsToClear ) )xTaskNotifyStateClearIndexed(xTask,uxIndexToClear)xTaskGenericNotifyStateClear( ( xTask ), ( uxIndexToClear ) )xTaskNotifyStateClear(xTask)xTaskGenericNotifyStateClear( ( xTask ), ( tskDEFAULT_INDEX_TO_NOTIFY ) )ulTaskNotifyTakeIndexed(uxIndexToWaitOn,xClearCountOnExit,xTicksToWait)ulTaskGenericNotifyTake( ( uxIndexToWaitOn ), ( xClearCountOnExit ), ( xTicksToWait ) )ulTaskNotifyTake(xClearCountOnExit,xTicksToWait)ulTaskGenericNotifyTake( ( tskDEFAULT_INDEX_TO_NOTIFY ), ( xClearCountOnExit ), ( xTicksToWait ) )vTaskNotifyGiveIndexedFromISR(xTaskToNotify,uxIndexToNotify,pxHigherPriorityTaskWoken)vTaskGenericNotifyGiveFromISR( ( xTaskToNotify ), ( uxIndexToNotify ), ( pxHigherPriorityTaskWoken ) )vTaskNotifyGiveFromISR(xTaskToNotify,pxHigherPriorityTaskWoken)vTaskGenericNotifyGiveFromISR( ( xTaskToNotify ), ( tskDEFAULT_INDEX_TO_NOTIFY ), ( pxHigherPriorityTaskWoken ) )xTaskNotifyGiveIndexed(xTaskToNotify,uxIndexToNotify)xTaskGenericNotify( ( xTaskToNotify ), ( uxIndexToNotify ), ( 0 ), eIncrement, NULL )xTaskNotifyGive(xTaskToNotify)xTaskGenericNotify( ( xTaskToNotify ), ( tskDEFAULT_INDEX_TO_NOTIFY ), ( 0 ), eIncrement, NULL )xTaskNotifyWaitIndexed(uxIndexToWaitOn,ulBitsToClearOnEntry,ulBitsToClearOnExit,pulNotificationValue,xTicksToWait)xTaskGenericNotifyWait( ( uxIndexToWaitOn ), ( ulBitsToClearOnEntry ), ( ulBitsToClearOnExit ), ( pulNotificationValue ), ( xTicksToWait ) )xTaskNotifyWait(ulBitsToClearOnEntry,ulBitsToClearOnExit,pulNotificationValue,xTicksToWait)xTaskGenericNotifyWait( tskDEFAULT_INDEX_TO_NOTIFY, ( ulBitsToClearOnEntry ), ( ulBitsToClearOnExit ), ( pulNotificationValue ), ( xTicksToWait ) )xTaskNotifyAndQueryFromISR(xTaskToNotify,ulValue,eAction,pulPreviousNotificationValue,pxHigherPriorityTaskWoken)xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( tskDEFAULT_INDEX_TO_NOTIFY ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )xTaskNotifyAndQueryIndexedFromISR(xTaskToNotify,uxIndexToNotify,ulValue,eAction,pulPreviousNotificationValue,pxHigherPriorityTaskWoken)xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( uxIndexToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )xTaskNotifyIndexedFromISR(xTaskToNotify,uxIndexToNotify,ulValue,eAction,pxHigherPriorityTaskWoken)xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( uxIndexToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )xTaskNotifyFromISR(xTaskToNotify,ulValue,eAction,pxHigherPriorityTaskWoken)xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( tskDEFAULT_INDEX_TO_NOTIFY ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )xTaskNotifyAndQueryIndexed(xTaskToNotify,uxIndexToNotify,ulValue,eAction,pulPreviousNotifyValue)xTaskGenericNotify( ( xTaskToNotify ), ( uxIndexToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )xTaskNotifyAndQuery(xTaskToNotify,ulValue,eAction,pulPreviousNotifyValue)xTaskGenericNotify( ( xTaskToNotify ), ( tskDEFAULT_INDEX_TO_NOTIFY ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )xTaskNotifyIndexed(xTaskToNotify,uxIndexToNotify,ulValue,eAction)xTaskGenericNotify( ( xTaskToNotify ), ( uxIndexToNotify ), ( ulValue ), ( eAction ), NULL )xTaskNotify(xTaskToNotify,ulValue,eAction)xTaskGenericNotify( ( xTaskToNotify ), ( tskDEFAULT_INDEX_TO_NOTIFY ), ( ulValue ), ( eAction ), NULL )vTaskDelayUntil(pxPreviousWakeTime,xTimeIncrement)do { ( void ) xTaskDelayUntil( ( pxPreviousWakeTime ), ( xTimeIncrement ) ); } while( 0 )taskSCHEDULER_RUNNING( ( BaseType_t ) 2 )taskSCHEDULER_NOT_STARTEDtaskSCHEDULER_SUSPENDEDtaskENABLE_INTERRUPTS()taskDISABLE_INTERRUPTS()taskEXIT_CRITICAL_FROM_ISR(x)portCLEAR_INTERRUPT_MASK_FROM_ISR( x )taskEXIT_CRITICAL()taskENTER_CRITICAL_FROM_ISR()taskENTER_CRITICAL()taskYIELD()tskIDLE_PRIORITY( ( UBaseType_t ) 0U )tskDEFAULT_INDEX_TO_NOTIFY( 0 )tskMPU_REGION_DEVICE_MEMORY( 1UL << 4UL )tskMPU_REGION_NORMAL_MEMORY( 1UL << 3UL )tskMPU_REGION_EXECUTE_NEVER( 1UL << 2UL )tskMPU_REGION_READ_WRITE( 1UL << 1UL )tskMPU_REGION_READ_ONLY( 1UL << 0UL )tskKERNEL_VERSION_BUILDtskKERNEL_VERSION_MINORtskKERNEL_VERSION_MAJORtskKERNEL_VERSION_NUMBER"V10.5.1"INC_TASK_H( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )( ( portSTACK_GROWTH > 0 ) && ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )( INCLUDE_vTaskSuspend == 1 )( configSUPPORT_DYNAMIC_ALLOCATION == 1 )( configSUPPORT_STATIC_ALLOCATION == 1 )configUSE_APPLICATION_TASK_TAG == 1( configCHECK_FOR_STACK_OVERFLOW > 0 )( configUSE_TICK_HOOK > 0 )usedvApplicationTickHook/* INC_TASK_H *//*
 * For internal use only.  Same as vTaskSetTimeOutState(), but without a critical
 * section.
 *//*
 * For internal use only.  Increment the mutex held count when a mutex is
 * taken and return the handle of the task that has taken the mutex.
 *//*
 * Only available when configUSE_TICKLESS_IDLE is set to 1.
 * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
 * specific sleep function to determine if it is ok to proceed with the sleep,
 * and if it is ok to proceed, if it is ok to sleep indefinitely.
 *
 * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
 * called with the scheduler suspended, not from within a critical section.  It
 * is therefore possible for an interrupt to request a context switch between
 * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
 * entered.  eTaskConfirmSleepModeStatus() should be called from a short
 * critical section between the timer being stopped and the sleep mode being
 * entered to ensure it is ok to proceed into the sleep mode.
 *//*
 * Only available when configUSE_TICKLESS_IDLE is set to 1.
 * If tickless mode is being used, or a low power mode is implemented, then
 * the tick interrupt will not execute during idle periods.  When this is the
 * case, the tick count value maintained by the scheduler needs to be kept up
 * to date with the actual execution time by being skipped forward by a time
 * equal to the idle period.
 *//*
 * Set the uxTaskNumber of the task referenced by the xTask parameter to
 * uxHandle.
 *//*
 * Get the uxTaskNumber assigned to the task referenced by the xTask parameter.
 *//*
 * If a higher priority task attempting to obtain a mutex caused a lower
 * priority task to inherit the higher priority task's priority - but the higher
 * priority task then timed out without obtaining the mutex, then the lower
 * priority task will disinherit the priority again - but only down as far as
 * the highest priority task that is still waiting for the mutex (if there were
 * more than one task waiting for the mutex).
 *//*
 * Set the priority of a task back to its proper priority in the case that it
 * inherited a higher priority while it was holding a semaphore.
 *//*
 * Raises the priority of the mutex holder to that of the calling task should
 * the mutex holder have a priority less than the calling task.
 *//*
 * Returns the scheduler state as taskSCHEDULER_RUNNING,
 * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
 *//*
 * Shortcut used by the queue implementation to prevent unnecessary call to
 * taskYIELD();
 *//*
 * Return the handle of the calling task.
 *//*
 * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
 * THE EVENT BITS MODULE.
 *//*
 * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
 * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
 * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
 *
 * Sets the pointer to the current TCB to the TCB of the highest priority task
 * that is ready to run.
 *//*
 * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
 * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
 *
 * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
 *
 * Removes a task from both the specified event list and the list of blocked
 * tasks, and places it on a ready queue.
 *
 * xTaskRemoveFromEventList()/vTaskRemoveFromUnorderedEventList() will be called
 * if either an event occurs to unblock a task, or the block timeout period
 * expires.
 *
 * xTaskRemoveFromEventList() is used when the event list is in task priority
 * order.  It removes the list item from the head of the event list as that will
 * have the highest priority owning task of all the tasks on the event list.
 * vTaskRemoveFromUnorderedEventList() is used when the event list is not
 * ordered and the event list items hold something other than the owning tasks
 * priority.  In this case the event list item value is updated to the value
 * passed in the xItemValue parameter.
 *
 * @return pdTRUE if the task being removed has a higher priority than the task
 * making the call, otherwise pdFALSE.
 *//*
 * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
 * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
 *
 * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
 *
 * This function performs nearly the same function as vTaskPlaceOnEventList().
 * The difference being that this function does not permit tasks to block
 * indefinitely, whereas vTaskPlaceOnEventList() does.
 *
 *//*
 * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
 * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
 *
 * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
 *
 * Removes the calling task from the ready list and places it both
 * on the list of tasks waiting for a particular event, and the
 * list of delayed tasks.  The task will be removed from both lists
 * and replaced on the ready list should either the event occur (and
 * there be no higher priority tasks waiting on the same event) or
 * the delay period expires.
 *
 * The 'unordered' version replaces the event list item value with the
 * xItemValue value, and inserts the list item at the end of the list.
 *
 * The 'ordered' version uses the existing event list item value (which is the
 * owning task's priority) to insert the list item into the event list in task
 * priority order.
 *
 * @param pxEventList The list containing tasks that are blocked waiting
 * for the event to occur.
 *
 * @param xItemValue The item value to use for the event list item when the
 * event list is not ordered by task priority.
 *
 * @param xTicksToWait The maximum amount of time that the task should wait
 * for the event to occur.  This is specified in kernel ticks, the constant
 * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
 * period.
 *//*
 * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
 * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
 * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
 *
 * Called from the real time kernel tick (either preemptive or cooperative),
 * this increments the tick count and checks if any tasks that are blocked
 * for a finite period required removing from a blocked list and placing on
 * a ready list.  If a non-zero value is returned then a context switch is
 * required because either:
 *   + A task was removed from a blocked list because its timeout had expired,
 *     or
 *   + Time slicing is in use and there is a task of equal priority to the
 *     currently running task.
 *//*-----------------------------------------------------------
* SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
*----------------------------------------------------------*//**
 * task.h
 * @code{c}
 * BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp );
 * @endcode
 *
 * This function corrects the tick count value after the application code has held
 * interrupts disabled for an extended period resulting in tick interrupts having
 * been missed.
 *
 * This function is similar to vTaskStepTick(), however, unlike
 * vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a
 * time at which a task should be removed from the blocked state.  That means
 * tasks may have to be removed from the blocked state as the tick count is
 * moved.
 *
 * @param xTicksToCatchUp The number of tick interrupts that have been missed due to
 * interrupts being disabled.  Its value is not computed automatically, so must be
 * computed by the application writer.
 *
 * @return pdTRUE if moving the tick count forward resulted in a task leaving the
 * blocked state and a context switch being performed.  Otherwise pdFALSE.
 *
 * \defgroup xTaskCatchUpTicks xTaskCatchUpTicks
 * \ingroup TaskCtrl
 *//**
 * task.h
 * @code{c}
 * BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );
 * @endcode
 *
 * Determines if pxTicksToWait ticks has passed since a time was captured
 * using a call to vTaskSetTimeOutState().  The captured time includes the tick
 * count and the number of times the tick count has overflowed.
 *
 * @param pxTimeOut The time status as captured previously using
 * vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated
 * to reflect the current time status.
 * @param pxTicksToWait The number of ticks to check for timeout i.e. if
 * pxTicksToWait ticks have passed since pxTimeOut was last updated (either by
 * vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred.
 * If the timeout has not occurred, pxTicksToWait is updated to reflect the
 * number of remaining ticks.
 *
 * @return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is
 * returned and pxTicksToWait is updated to reflect the number of remaining
 * ticks.
 *
 * @see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html
 *
 * Example Usage:
 * @code{c}
 *  // Driver library function used to receive uxWantedBytes from an Rx buffer
 *  // that is filled by a UART interrupt. If there are not enough bytes in the
 *  // Rx buffer then the task enters the Blocked state until it is notified that
 *  // more data has been placed into the buffer. If there is still not enough
 *  // data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()
 *  // is used to re-calculate the Block time to ensure the total amount of time
 *  // spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This
 *  // continues until either the buffer contains at least uxWantedBytes bytes,
 *  // or the total amount of time spent in the Blocked state reaches
 *  // MAX_TIME_TO_WAIT - at which point the task reads however many bytes are
 *  // available up to a maximum of uxWantedBytes.
 *
 *  size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )
 *  {
 *  size_t uxReceived = 0;
 *  TickType_t xTicksToWait = MAX_TIME_TO_WAIT;
 *  TimeOut_t xTimeOut;
 *
 *      // Initialize xTimeOut.  This records the time at which this function
 *      // was entered.
 *      vTaskSetTimeOutState( &xTimeOut );
 *
 *      // Loop until the buffer contains the wanted number of bytes, or a
 *      // timeout occurs.
 *      while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )
 *      {
 *          // The buffer didn't contain enough data so this task is going to
 *          // enter the Blocked state. Adjusting xTicksToWait to account for
 *          // any time that has been spent in the Blocked state within this
 *          // function so far to ensure the total amount of time spent in the
 *          // Blocked state does not exceed MAX_TIME_TO_WAIT.
 *          if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )
 *          {
 *              //Timed out before the wanted number of bytes were available,
 *              // exit the loop.
 *              break;
 *          }
 *
 *          // Wait for a maximum of xTicksToWait ticks to be notified that the
 *          // receive interrupt has placed more data into the buffer.
 *          ulTaskNotifyTake( pdTRUE, xTicksToWait );
 *      }
 *
 *      // Attempt to read uxWantedBytes from the receive buffer into pucBuffer.
 *      // The actual number of bytes read (which might be less than
 *      // uxWantedBytes) is returned.
 *      uxReceived = UART_read_from_receive_buffer( pxUARTInstance,
 *                                                  pucBuffer,
 *                                                  uxWantedBytes );
 *
 *      return uxReceived;
 *  }
 * @endcode
 * \defgroup xTaskCheckForTimeOut xTaskCheckForTimeOut
 * \ingroup TaskCtrl
 *//**
 * task.h
 * @code{c}
 * void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut );
 * @endcode
 *
 * Capture the current time for future use with xTaskCheckForTimeOut().
 *
 * @param pxTimeOut Pointer to a timeout object into which the current time
 * is to be captured.  The captured time includes the tick count and the number
 * of times the tick count has overflowed since the system first booted.
 * \defgroup vTaskSetTimeOutState vTaskSetTimeOutState
 * \ingroup TaskCtrl
 *//**
 * task. h
 * @code{c}
 * uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear );
 *
 * uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear );
 * @endcode
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.
 *
 * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
 * functions to be available.
 *
 * Each task has a private array of "notification values" (or 'notifications'),
 * each of which is a 32-bit unsigned integer (uint32_t).  The constant
 * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 * array, and (for backward compatibility) defaults to 1 if left undefined.
 * Prior to FreeRTOS V10.4.0 there was only one notification value per task.
 *
 * ulTaskNotifyValueClearIndexed() clears the bits specified by the
 * ulBitsToClear bit mask in the notification value at array index uxIndexToClear
 * of the task referenced by xTask.
 *
 * Backward compatibility information:
 * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 * all task notification API functions operated on that value. Replacing the
 * single notification value with an array of notification values necessitated a
 * new set of API functions that could address specific notifications within the
 * array.  ulTaskNotifyValueClear() is the original API function, and remains
 * backward compatible by always operating on the notification value at index 0
 * within the array. Calling ulTaskNotifyValueClear() is equivalent to calling
 * ulTaskNotifyValueClearIndexed() with the uxIndexToClear parameter set to 0.
 *
 * @param xTask The handle of the RTOS task that will have bits in one of its
 * notification values cleared. Set xTask to NULL to clear bits in a
 * notification value of the calling task.  To obtain a task's handle create the
 * task using xTaskCreate() and make use of the pxCreatedTask parameter, or
 * create the task using xTaskCreateStatic() and store the returned value, or
 * use the task's name in a call to xTaskGetHandle().
 *
 * @param uxIndexToClear The index within the target task's array of
 * notification values in which to clear the bits.  uxIndexToClear
 * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.
 * ulTaskNotifyValueClear() does not have this parameter and always clears bits
 * in the notification value at index 0.
 *
 * @param ulBitsToClear Bit mask of the bits to clear in the notification value of
 * xTask. Set a bit to 1 to clear the corresponding bits in the task's notification
 * value. Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear
 * the notification value to 0.  Set ulBitsToClear to 0 to query the task's
 * notification value without clearing any bits.
 *
 *
 * @return The value of the target task's notification value before the bits
 * specified by ulBitsToClear were cleared.
 * \defgroup ulTaskNotifyValueClear ulTaskNotifyValueClear
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToCLear );
 *
 * BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
 * @endcode
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.
 *
 * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
 * functions to be available.
 *
 * Each task has a private array of "notification values" (or 'notifications'),
 * each of which is a 32-bit unsigned integer (uint32_t).  The constant
 * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 * array, and (for backward compatibility) defaults to 1 if left undefined.
 * Prior to FreeRTOS V10.4.0 there was only one notification value per task.
 *
 * If a notification is sent to an index within the array of notifications then
 * the notification at that index is said to be 'pending' until it is read or
 * explicitly cleared by the receiving task.  xTaskNotifyStateClearIndexed()
 * is the function that clears a pending notification without reading the
 * notification value.  The notification value at the same array index is not
 * altered.  Set xTask to NULL to clear the notification state of the calling
 * task.
 *
 * Backward compatibility information:
 * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 * all task notification API functions operated on that value. Replacing the
 * single notification value with an array of notification values necessitated a
 * new set of API functions that could address specific notifications within the
 * array.  xTaskNotifyStateClear() is the original API function, and remains
 * backward compatible by always operating on the notification value at index 0
 * within the array. Calling xTaskNotifyStateClear() is equivalent to calling
 * xTaskNotifyStateClearIndexed() with the uxIndexToNotify parameter set to 0.
 *
 * @param xTask The handle of the RTOS task that will have a notification state
 * cleared.  Set xTask to NULL to clear a notification state in the calling
 * task.  To obtain a task's handle create the task using xTaskCreate() and
 * make use of the pxCreatedTask parameter, or create the task using
 * xTaskCreateStatic() and store the returned value, or use the task's name in
 * a call to xTaskGetHandle().
 *
 * @param uxIndexToClear The index within the target task's array of
 * notification values to act upon.  For example, setting uxIndexToClear to 1
 * will clear the state of the notification at index 1 within the array.
 * uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.
 * ulTaskNotifyStateClear() does not have this parameter and always acts on the
 * notification at index 0.
 *
 * @return pdTRUE if the task's notification state was set to
 * eNotWaitingNotification, otherwise pdFALSE.
 *
 * \defgroup xTaskNotifyStateClearIndexed xTaskNotifyStateClearIndexed
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait );
 *
 * uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );
 * @endcode
 *
 * Waits for a direct to task notification on a particular index in the calling
 * task's notification array in a manner similar to taking a counting semaphore.
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.
 *
 * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
 * function to be available.
 *
 * Each task has a private array of "notification values" (or 'notifications'),
 * each of which is a 32-bit unsigned integer (uint32_t).  The constant
 * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 * array, and (for backward compatibility) defaults to 1 if left undefined.
 * Prior to FreeRTOS V10.4.0 there was only one notification value per task.
 *
 * Events can be sent to a task using an intermediary object.  Examples of such
 * objects are queues, semaphores, mutexes and event groups.  Task notifications
 * are a method of sending an event directly to a task without the need for such
 * an intermediary object.
 *
 * A notification sent to a task can optionally perform an action, such as
 * update, overwrite or increment one of the task's notification values.  In
 * that way task notifications can be used to send data to a task, or be used as
 * light weight and fast binary or counting semaphores.
 *
 * ulTaskNotifyTakeIndexed() is intended for use when a task notification is
 * used as a faster and lighter weight binary or counting semaphore alternative.
 * Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function,
 * the equivalent action that instead uses a task notification is
 * ulTaskNotifyTakeIndexed().
 *
 * When a task is using its notification value as a binary or counting semaphore
 * other tasks should send notifications to it using the xTaskNotifyGiveIndexed()
 * macro, or xTaskNotifyIndex() function with the eAction parameter set to
 * eIncrement.
 *
 * ulTaskNotifyTakeIndexed() can either clear the task's notification value at
 * the array index specified by the uxIndexToWaitOn parameter to zero on exit,
 * in which case the notification value acts like a binary semaphore, or
 * decrement the notification value on exit, in which case the notification
 * value acts like a counting semaphore.
 *
 * A task can use ulTaskNotifyTakeIndexed() to [optionally] block to wait for
 * a notification.  The task does not consume any CPU time while it is in the
 * Blocked state.
 *
 * Where as xTaskNotifyWaitIndexed() will return when a notification is pending,
 * ulTaskNotifyTakeIndexed() will return when the task's notification value is
 * not zero.
 *
 * **NOTE** Each notification within the array operates independently - a task
 * can only block on one notification within the array at a time and will not be
 * unblocked by a notification sent to any other array index.
 *
 * Backward compatibility information:
 * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 * all task notification API functions operated on that value. Replacing the
 * single notification value with an array of notification values necessitated a
 * new set of API functions that could address specific notifications within the
 * array.  ulTaskNotifyTake() is the original API function, and remains backward
 * compatible by always operating on the notification value at index 0 in the
 * array. Calling ulTaskNotifyTake() is equivalent to calling
 * ulTaskNotifyTakeIndexed() with the uxIndexToWaitOn parameter set to 0.
 *
 * @param uxIndexToWaitOn The index within the calling task's array of
 * notification values on which the calling task will wait for a notification to
 * be non-zero.  uxIndexToWaitOn must be less than
 * configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyTake() does
 * not have this parameter and always waits for notifications on index 0.
 *
 * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
 * notification value is decremented when the function exits.  In this way the
 * notification value acts like a counting semaphore.  If xClearCountOnExit is
 * not pdFALSE then the task's notification value is cleared to zero when the
 * function exits.  In this way the notification value acts like a binary
 * semaphore.
 *
 * @param xTicksToWait The maximum amount of time that the task should wait in
 * the Blocked state for the task's notification value to be greater than zero,
 * should the count not already be greater than zero when
 * ulTaskNotifyTake() was called.  The task will not consume any processing
 * time while it is in the Blocked state.  This is specified in kernel ticks,
 * the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time
 * specified in milliseconds to a time specified in ticks.
 *
 * @return The task's notification count before it is either cleared to zero or
 * decremented (see the xClearCountOnExit parameter).
 *
 * \defgroup ulTaskNotifyTakeIndexed ulTaskNotifyTakeIndexed
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken );
 * void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
 * @endcode
 *
 * A version of xTaskNotifyGiveIndexed() that can be called from an interrupt
 * service routine (ISR).
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
 *
 * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
 * to be available.
 *
 * Each task has a private array of "notification values" (or 'notifications'),
 * each of which is a 32-bit unsigned integer (uint32_t).  The constant
 * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 * array, and (for backward compatibility) defaults to 1 if left undefined.
 * Prior to FreeRTOS V10.4.0 there was only one notification value per task.
 *
 * Events can be sent to a task using an intermediary object.  Examples of such
 * objects are queues, semaphores, mutexes and event groups.  Task notifications
 * are a method of sending an event directly to a task without the need for such
 * an intermediary object.
 *
 * A notification sent to a task can optionally perform an action, such as
 * update, overwrite or increment one of the task's notification values.  In
 * that way task notifications can be used to send data to a task, or be used as
 * light weight and fast binary or counting semaphores.
 *
 * vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications
 * are used as light weight and faster binary or counting semaphore equivalents.
 * Actual FreeRTOS semaphores are given from an ISR using the
 * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
 * a task notification is vTaskNotifyGiveIndexedFromISR().
 *
 * When task notifications are being used as a binary or counting semaphore
 * equivalent then the task being notified should wait for the notification
 * using the ulTaskNotifyTakeIndexed() API function rather than the
 * xTaskNotifyWaitIndexed() API function.
 *
 * **NOTE** Each notification within the array operates independently - a task
 * can only block on one notification within the array at a time and will not be
 * unblocked by a notification sent to any other array index.
 *
 * Backward compatibility information:
 * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 * all task notification API functions operated on that value. Replacing the
 * single notification value with an array of notification values necessitated a
 * new set of API functions that could address specific notifications within the
 * array.  xTaskNotifyFromISR() is the original API function, and remains
 * backward compatible by always operating on the notification value at index 0
 * within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling
 * xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0.
 *
 * @param xTaskToNotify The handle of the task being notified.  The handle to a
 * task can be returned from the xTaskCreate() API function used to create the
 * task, and the handle of the currently running task can be obtained by calling
 * xTaskGetCurrentTaskHandle().
 *
 * @param uxIndexToNotify The index within the target task's array of
 * notification values to which the notification is to be sent.  uxIndexToNotify
 * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.
 * xTaskNotifyGiveFromISR() does not have this parameter and always sends
 * notifications to index 0.
 *
 * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
 * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
 * task to which the notification was sent to leave the Blocked state, and the
 * unblocked task has a priority higher than the currently running task.  If
 * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
 * should be requested before the interrupt is exited.  How a context switch is
 * requested from an ISR is dependent on the port - see the documentation page
 * for the port in use.
 *
 * \defgroup vTaskNotifyGiveIndexedFromISR vTaskNotifyGiveIndexedFromISR
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify );
 * BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );
 * @endcode
 *
 * Sends a direct to task notification to a particular index in the target
 * task's notification array in a manner similar to giving a counting semaphore.
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
 *
 * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
 * macros to be available.
 *
 * Each task has a private array of "notification values" (or 'notifications'),
 * each of which is a 32-bit unsigned integer (uint32_t).  The constant
 * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 * array, and (for backward compatibility) defaults to 1 if left undefined.
 * Prior to FreeRTOS V10.4.0 there was only one notification value per task.
 *
 * Events can be sent to a task using an intermediary object.  Examples of such
 * objects are queues, semaphores, mutexes and event groups.  Task notifications
 * are a method of sending an event directly to a task without the need for such
 * an intermediary object.
 *
 * A notification sent to a task can optionally perform an action, such as
 * update, overwrite or increment one of the task's notification values.  In
 * that way task notifications can be used to send data to a task, or be used as
 * light weight and fast binary or counting semaphores.
 *
 * xTaskNotifyGiveIndexed() is a helper macro intended for use when task
 * notifications are used as light weight and faster binary or counting
 * semaphore equivalents.  Actual FreeRTOS semaphores are given using the
 * xSemaphoreGive() API function, the equivalent action that instead uses a task
 * notification is xTaskNotifyGiveIndexed().
 *
 * When task notifications are being used as a binary or counting semaphore
 * equivalent then the task being notified should wait for the notification
 * using the ulTaskNotifyTakeIndexed() API function rather than the
 * xTaskNotifyWaitIndexed() API function.
 *
 * **NOTE** Each notification within the array operates independently - a task
 * can only block on one notification within the array at a time and will not be
 * unblocked by a notification sent to any other array index.
 *
 * Backward compatibility information:
 * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 * all task notification API functions operated on that value. Replacing the
 * single notification value with an array of notification values necessitated a
 * new set of API functions that could address specific notifications within the
 * array.  xTaskNotifyGive() is the original API function, and remains backward
 * compatible by always operating on the notification value at index 0 in the
 * array. Calling xTaskNotifyGive() is equivalent to calling
 * xTaskNotifyGiveIndexed() with the uxIndexToNotify parameter set to 0.
 *
 * @param xTaskToNotify The handle of the task being notified.  The handle to a
 * task can be returned from the xTaskCreate() API function used to create the
 * task, and the handle of the currently running task can be obtained by calling
 * xTaskGetCurrentTaskHandle().
 *
 * @param uxIndexToNotify The index within the target task's array of
 * notification values to which the notification is to be sent.  uxIndexToNotify
 * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyGive()
 * does not have this parameter and always sends notifications to index 0.
 *
 * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
 * eAction parameter set to eIncrement - so pdPASS is always returned.
 *
 * \defgroup xTaskNotifyGiveIndexed xTaskNotifyGiveIndexed
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );
 *
 * BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );
 * @endcode
 *
 * Waits for a direct to task notification to be pending at a given index within
 * an array of direct to task notifications.
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.
 *
 * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
 * function to be available.
 *
 * Each task has a private array of "notification values" (or 'notifications'),
 * each of which is a 32-bit unsigned integer (uint32_t).  The constant
 * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 * array, and (for backward compatibility) defaults to 1 if left undefined.
 * Prior to FreeRTOS V10.4.0 there was only one notification value per task.
 *
 * Events can be sent to a task using an intermediary object.  Examples of such
 * objects are queues, semaphores, mutexes and event groups.  Task notifications
 * are a method of sending an event directly to a task without the need for such
 * an intermediary object.
 *
 * A notification sent to a task can optionally perform an action, such as
 * update, overwrite or increment one of the task's notification values.  In
 * that way task notifications can be used to send data to a task, or be used as
 * light weight and fast binary or counting semaphores.
 *
 * A notification sent to a task will remain pending until it is cleared by the
 * task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their
 * un-indexed equivalents).  If the task was already in the Blocked state to
 * wait for a notification when the notification arrives then the task will
 * automatically be removed from the Blocked state (unblocked) and the
 * notification cleared.
 *
 * A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a
 * notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block
 * to wait for a notification value to have a non-zero value.  The task does
 * not consume any CPU time while it is in the Blocked state.
 *
 * **NOTE** Each notification within the array operates independently - a task
 * can only block on one notification within the array at a time and will not be
 * unblocked by a notification sent to any other array index.
 *
 * Backward compatibility information:
 * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 * all task notification API functions operated on that value. Replacing the
 * single notification value with an array of notification values necessitated a
 * new set of API functions that could address specific notifications within the
 * array.  xTaskNotifyWait() is the original API function, and remains backward
 * compatible by always operating on the notification value at index 0 in the
 * array. Calling xTaskNotifyWait() is equivalent to calling
 * xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0.
 *
 * @param uxIndexToWaitOn The index within the calling task's array of
 * notification values on which the calling task will wait for a notification to
 * be received.  uxIndexToWaitOn must be less than
 * configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyWait() does
 * not have this parameter and always waits for notifications on index 0.
 *
 * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
 * will be cleared in the calling task's notification value before the task
 * checks to see if any notifications are pending, and optionally blocks if no
 * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
 * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
 * the effect of resetting the task's notification value to 0.  Setting
 * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
 *
 * @param ulBitsToClearOnExit If a notification is pending or received before
 * the calling task exits the xTaskNotifyWait() function then the task's
 * notification value (see the xTaskNotify() API function) is passed out using
 * the pulNotificationValue parameter.  Then any bits that are set in
 * ulBitsToClearOnExit will be cleared in the task's notification value (note
 * *pulNotificationValue is set before any bits are cleared).  Setting
 * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
 * (if limits.h is not included) will have the effect of resetting the task's
 * notification value to 0 before the function exits.  Setting
 * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
 * when the function exits (in which case the value passed out in
 * pulNotificationValue will match the task's notification value).
 *
 * @param pulNotificationValue Used to pass the task's notification value out
 * of the function.  Note the value passed out will not be effected by the
 * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
 *
 * @param xTicksToWait The maximum amount of time that the task should wait in
 * the Blocked state for a notification to be received, should a notification
 * not already be pending when xTaskNotifyWait() was called.  The task
 * will not consume any processing time while it is in the Blocked state.  This
 * is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be
 * used to convert a time specified in milliseconds to a time specified in
 * ticks.
 *
 * @return If a notification was received (including notifications that were
 * already pending when xTaskNotifyWait was called) then pdPASS is
 * returned.  Otherwise pdFAIL is returned.
 *
 * \defgroup xTaskNotifyWaitIndexed xTaskNotifyWaitIndexed
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskNotifyAndQueryIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken );
 * BaseType_t xTaskNotifyAndQueryFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken );
 * @endcode
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.
 *
 * xTaskNotifyAndQueryIndexedFromISR() performs the same operation as
 * xTaskNotifyIndexedFromISR() with the addition that it also returns the
 * subject task's prior notification value (the notification value at the time
 * the function is called rather than at the time the function returns) in the
 * additional pulPreviousNotifyValue parameter.
 *
 * xTaskNotifyAndQueryFromISR() performs the same operation as
 * xTaskNotifyFromISR() with the addition that it also returns the subject
 * task's prior notification value (the notification value at the time the
 * function is called rather than at the time the function returns) in the
 * additional pulPreviousNotifyValue parameter.
 *
 * \defgroup xTaskNotifyAndQueryIndexedFromISR xTaskNotifyAndQueryIndexedFromISR
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );
 * BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );
 * @endcode
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.
 *
 * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
 * functions to be available.
 *
 * A version of xTaskNotifyIndexed() that can be used from an interrupt service
 * routine (ISR).
 *
 * Each task has a private array of "notification values" (or 'notifications'),
 * each of which is a 32-bit unsigned integer (uint32_t).  The constant
 * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 * array, and (for backward compatibility) defaults to 1 if left undefined.
 * Prior to FreeRTOS V10.4.0 there was only one notification value per task.
 *
 * Events can be sent to a task using an intermediary object.  Examples of such
 * objects are queues, semaphores, mutexes and event groups.  Task notifications
 * are a method of sending an event directly to a task without the need for such
 * an intermediary object.
 *
 * A notification sent to a task can optionally perform an action, such as
 * update, overwrite or increment one of the task's notification values.  In
 * that way task notifications can be used to send data to a task, or be used as
 * light weight and fast binary or counting semaphores.
 *
 * A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a
 * notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block
 * to wait for a notification value to have a non-zero value.  The task does
 * not consume any CPU time while it is in the Blocked state.
 *
 * A notification sent to a task will remain pending until it is cleared by the
 * task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their
 * un-indexed equivalents).  If the task was already in the Blocked state to
 * wait for a notification when the notification arrives then the task will
 * automatically be removed from the Blocked state (unblocked) and the
 * notification cleared.
 *
 * **NOTE** Each notification within the array operates independently - a task
 * can only block on one notification within the array at a time and will not be
 * unblocked by a notification sent to any other array index.
 *
 * Backward compatibility information:
 * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 * all task notification API functions operated on that value. Replacing the
 * single notification value with an array of notification values necessitated a
 * new set of API functions that could address specific notifications within the
 * array.  xTaskNotifyFromISR() is the original API function, and remains
 * backward compatible by always operating on the notification value at index 0
 * within the array. Calling xTaskNotifyFromISR() is equivalent to calling
 * xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0.
 *
 * @param uxIndexToNotify The index within the target task's array of
 * notification values to which the notification is to be sent.  uxIndexToNotify
 * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyFromISR()
 * does not have this parameter and always sends notifications to index 0.
 *
 * @param xTaskToNotify The handle of the task being notified.  The handle to a
 * task can be returned from the xTaskCreate() API function used to create the
 * task, and the handle of the currently running task can be obtained by calling
 * xTaskGetCurrentTaskHandle().
 *
 * @param ulValue Data that can be sent with the notification.  How the data is
 * used depends on the value of the eAction parameter.
 *
 * @param eAction Specifies how the notification updates the task's notification
 * value, if at all.  Valid values for eAction are as follows:
 *
 * eSetBits -
 * The task's notification value is bitwise ORed with ulValue.  xTaskNotify()
 * always returns pdPASS in this case.
 *
 * eIncrement -
 * The task's notification value is incremented.  ulValue is not used and
 * xTaskNotify() always returns pdPASS in this case.
 *
 * eSetValueWithOverwrite -
 * The task's notification value is set to the value of ulValue, even if the
 * task being notified had not yet processed the previous notification (the
 * task already had a notification pending).  xTaskNotify() always returns
 * pdPASS in this case.
 *
 * eSetValueWithoutOverwrite -
 * If the task being notified did not already have a notification pending then
 * the task's notification value is set to ulValue and xTaskNotify() will
 * return pdPASS.  If the task being notified already had a notification
 * pending then no action is performed and pdFAIL is returned.
 *
 * eNoAction -
 * The task receives a notification without its notification value being
 * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
 * this case.
 *
 * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
 * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
 * task to which the notification was sent to leave the Blocked state, and the
 * unblocked task has a priority higher than the currently running task.  If
 * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
 * be requested before the interrupt is exited.  How a context switch is
 * requested from an ISR is dependent on the port - see the documentation page
 * for the port in use.
 *
 * @return Dependent on the value of eAction.  See the description of the
 * eAction parameter.
 *
 * \defgroup xTaskNotifyIndexedFromISR xTaskNotifyIndexedFromISR
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskNotifyAndQueryIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue );
 * BaseType_t xTaskNotifyAndQuery( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue );
 * @endcode
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.
 *
 * xTaskNotifyAndQueryIndexed() performs the same operation as
 * xTaskNotifyIndexed() with the addition that it also returns the subject
 * task's prior notification value (the notification value at the time the
 * function is called rather than when the function returns) in the additional
 * pulPreviousNotifyValue parameter.
 *
 * xTaskNotifyAndQuery() performs the same operation as xTaskNotify() with the
 * addition that it also returns the subject task's prior notification value
 * (the notification value as it was at the time the function is called, rather
 * than when the function returns) in the additional pulPreviousNotifyValue
 * parameter.
 *
 * \defgroup xTaskNotifyAndQueryIndexed xTaskNotifyAndQueryIndexed
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction );
 * BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );
 * @endcode
 *
 * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.
 *
 * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
 * functions to be available.
 *
 * Sends a direct to task notification to a task, with an optional value and
 * action.
 *
 * Each task has a private array of "notification values" (or 'notifications'),
 * each of which is a 32-bit unsigned integer (uint32_t).  The constant
 * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 * array, and (for backward compatibility) defaults to 1 if left undefined.
 * Prior to FreeRTOS V10.4.0 there was only one notification value per task.
 *
 * Events can be sent to a task using an intermediary object.  Examples of such
 * objects are queues, semaphores, mutexes and event groups.  Task notifications
 * are a method of sending an event directly to a task without the need for such
 * an intermediary object.
 *
 * A notification sent to a task can optionally perform an action, such as
 * update, overwrite or increment one of the task's notification values.  In
 * that way task notifications can be used to send data to a task, or be used as
 * light weight and fast binary or counting semaphores.
 *
 * A task can use xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() to
 * [optionally] block to wait for a notification to be pending.  The task does
 * not consume any CPU time while it is in the Blocked state.
 *
 * A notification sent to a task will remain pending until it is cleared by the
 * task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their
 * un-indexed equivalents).  If the task was already in the Blocked state to
 * wait for a notification when the notification arrives then the task will
 * automatically be removed from the Blocked state (unblocked) and the
 * notification cleared.
 *
 * **NOTE** Each notification within the array operates independently - a task
 * can only block on one notification within the array at a time and will not be
 * unblocked by a notification sent to any other array index.
 *
 * Backward compatibility information:
 * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 * all task notification API functions operated on that value. Replacing the
 * single notification value with an array of notification values necessitated a
 * new set of API functions that could address specific notifications within the
 * array.  xTaskNotify() is the original API function, and remains backward
 * compatible by always operating on the notification value at index 0 in the
 * array. Calling xTaskNotify() is equivalent to calling xTaskNotifyIndexed()
 * with the uxIndexToNotify parameter set to 0.
 *
 * @param xTaskToNotify The handle of the task being notified.  The handle to a
 * task can be returned from the xTaskCreate() API function used to create the
 * task, and the handle of the currently running task can be obtained by calling
 * xTaskGetCurrentTaskHandle().
 *
 * @param uxIndexToNotify The index within the target task's array of
 * notification values to which the notification is to be sent.  uxIndexToNotify
 * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotify() does
 * not have this parameter and always sends notifications to index 0.
 *
 * @param ulValue Data that can be sent with the notification.  How the data is
 * used depends on the value of the eAction parameter.
 *
 * @param eAction Specifies how the notification updates the task's notification
 * value, if at all.  Valid values for eAction are as follows:
 *
 * eSetBits -
 * The target notification value is bitwise ORed with ulValue.
 * xTaskNotifyIndexed() always returns pdPASS in this case.
 *
 * eIncrement -
 * The target notification value is incremented.  ulValue is not used and
 * xTaskNotifyIndexed() always returns pdPASS in this case.
 *
 * eSetValueWithOverwrite -
 * The target notification value is set to the value of ulValue, even if the
 * task being notified had not yet processed the previous notification at the
 * same array index (the task already had a notification pending at that index).
 * xTaskNotifyIndexed() always returns pdPASS in this case.
 *
 * eSetValueWithoutOverwrite -
 * If the task being notified did not already have a notification pending at the
 * same array index then the target notification value is set to ulValue and
 * xTaskNotifyIndexed() will return pdPASS.  If the task being notified already
 * had a notification pending at the same array index then no action is
 * performed and pdFAIL is returned.
 *
 * eNoAction -
 * The task receives a notification at the specified array index without the
 * notification value at that index being updated.  ulValue is not used and
 * xTaskNotifyIndexed() always returns pdPASS in this case.
 *
 * pulPreviousNotificationValue -
 * Can be used to pass out the subject task's notification value before any
 * bits are modified by the notify function.
 *
 * @return Dependent on the value of eAction.  See the description of the
 * eAction parameter.
 *
 * \defgroup xTaskNotifyIndexed xTaskNotifyIndexed
 * \ingroup TaskNotifications
 *//**
 * task. h
 * @code{c}
 * configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void );
 * configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void );
 * @endcode
 *
 * configGENERATE_RUN_TIME_STATS, configUSE_STATS_FORMATTING_FUNCTIONS and
 * INCLUDE_xTaskGetIdleTaskHandle must all be defined as 1 for these functions
 * to be available.  The application must also then provide definitions for
 * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
 * to configure a peripheral timer/counter and return the timers current count
 * value respectively.  The counter should be at least 10 times the frequency of
 * the tick count.
 *
 * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
 * accumulated execution time being stored for each task.  The resolution
 * of the accumulated time value depends on the frequency of the timer
 * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
 * While uxTaskGetSystemState() and vTaskGetRunTimeStats() writes the total
 * execution time of each task into a buffer, ulTaskGetIdleRunTimeCounter()
 * returns the total execution time of just the idle task and
 * ulTaskGetIdleRunTimePercent() returns the percentage of the CPU time used by
 * just the idle task.
 *
 * Note the amount of idle time is only a good measure of the slack time in a
 * system if there are no other tasks executing at the idle priority, tickless
 * idle is not used, and configIDLE_SHOULD_YIELD is set to 0.
 *
 * @return The total run time of the idle task or the percentage of the total
 * run time consumed by the idle task.  This is the amount of time the
 * idle task has actually been executing.  The unit of time is dependent on the
 * frequency configured using the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and
 * portGET_RUN_TIME_COUNTER_VALUE() macros.
 *
 * \defgroup ulTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter
 * \ingroup TaskUtils
 *//*lint !e971 Unqualified char types are allowed for strings and single characters only. *//**
 * task. h
 * @code{c}
 * void vTaskGetRunTimeStats( char *pcWriteBuffer );
 * @endcode
 *
 * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
 * must both be defined as 1 for this function to be available.  The application
 * must also then provide definitions for
 * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
 * to configure a peripheral timer/counter and return the timers current count
 * value respectively.  The counter should be at least 10 times the frequency of
 * the tick count.
 *
 * NOTE 1: This function will disable interrupts for its duration.  It is
 * not intended for normal application runtime use but as a debug aid.
 *
 * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
 * accumulated execution time being stored for each task.  The resolution
 * of the accumulated time value depends on the frequency of the timer
 * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
 * Calling vTaskGetRunTimeStats() writes the total execution time of each
 * task into a buffer, both as an absolute count value and as a percentage
 * of the total system execution time.
 *
 * NOTE 2:
 *
 * This function is provided for convenience only, and is used by many of the
 * demo applications.  Do not consider it to be part of the scheduler.
 *
 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
 * uxTaskGetSystemState() output into a human readable table that displays the
 * amount of time each task has spent in the Running state in both absolute and
 * percentage terms.
 *
 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
 * that might bloat the code size, use a lot of stack, and provide different
 * results on different platforms.  An alternative, tiny, third party, and
 * limited functionality implementation of sprintf() is provided in many of the
 * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
 * printf-stdarg.c does not provide a full snprintf() implementation!).
 *
 * It is recommended that production systems call uxTaskGetSystemState() directly
 * to get access to raw stats data, rather than indirectly through a call to
 * vTaskGetRunTimeStats().
 *
 * @param pcWriteBuffer A buffer into which the execution times will be
 * written, in ASCII form.  This buffer is assumed to be large enough to
 * contain the generated report.  Approximately 40 bytes per task should
 * be sufficient.
 *
 * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
 * \ingroup TaskUtils
 *//**
 * task. h
 * @code{c}
 * void vTaskList( char *pcWriteBuffer );
 * @endcode
 *
 * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
 * both be defined as 1 for this function to be available.  See the
 * configuration section of the FreeRTOS.org website for more information.
 *
 * NOTE 1: This function will disable interrupts for its duration.  It is
 * not intended for normal application runtime use but as a debug aid.
 *
 * Lists all the current tasks, along with their current state and stack
 * usage high water mark.
 *
 * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
 * suspended ('S').
 *
 * PLEASE NOTE:
 *
 * This function is provided for convenience only, and is used by many of the
 * demo applications.  Do not consider it to be part of the scheduler.
 *
 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
 * uxTaskGetSystemState() output into a human readable table that displays task:
 * names, states, priority, stack usage and task number.
 * Stack usage specified as the number of unused StackType_t words stack can hold
 * on top of stack - not the number of bytes.
 *
 * vTaskList() has a dependency on the sprintf() C library function that might
 * bloat the code size, use a lot of stack, and provide different results on
 * different platforms.  An alternative, tiny, third party, and limited
 * functionality implementation of sprintf() is provided in many of the
 * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
 * printf-stdarg.c does not provide a full snprintf() implementation!).
 *
 * It is recommended that production systems call uxTaskGetSystemState()
 * directly to get access to raw stats data, rather than indirectly through a
 * call to vTaskList().
 *
 * @param pcWriteBuffer A buffer into which the above mentioned details
 * will be written, in ASCII form.  This buffer is assumed to be large
 * enough to contain the generated report.  Approximately 40 bytes per
 * task should be sufficient.
 *
 * \defgroup vTaskList vTaskList
 * \ingroup TaskUtils
 *//**
 * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
 * uxTaskGetSystemState() to be available.
 *
 * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
 * the system.  TaskStatus_t structures contain, among other things, members
 * for the task handle, task name, task priority, task state, and total amount
 * of run time consumed by the task.  See the TaskStatus_t structure
 * definition in this file for the full member list.
 *
 * NOTE:  This function is intended for debugging use only as its use results in
 * the scheduler remaining suspended for an extended period.
 *
 * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
 * The array must contain at least one TaskStatus_t structure for each task
 * that is under the control of the RTOS.  The number of tasks under the control
 * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
 *
 * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
 * parameter.  The size is specified as the number of indexes in the array, or
 * the number of TaskStatus_t structures contained in the array, not by the
 * number of bytes in the array.
 *
 * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
 * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
 * total run time (as defined by the run time stats clock, see
 * https://www.FreeRTOS.org/rtos-run-time-stats.html) since the target booted.
 * pulTotalRunTime can be set to NULL to omit the total run time information.
 *
 * @return The number of TaskStatus_t structures that were populated by
 * uxTaskGetSystemState().  This should equal the number returned by the
 * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
 * in the uxArraySize parameter was too small.
 *
 * Example usage:
 * @code{c}
 *  // This example demonstrates how a human readable table of run time stats
 *  // information is generated from raw data provided by uxTaskGetSystemState().
 *  // The human readable table is written to pcWriteBuffer
 *  void vTaskGetRunTimeStats( char *pcWriteBuffer )
 *  {
 *  TaskStatus_t *pxTaskStatusArray;
 *  volatile UBaseType_t uxArraySize, x;
 *  configRUN_TIME_COUNTER_TYPE ulTotalRunTime, ulStatsAsPercentage;
 *
 *      // Make sure the write buffer does not contain a string.
 * pcWriteBuffer = 0x00;
 *
 *      // Take a snapshot of the number of tasks in case it changes while this
 *      // function is executing.
 *      uxArraySize = uxTaskGetNumberOfTasks();
 *
 *      // Allocate a TaskStatus_t structure for each task.  An array could be
 *      // allocated statically at compile time.
 *      pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
 *
 *      if( pxTaskStatusArray != NULL )
 *      {
 *          // Generate raw status information about each task.
 *          uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
 *
 *          // For percentage calculations.
 *          ulTotalRunTime /= 100UL;
 *
 *          // Avoid divide by zero errors.
 *          if( ulTotalRunTime > 0 )
 *          {
 *              // For each populated position in the pxTaskStatusArray array,
 *              // format the raw data as human readable ASCII data
 *              for( x = 0; x < uxArraySize; x++ )
 *              {
 *                  // What percentage of the total run time has the task used?
 *                  // This will always be rounded down to the nearest integer.
 *                  // ulTotalRunTimeDiv100 has already been divided by 100.
 *                  ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
 *
 *                  if( ulStatsAsPercentage > 0UL )
 *                  {
 *                      sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
 *                  }
 *                  else
 *                  {
 *                      // If the percentage is zero here then the task has
 *                      // consumed less than 1% of the total run time.
 *                      sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
 *                  }
 *
 *                  pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
 *              }
 *          }
 *
 *          // The array is no longer needed, free the memory it consumes.
 *          vPortFree( pxTaskStatusArray );
 *      }
 *  }
 *  @endcode
 *//**
 * xTaskGetIdleTaskHandle() is only available if
 * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
 *
 * Simply returns the handle of the idle task.  It is not valid to call
 * xTaskGetIdleTaskHandle() before the scheduler has been started.
 *//**
 * task.h
 * @code{c}
 * BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );
 * @endcode
 *
 * Calls the hook function associated with xTask.  Passing xTask as NULL has
 * the effect of calling the Running tasks (the calling task) hook function.
 *
 * pvParameter is passed to the hook function for the task to interpret as it
 * wants.  The return value is the value returned by the task hook function
 * registered by the user.
 *//**
 * task.h
 * @code{c}
 * void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
 * @endcode
 *
 * This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Idle Task TCB.  This function is required when
 * configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION
 *
 * @param ppxIdleTaskTCBBuffer A handle to a statically allocated TCB buffer
 * @param ppxIdleTaskStackBuffer A handle to a statically allocated Stack buffer for the idle task
 * @param pulIdleTaskStackSize A pointer to the number of elements that will fit in the allocated stack buffer
 *//**
 *  task.h
 * @code{c}
 * void vApplicationTickHook( void );
 * @endcode
 *
 * This hook function is called in the system tick handler after any OS work is completed.
 *//**
 * task.h
 * @code{c}
 * void vApplicationStackOverflowHook( TaskHandle_t xTask char *pcTaskName);
 * @endcode
 *
 * The application stack overflow hook is called when a stack overflow is detected for a task.
 *
 * Details on stack overflow detection can be found here: https://www.FreeRTOS.org/Stacks-and-stack-overflow-checking.html
 *
 * @param xTask the task that just exceeded its stack boundaries.
 * @param pcTaskName A character string containing the name of the offending task.
 *//* Each task contains an array of pointers that is dimensioned by the
 * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
 * kernel does not use the pointers itself, so the application writer can use
 * the pointers for any purpose they wish.  The following two functions are
 * used to set and query a pointer respectively. *//* ifdef configUSE_APPLICATION_TASK_TAG *//* configUSE_APPLICATION_TASK_TAG ==1 *//**
 * task.h
 * @code{c}
 * void xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask );
 * @endcode
 *
 * Returns the pxHookFunction value assigned to the task xTask.  Can
 * be called from an interrupt service routine.
 *//**
 * task.h
 * @code{c}
 * void xTaskGetApplicationTaskTag( TaskHandle_t xTask );
 * @endcode
 *
 * Returns the pxHookFunction value assigned to the task xTask.  Do not
 * call from an interrupt service routine - call
 * xTaskGetApplicationTaskTagFromISR() instead.
 *//**
 * task.h
 * @code{c}
 * void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );
 * @endcode
 *
 * Sets pxHookFunction to be the task hook function used by the task xTask.
 * Passing xTask as NULL has the effect of setting the calling tasks hook
 * function.
 *//* When using trace macros it is sometimes necessary to include task.h before
 * FreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
 * so the following two prototypes will cause a compilation error.  This can be
 * fixed by simply guarding against the inclusion of these two prototypes unless
 * they are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
 * constant. *//**
 * task.h
 * @code{c}
 * configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );
 * @endcode
 *
 * INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for
 * this function to be available.
 *
 * Returns the high water mark of the stack associated with xTask.  That is,
 * the minimum free stack space there has been (in words, so on a 32 bit machine
 * a value of 1 means 4 bytes) since the task started.  The smaller the returned
 * number the closer the task has come to overflowing its stack.
 *
 * uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
 * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
 * user to determine the return type.  It gets around the problem of the value
 * overflowing on 8-bit types without breaking backward compatibility for
 * applications that expect an 8-bit return type.
 *
 * @param xTask Handle of the task associated with the stack to be checked.
 * Set xTask to NULL to check the stack of the calling task.
 *
 * @return The smallest amount of free stack space there has been (in words, so
 * actual spaces on the stack rather than bytes) since the task referenced by
 * xTask was created.
 *//**
 * task.h
 * @code{c}
 * UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );
 * @endcode
 *
 * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
 * this function to be available.
 *
 * Returns the high water mark of the stack associated with xTask.  That is,
 * the minimum free stack space there has been (in words, so on a 32 bit machine
 * a value of 1 means 4 bytes) since the task started.  The smaller the returned
 * number the closer the task has come to overflowing its stack.
 *
 * uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
 * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
 * user to determine the return type.  It gets around the problem of the value
 * overflowing on 8-bit types without breaking backward compatibility for
 * applications that expect an 8-bit return type.
 *
 * @param xTask Handle of the task associated with the stack to be checked.
 * Set xTask to NULL to check the stack of the calling task.
 *
 * @return The smallest amount of free stack space there has been (in words, so
 * actual spaces on the stack rather than bytes) since the task referenced by
 * xTask was created.
 *//**
 * task. h
 * @code{c}
 * TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );
 * @endcode
 *
 * NOTE:  This function takes a relatively long time to complete and should be
 * used sparingly.
 *
 * @return The handle of the task that has the human readable name pcNameToQuery.
 * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
 * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
 *
 * \defgroup pcTaskGetHandle pcTaskGetHandle
 * \ingroup TaskUtils
 *//**
 * task. h
 * @code{c}
 * char *pcTaskGetName( TaskHandle_t xTaskToQuery );
 * @endcode
 *
 * @return The text (human readable) name of the task referenced by the handle
 * xTaskToQuery.  A task can query its own name by either passing in its own
 * handle, or by setting xTaskToQuery to NULL.
 *
 * \defgroup pcTaskGetName pcTaskGetName
 * \ingroup TaskUtils
 *//**
 * task. h
 * @code{c}
 * uint16_t uxTaskGetNumberOfTasks( void );
 * @endcode
 *
 * @return The number of tasks that the real time kernel is currently managing.
 * This includes all ready, blocked and suspended tasks.  A task that
 * has been deleted but not yet freed by the idle task will also be
 * included in the count.
 *
 * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
 * \ingroup TaskUtils
 *//**
 * task. h
 * @code{c}
 * TickType_t xTaskGetTickCountFromISR( void );
 * @endcode
 *
 * @return The count of ticks since vTaskStartScheduler was called.
 *
 * This is a version of xTaskGetTickCount() that is safe to be called from an
 * ISR - provided that TickType_t is the natural word size of the
 * microcontroller being used or interrupt nesting is either not supported or
 * not being used.
 *
 * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
 * \ingroup TaskUtils
 *//**
 * task. h
 * @code{c}
 * TickType_t xTaskGetTickCount( void );
 * @endcode
 *
 * @return The count of ticks since vTaskStartScheduler was called.
 *
 * \defgroup xTaskGetTickCount xTaskGetTickCount
 * \ingroup TaskUtils
 *//*-----------------------------------------------------------
* TASK UTILITIES
*----------------------------------------------------------*//**
 * task. h
 * @code{c}
 * BaseType_t xTaskResumeAll( void );
 * @endcode
 *
 * Resumes scheduler activity after it was suspended by a call to
 * vTaskSuspendAll().
 *
 * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
 * that were previously suspended by a call to vTaskSuspend().
 *
 * @return If resuming the scheduler caused a context switch then pdTRUE is
 *         returned, otherwise pdFALSE is returned.
 *
 * Example usage:
 * @code{c}
 * void vTask1( void * pvParameters )
 * {
 *   for( ;; )
 *   {
 *       // Task code goes here.
 *
 *       // ...
 *
 *       // At some point the task wants to perform a long operation during
 *       // which it does not want to get swapped out.  It cannot use
 *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
 *       // operation may cause interrupts to be missed - including the
 *       // ticks.
 *
 *       // Prevent the real time kernel swapping out the task.
 *       vTaskSuspendAll ();
 *
 *       // Perform the operation here.  There is no need to use critical
 *       // sections as we have all the microcontroller processing time.
 *       // During this time interrupts will still operate and the real
 *       // time kernel tick count will be maintained.
 *
 *       // ...
 *
 *       // The operation is complete.  Restart the kernel.  We want to force
 *       // a context switch - but there is no point if resuming the scheduler
 *       // caused a context switch already.
 *       if( !xTaskResumeAll () )
 *       {
 *            taskYIELD ();
 *       }
 *   }
 * }
 * @endcode
 * \defgroup xTaskResumeAll xTaskResumeAll
 * \ingroup SchedulerControl
 *//**
 * task. h
 * @code{c}
 * void vTaskSuspendAll( void );
 * @endcode
 *
 * Suspends the scheduler without disabling interrupts.  Context switches will
 * not occur while the scheduler is suspended.
 *
 * After calling vTaskSuspendAll () the calling task will continue to execute
 * without risk of being swapped out until a call to xTaskResumeAll () has been
 * made.
 *
 * API functions that have the potential to cause a context switch (for example,
 * xTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
 * is suspended.
 *
 * Example usage:
 * @code{c}
 * void vTask1( void * pvParameters )
 * {
 *   for( ;; )
 *   {
 *       // Task code goes here.
 *
 *       // ...
 *
 *       // At some point the task wants to perform a long operation during
 *       // which it does not want to get swapped out.  It cannot use
 *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
 *       // operation may cause interrupts to be missed - including the
 *       // ticks.
 *
 *       // Prevent the real time kernel swapping out the task.
 *       vTaskSuspendAll ();
 *
 *       // Perform the operation here.  There is no need to use critical
 *       // sections as we have all the microcontroller processing time.
 *       // During this time interrupts will still operate and the kernel
 *       // tick count will be maintained.
 *
 *       // ...
 *
 *       // The operation is complete.  Restart the kernel.
 *       xTaskResumeAll ();
 *   }
 * }
 * @endcode
 * \defgroup vTaskSuspendAll vTaskSuspendAll
 * \ingroup SchedulerControl
 *//**
 * task. h
 * @code{c}
 * void vTaskEndScheduler( void );
 * @endcode
 *
 * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
 * in place of DOS, implements this function.
 *
 * Stops the real time kernel tick.  All created tasks will be automatically
 * deleted and multitasking (either preemptive or cooperative) will
 * stop.  Execution then resumes from the point where vTaskStartScheduler ()
 * was called, as if vTaskStartScheduler () had just returned.
 *
 * See the demo application file main. c in the demo/PC directory for an
 * example that uses vTaskEndScheduler ().
 *
 * vTaskEndScheduler () requires an exit function to be defined within the
 * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
 * performs hardware specific operations such as stopping the kernel tick.
 *
 * vTaskEndScheduler () will cause all of the resources allocated by the
 * kernel to be freed - but will not free resources allocated by application
 * tasks.
 *
 * Example usage:
 * @code{c}
 * void vTaskCode( void * pvParameters )
 * {
 *   for( ;; )
 *   {
 *       // Task code goes here.
 *
 *       // At some point we want to end the real time kernel processing
 *       // so call ...
 *       vTaskEndScheduler ();
 *   }
 * }
 *
 * void vAFunction( void )
 * {
 *   // Create at least one task before starting the kernel.
 *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 *
 *   // Start the real time kernel with preemption.
 *   vTaskStartScheduler ();
 *
 *   // Will only get here when the vTaskCode () task has called
 *   // vTaskEndScheduler ().  When we get here we are back to single task
 *   // execution.
 * }
 * @endcode
 *
 * \defgroup vTaskEndScheduler vTaskEndScheduler
 * \ingroup SchedulerControl
 *//**
 * task. h
 * @code{c}
 * void vTaskStartScheduler( void );
 * @endcode
 *
 * Starts the real time kernel tick processing.  After calling the kernel
 * has control over which tasks are executed and when.
 *
 * See the demo application file main.c for an example of creating
 * tasks and starting the kernel.
 *
 * Example usage:
 * @code{c}
 * void vAFunction( void )
 * {
 *   // Create at least one task before starting the kernel.
 *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 *
 *   // Start the real time kernel with preemption.
 *   vTaskStartScheduler ();
 *
 *   // Will not get here unless a task calls vTaskEndScheduler ()
 * }
 * @endcode
 *
 * \defgroup vTaskStartScheduler vTaskStartScheduler
 * \ingroup SchedulerControl
 *//*-----------------------------------------------------------
* SCHEDULER CONTROL
*----------------------------------------------------------*//**
 * task. h
 * @code{c}
 * void xTaskResumeFromISR( TaskHandle_t xTaskToResume );
 * @endcode
 *
 * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
 * available.  See the configuration section for more information.
 *
 * An implementation of vTaskResume() that can be called from within an ISR.
 *
 * A task that has been suspended by one or more calls to vTaskSuspend ()
 * will be made available for running again by a single call to
 * xTaskResumeFromISR ().
 *
 * xTaskResumeFromISR() should not be used to synchronise a task with an
 * interrupt if there is a chance that the interrupt could arrive prior to the
 * task being suspended - as this can lead to interrupts being missed. Use of a
 * semaphore as a synchronisation mechanism would avoid this eventuality.
 *
 * @param xTaskToResume Handle to the task being readied.
 *
 * @return pdTRUE if resuming the task should result in a context switch,
 * otherwise pdFALSE. This is used by the ISR to determine if a context switch
 * may be required following the ISR.
 *
 * \defgroup vTaskResumeFromISR vTaskResumeFromISR
 * \ingroup TaskCtrl
 *//**
 * task. h
 * @code{c}
 * void vTaskResume( TaskHandle_t xTaskToResume );
 * @endcode
 *
 * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
 * See the configuration section for more information.
 *
 * Resumes a suspended task.
 *
 * A task that has been suspended by one or more calls to vTaskSuspend ()
 * will be made available for running again by a single call to
 * vTaskResume ().
 *
 * @param xTaskToResume Handle to the task being readied.
 *
 * Example usage:
 * @code{c}
 * void vAFunction( void )
 * {
 * TaskHandle_t xHandle;
 *
 *   // Create a task, storing the handle.
 *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
 *
 *   // ...
 *
 *   // Use the handle to suspend the created task.
 *   vTaskSuspend( xHandle );
 *
 *   // ...
 *
 *   // The created task will not run during this period, unless
 *   // another task calls vTaskResume( xHandle ).
 *
 *   //...
 *
 *
 *   // Resume the suspended task ourselves.
 *   vTaskResume( xHandle );
 *
 *   // The created task will once again get microcontroller processing
 *   // time in accordance with its priority within the system.
 * }
 * @endcode
 * \defgroup vTaskResume vTaskResume
 * \ingroup TaskCtrl
 *//**
 * task. h
 * @code{c}
 * void vTaskSuspend( TaskHandle_t xTaskToSuspend );
 * @endcode
 *
 * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
 * See the configuration section for more information.
 *
 * Suspend any task.  When suspended a task will never get any microcontroller
 * processing time, no matter what its priority.
 *
 * Calls to vTaskSuspend are not accumulative -
 * i.e. calling vTaskSuspend () twice on the same task still only requires one
 * call to vTaskResume () to ready the suspended task.
 *
 * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
 * handle will cause the calling task to be suspended.
 *
 * Example usage:
 * @code{c}
 * void vAFunction( void )
 * {
 * TaskHandle_t xHandle;
 *
 *   // Create a task, storing the handle.
 *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
 *
 *   // ...
 *
 *   // Use the handle to suspend the created task.
 *   vTaskSuspend( xHandle );
 *
 *   // ...
 *
 *   // The created task will not run during this period, unless
 *   // another task calls vTaskResume( xHandle ).
 *
 *   //...
 *
 *
 *   // Suspend ourselves.
 *   vTaskSuspend( NULL );
 *
 *   // We cannot get here unless another task calls vTaskResume
 *   // with our handle as the parameter.
 * }
 * @endcode
 * \defgroup vTaskSuspend vTaskSuspend
 * \ingroup TaskCtrl
 *//**
 * task. h
 * @code{c}
 * void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );
 * @endcode
 *
 * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
 * See the configuration section for more information.
 *
 * Set the priority of any task.
 *
 * A context switch will occur before the function returns if the priority
 * being set is higher than the currently executing task.
 *
 * @param xTask Handle to the task for which the priority is being set.
 * Passing a NULL handle results in the priority of the calling task being set.
 *
 * @param uxNewPriority The priority to which the task will be set.
 *
 * Example usage:
 * @code{c}
 * void vAFunction( void )
 * {
 * TaskHandle_t xHandle;
 *
 *   // Create a task, storing the handle.
 *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
 *
 *   // ...
 *
 *   // Use the handle to raise the priority of the created task.
 *   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
 *
 *   // ...
 *
 *   // Use a NULL handle to raise our priority to the same value.
 *   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
 * }
 * @endcode
 * \defgroup vTaskPrioritySet vTaskPrioritySet
 * \ingroup TaskCtrl
 *//**
 * task. h
 * @code{c}
 * void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );
 * @endcode
 *
 * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
 * available.  See the configuration section for more information.
 *
 * Populates a TaskStatus_t structure with information about a task.
 *
 * @param xTask Handle of the task being queried.  If xTask is NULL then
 * information will be returned about the calling task.
 *
 * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
 * filled with information about the task referenced by the handle passed using
 * the xTask parameter.
 *
 * @param xGetFreeStackSpace The TaskStatus_t structure contains a member to report
 * the stack high water mark of the task being queried.  Calculating the stack
 * high water mark takes a relatively long time, and can make the system
 * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
 * allow the high water mark checking to be skipped.  The high watermark value
 * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
 * not set to pdFALSE;
 *
 * @param eState The TaskStatus_t structure contains a member to report the
 * state of the task being queried.  Obtaining the task state is not as fast as
 * a simple assignment - so the eState parameter is provided to allow the state
 * information to be omitted from the TaskStatus_t structure.  To obtain state
 * information then set eState to eInvalid - otherwise the value passed in
 * eState will be reported as the task state in the TaskStatus_t structure.
 *
 * Example usage:
 * @code{c}
 * void vAFunction( void )
 * {
 * TaskHandle_t xHandle;
 * TaskStatus_t xTaskDetails;
 *
 *  // Obtain the handle of a task from its name.
 *  xHandle = xTaskGetHandle( "Task_Name" );
 *
 *  // Check the handle is not NULL.
 *  configASSERT( xHandle );
 *
 *  // Use the handle to obtain further information about the task.
 *  vTaskGetInfo( xHandle,
 *                &xTaskDetails,
 *                pdTRUE, // Include the high water mark in xTaskDetails.
 *                eInvalid ); // Include the task state in xTaskDetails.
 * }
 * @endcode
 * \defgroup vTaskGetInfo vTaskGetInfo
 * \ingroup TaskCtrl
 *//**
 * task. h
 * @code{c}
 * eTaskState eTaskGetState( TaskHandle_t xTask );
 * @endcode
 *
 * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
 * See the configuration section for more information.
 *
 * Obtain the state of any task.  States are encoded by the eTaskState
 * enumerated type.
 *
 * @param xTask Handle of the task to be queried.
 *
 * @return The state of xTask at the time the function was called.  Note the
 * state of the task might change between the function being called, and the
 * functions return value being tested by the calling task.
 *//**
 * task. h
 * @code{c}
 * UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask );
 * @endcode
 *
 * A version of uxTaskPriorityGet() that can be used from an ISR.
 *//**
 * task. h
 * @code{c}
 * UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );
 * @endcode
 *
 * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
 * See the configuration section for more information.
 *
 * Obtain the priority of any task.
 *
 * @param xTask Handle of the task to be queried.  Passing a NULL
 * handle results in the priority of the calling task being returned.
 *
 * @return The priority of xTask.
 *
 * Example usage:
 * @code{c}
 * void vAFunction( void )
 * {
 * TaskHandle_t xHandle;
 *
 *   // Create a task, storing the handle.
 *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
 *
 *   // ...
 *
 *   // Use the handle to obtain the priority of the created task.
 *   // It was created with tskIDLE_PRIORITY, but may have changed
 *   // it itself.
 *   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
 *   {
 *       // The task has changed it's priority.
 *   }
 *
 *   // ...
 *
 *   // Is our priority higher than the created task?
 *   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
 *   {
 *       // Our priority (obtained using NULL handle) is higher.
 *   }
 * }
 * @endcode
 * \defgroup uxTaskPriorityGet uxTaskPriorityGet
 * \ingroup TaskCtrl
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskAbortDelay( TaskHandle_t xTask );
 * @endcode
 *
 * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
 * function to be available.
 *
 * A task will enter the Blocked state when it is waiting for an event.  The
 * event it is waiting for can be a temporal event (waiting for a time), such
 * as when vTaskDelay() is called, or an event on an object, such as when
 * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
 * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
 * task will leave the Blocked state, and return from whichever function call
 * placed the task into the Blocked state.
 *
 * There is no 'FromISR' version of this function as an interrupt would need to
 * know which object a task was blocked on in order to know which actions to
 * take.  For example, if the task was blocked on a queue the interrupt handler
 * would then need to know if the queue was locked.
 *
 * @param xTask The handle of the task to remove from the Blocked state.
 *
 * @return If the task referenced by xTask was not in the Blocked state then
 * pdFAIL is returned.  Otherwise pdPASS is returned.
 *
 * \defgroup xTaskAbortDelay xTaskAbortDelay
 * \ingroup TaskCtrl
 *//*
 * vTaskDelayUntil() is the older version of xTaskDelayUntil() and does not
 * return a value.
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );
 * @endcode
 *
 * INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available.
 * See the configuration section for more information.
 *
 * Delay a task until a specified time.  This function can be used by periodic
 * tasks to ensure a constant execution frequency.
 *
 * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
 * cause a task to block for the specified number of ticks from the time vTaskDelay () is
 * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
 * execution frequency as the time between a task starting to execute and that task
 * calling vTaskDelay () may not be fixed [the task may take a different path though the
 * code between calls, or may get interrupted or preempted a different number of times
 * each time it executes].
 *
 * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
 * is called, xTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
 * unblock.
 *
 * The macro pdMS_TO_TICKS() can be used to calculate the number of ticks from a
 * time specified in milliseconds with a resolution of one tick period.
 *
 * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
 * task was last unblocked.  The variable must be initialised with the current time
 * prior to its first use (see the example below).  Following this the variable is
 * automatically updated within xTaskDelayUntil ().
 *
 * @param xTimeIncrement The cycle time period.  The task will be unblocked at
 * time *pxPreviousWakeTime + xTimeIncrement.  Calling xTaskDelayUntil with the
 * same xTimeIncrement parameter value will cause the task to execute with
 * a fixed interface period.
 *
 * @return Value which can be used to check whether the task was actually delayed.
 * Will be pdTRUE if the task way delayed and pdFALSE otherwise.  A task will not
 * be delayed if the next expected wake time is in the past.
 *
 * Example usage:
 * @code{c}
 * // Perform an action every 10 ticks.
 * void vTaskFunction( void * pvParameters )
 * {
 * TickType_t xLastWakeTime;
 * const TickType_t xFrequency = 10;
 * BaseType_t xWasDelayed;
 *
 *     // Initialise the xLastWakeTime variable with the current time.
 *     xLastWakeTime = xTaskGetTickCount ();
 *     for( ;; )
 *     {
 *         // Wait for the next cycle.
 *         xWasDelayed = xTaskDelayUntil( &xLastWakeTime, xFrequency );
 *
 *         // Perform action here. xWasDelayed value can be used to determine
 *         // whether a deadline was missed if the code here took too long.
 *     }
 * }
 * @endcode
 * \defgroup xTaskDelayUntil xTaskDelayUntil
 * \ingroup TaskCtrl
 *//**
 * task. h
 * @code{c}
 * void vTaskDelay( const TickType_t xTicksToDelay );
 * @endcode
 *
 * Delay a task for a given number of ticks.  The actual time that the
 * task remains blocked depends on the tick rate.  The constant
 * portTICK_PERIOD_MS can be used to calculate real time from the tick
 * rate - with the resolution of one tick period.
 *
 * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
 * See the configuration section for more information.
 *
 *
 * vTaskDelay() specifies a time at which the task wishes to unblock relative to
 * the time at which vTaskDelay() is called.  For example, specifying a block
 * period of 100 ticks will cause the task to unblock 100 ticks after
 * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
 * of controlling the frequency of a periodic task as the path taken through the
 * code, as well as other task and interrupt activity, will affect the frequency
 * at which vTaskDelay() gets called and therefore the time at which the task
 * next executes.  See xTaskDelayUntil() for an alternative API function designed
 * to facilitate fixed frequency execution.  It does this by specifying an
 * absolute time (rather than a relative time) at which the calling task should
 * unblock.
 *
 * @param xTicksToDelay The amount of time, in tick periods, that
 * the calling task should block.
 *
 * Example usage:
 *
 * void vTaskFunction( void * pvParameters )
 * {
 * // Block for 500ms.
 * const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
 *
 *   for( ;; )
 *   {
 *       // Simply toggle the LED every 500ms, blocking between each toggle.
 *       vToggleLED();
 *       vTaskDelay( xDelay );
 *   }
 * }
 *
 * \defgroup vTaskDelay vTaskDelay
 * \ingroup TaskCtrl
 *//*-----------------------------------------------------------
* TASK CONTROL API
*----------------------------------------------------------*//**
 * task. h
 * @code{c}
 * void vTaskDelete( TaskHandle_t xTaskToDelete );
 * @endcode
 *
 * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
 * See the configuration section for more information.
 *
 * Remove a task from the RTOS real time kernel's management.  The task being
 * deleted will be removed from all ready, blocked, suspended and event lists.
 *
 * NOTE:  The idle task is responsible for freeing the kernel allocated
 * memory from tasks that have been deleted.  It is therefore important that
 * the idle task is not starved of microcontroller processing time if your
 * application makes any calls to vTaskDelete ().  Memory allocated by the
 * task code is not automatically freed, and should be freed before the task
 * is deleted.
 *
 * See the demo application file death.c for sample code that utilises
 * vTaskDelete ().
 *
 * @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will
 * cause the calling task to be deleted.
 *
 * Example usage:
 * @code{c}
 * void vOtherFunction( void )
 * {
 * TaskHandle_t xHandle;
 *
 *   // Create the task, storing the handle.
 *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
 *
 *   // Use the handle to delete the task.
 *   vTaskDelete( xHandle );
 * }
 * @endcode
 * \defgroup vTaskDelete vTaskDelete
 * \ingroup Tasks
 *//**
 * task. h
 * @code{c}
 * void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );
 * @endcode
 *
 * Memory regions are assigned to a restricted task when the task is created by
 * a call to xTaskCreateRestricted().  These regions can be redefined using
 * vTaskAllocateMPURegions().
 *
 * @param xTask The handle of the task being updated.
 *
 * @param xRegions A pointer to a MemoryRegion_t structure that contains the
 * new memory region definitions.
 *
 * Example usage:
 * @code{c}
 * // Define an array of MemoryRegion_t structures that configures an MPU region
 * // allowing read/write access for 1024 bytes starting at the beginning of the
 * // ucOneKByte array.  The other two of the maximum 3 definable regions are
 * // unused so set to zero.
 * static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
 * {
 *  // Base address     Length      Parameters
 *  { ucOneKByte,       1024,       portMPU_REGION_READ_WRITE },
 *  { 0,                0,          0 },
 *  { 0,                0,          0 }
 * };
 *
 * void vATask( void *pvParameters )
 * {
 *  // This task was created such that it has access to certain regions of
 *  // memory as defined by the MPU configuration.  At some point it is
 *  // desired that these MPU regions are replaced with that defined in the
 *  // xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
 *  // for this purpose.  NULL is used as the task handle to indicate that this
 *  // function should modify the MPU regions of the calling task.
 *  vTaskAllocateMPURegions( NULL, xAltRegions );
 *
 *  // Now the task can continue its function, but from this point on can only
 *  // access its stack and the ucOneKByte array (unless any other statically
 *  // defined or shared regions have been declared elsewhere).
 * }
 * @endcode
 * \defgroup vTaskAllocateMPURegions vTaskAllocateMPURegions
 * \ingroup Tasks
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskCreateRestrictedStatic( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );
 * @endcode
 *
 * Only available when configSUPPORT_STATIC_ALLOCATION is set to 1.
 *
 * xTaskCreateRestrictedStatic() should only be used in systems that include an
 * MPU implementation.
 *
 * Internally, within the FreeRTOS implementation, tasks use two blocks of
 * memory.  The first block is used to hold the task's data structures.  The
 * second block is used by the task as its stack.  If a task is created using
 * xTaskCreateRestricted() then the stack is provided by the application writer,
 * and the memory used to hold the task's data structure is automatically
 * dynamically allocated inside the xTaskCreateRestricted() function.  If a task
 * is created using xTaskCreateRestrictedStatic() then the application writer
 * must provide the memory used to hold the task's data structures too.
 * xTaskCreateRestrictedStatic() therefore allows a memory protected task to be
 * created without using any dynamic memory allocation.
 *
 * @param pxTaskDefinition Pointer to a structure that contains a member
 * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
 * documentation) plus an optional stack buffer and the memory region
 * definitions.  If configSUPPORT_STATIC_ALLOCATION is set to 1 the structure
 * contains an additional member, which is used to point to a variable of type
 * StaticTask_t - which is then used to hold the task's data structure.
 *
 * @param pxCreatedTask Used to pass back a handle by which the created task
 * can be referenced.
 *
 * @return pdPASS if the task was successfully created and added to a ready
 * list, otherwise an error code defined in the file projdefs.h
 *
 * Example usage:
 * @code{c}
 * // Create an TaskParameters_t structure that defines the task to be created.
 * // The StaticTask_t variable is only included in the structure when
 * // configSUPPORT_STATIC_ALLOCATION is set to 1.  The PRIVILEGED_DATA macro can
 * // be used to force the variable into the RTOS kernel's privileged data area.
 * static PRIVILEGED_DATA StaticTask_t xTaskBuffer;
 * static const TaskParameters_t xCheckTaskParameters =
 * {
 *  vATask,     // pvTaskCode - the function that implements the task.
 *  "ATask",    // pcName - just a text name for the task to assist debugging.
 *  100,        // usStackDepth - the stack size DEFINED IN WORDS.
 *  NULL,       // pvParameters - passed into the task function as the function parameters.
 *  ( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
 *  cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
 *
 *  // xRegions - Allocate up to three separate memory regions for access by
 *  // the task, with appropriate access permissions.  Different processors have
 *  // different memory alignment requirements - refer to the FreeRTOS documentation
 *  // for full information.
 *  {
 *      // Base address                 Length  Parameters
 *      { cReadWriteArray,              32,     portMPU_REGION_READ_WRITE },
 *      { cReadOnlyArray,               32,     portMPU_REGION_READ_ONLY },
 *      { cPrivilegedOnlyAccessArray,   128,    portMPU_REGION_PRIVILEGED_READ_WRITE }
 *  }
 *
 *  &xTaskBuffer; // Holds the task's data structure.
 * };
 *
 * int main( void )
 * {
 * TaskHandle_t xHandle;
 *
 *  // Create a task from the const structure defined above.  The task handle
 *  // is requested (the second parameter is not NULL) but in this case just for
 *  // demonstration purposes as its not actually used.
 *  xTaskCreateRestrictedStatic( &xRegTest1Parameters, &xHandle );
 *
 *  // Start the scheduler.
 *  vTaskStartScheduler();
 *
 *  // Will only get here if there was insufficient memory to create the idle
 *  // and/or timer task.
 *  for( ;; );
 * }
 * @endcode
 * \defgroup xTaskCreateRestrictedStatic xTaskCreateRestrictedStatic
 * \ingroup Tasks
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );
 * @endcode
 *
 * Only available when configSUPPORT_DYNAMIC_ALLOCATION is set to 1.
 *
 * xTaskCreateRestricted() should only be used in systems that include an MPU
 * implementation.
 *
 * Create a new task and add it to the list of tasks that are ready to run.
 * The function parameters define the memory regions and associated access
 * permissions allocated to the task.
 *
 * See xTaskCreateRestrictedStatic() for a version that does not use any
 * dynamic memory allocation.
 *
 * @param pxTaskDefinition Pointer to a structure that contains a member
 * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
 * documentation) plus an optional stack buffer and the memory region
 * definitions.
 *
 * @param pxCreatedTask Used to pass back a handle by which the created task
 * can be referenced.
 *
 * @return pdPASS if the task was successfully created and added to a ready
 * list, otherwise an error code defined in the file projdefs.h
 *
 * Example usage:
 * @code{c}
 * // Create an TaskParameters_t structure that defines the task to be created.
 * static const TaskParameters_t xCheckTaskParameters =
 * {
 *  vATask,     // pvTaskCode - the function that implements the task.
 *  "ATask",    // pcName - just a text name for the task to assist debugging.
 *  100,        // usStackDepth - the stack size DEFINED IN WORDS.
 *  NULL,       // pvParameters - passed into the task function as the function parameters.
 *  ( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
 *  cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
 *
 *  // xRegions - Allocate up to three separate memory regions for access by
 *  // the task, with appropriate access permissions.  Different processors have
 *  // different memory alignment requirements - refer to the FreeRTOS documentation
 *  // for full information.
 *  {
 *      // Base address                 Length  Parameters
 *      { cReadWriteArray,              32,     portMPU_REGION_READ_WRITE },
 *      { cReadOnlyArray,               32,     portMPU_REGION_READ_ONLY },
 *      { cPrivilegedOnlyAccessArray,   128,    portMPU_REGION_PRIVILEGED_READ_WRITE }
 *  }
 * };
 *
 * int main( void )
 * {
 * TaskHandle_t xHandle;
 *
 *  // Create a task from the const structure defined above.  The task handle
 *  // is requested (the second parameter is not NULL) but in this case just for
 *  // demonstration purposes as its not actually used.
 *  xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
 *
 *  // Start the scheduler.
 *  vTaskStartScheduler();
 *
 *  // Will only get here if there was insufficient memory to create the idle
 *  // and/or timer task.
 *  for( ;; );
 * }
 * @endcode
 * \defgroup xTaskCreateRestricted xTaskCreateRestricted
 * \ingroup Tasks
 *//* configSUPPORT_STATIC_ALLOCATION *//**
 * task. h
 * @code{c}
 * TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
 *                               const char *pcName,
 *                               uint32_t ulStackDepth,
 *                               void *pvParameters,
 *                               UBaseType_t uxPriority,
 *                               StackType_t *puxStackBuffer,
 *                               StaticTask_t *pxTaskBuffer );
 * @endcode
 *
 * Create a new task and add it to the list of tasks that are ready to run.
 *
 * Internally, within the FreeRTOS implementation, tasks use two blocks of
 * memory.  The first block is used to hold the task's data structures.  The
 * second block is used by the task as its stack.  If a task is created using
 * xTaskCreate() then both blocks of memory are automatically dynamically
 * allocated inside the xTaskCreate() function.  (see
 * https://www.FreeRTOS.org/a00111.html).  If a task is created using
 * xTaskCreateStatic() then the application writer must provide the required
 * memory.  xTaskCreateStatic() therefore allows a task to be created without
 * using any dynamic memory allocation.
 *
 * @param pxTaskCode Pointer to the task entry function.  Tasks
 * must be implemented to never return (i.e. continuous loop).
 *
 * @param pcName A descriptive name for the task.  This is mainly used to
 * facilitate debugging.  The maximum length of the string is defined by
 * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
 *
 * @param ulStackDepth The size of the task stack specified as the number of
 * variables the stack can hold - not the number of bytes.  For example, if
 * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
 * will be allocated for stack storage.
 *
 * @param pvParameters Pointer that will be used as the parameter for the task
 * being created.
 *
 * @param uxPriority The priority at which the task will run.
 *
 * @param puxStackBuffer Must point to a StackType_t array that has at least
 * ulStackDepth indexes - the array will then be used as the task's stack,
 * removing the need for the stack to be allocated dynamically.
 *
 * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
 * then be used to hold the task's data structures, removing the need for the
 * memory to be allocated dynamically.
 *
 * @return If neither puxStackBuffer nor pxTaskBuffer are NULL, then the task
 * will be created and a handle to the created task is returned.  If either
 * puxStackBuffer or pxTaskBuffer are NULL then the task will not be created and
 * NULL is returned.
 *
 * Example usage:
 * @code{c}
 *
 *  // Dimensions of the buffer that the task being created will use as its stack.
 *  // NOTE:  This is the number of words the stack will hold, not the number of
 *  // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
 *  // then 400 bytes (100 * 32-bits) will be allocated.
 #define STACK_SIZE 200
 *
 *  // Structure that will hold the TCB of the task being created.
 *  StaticTask_t xTaskBuffer;
 *
 *  // Buffer that the task being created will use as its stack.  Note this is
 *  // an array of StackType_t variables.  The size of StackType_t is dependent on
 *  // the RTOS port.
 *  StackType_t xStack[ STACK_SIZE ];
 *
 *  // Function that implements the task being created.
 *  void vTaskCode( void * pvParameters )
 *  {
 *      // The parameter value is expected to be 1 as 1 is passed in the
 *      // pvParameters value in the call to xTaskCreateStatic().
 *      configASSERT( ( uint32_t ) pvParameters == 1UL );
 *
 *      for( ;; )
 *      {
 *          // Task code goes here.
 *      }
 *  }
 *
 *  // Function that creates a task.
 *  void vOtherFunction( void )
 *  {
 *      TaskHandle_t xHandle = NULL;
 *
 *      // Create the task without using any dynamic memory allocation.
 *      xHandle = xTaskCreateStatic(
 *                    vTaskCode,       // Function that implements the task.
 *                    "NAME",          // Text name for the task.
 *                    STACK_SIZE,      // Stack size in words, not bytes.
 *                    ( void * ) 1,    // Parameter passed into the task.
 *                    tskIDLE_PRIORITY,// Priority at which the task is created.
 *                    xStack,          // Array to use as the task's stack.
 *                    &xTaskBuffer );  // Variable to hold the task's data structure.
 *
 *      // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
 *      // been created, and xHandle will be the task's handle.  Use the handle
 *      // to suspend the task.
 *      vTaskSuspend( xHandle );
 *  }
 * @endcode
 * \defgroup xTaskCreateStatic xTaskCreateStatic
 * \ingroup Tasks
 *//**
 * task. h
 * @code{c}
 * BaseType_t xTaskCreate(
 *                            TaskFunction_t pxTaskCode,
 *                            const char *pcName,
 *                            configSTACK_DEPTH_TYPE usStackDepth,
 *                            void *pvParameters,
 *                            UBaseType_t uxPriority,
 *                            TaskHandle_t *pxCreatedTask
 *                        );
 * @endcode
 *
 * Create a new task and add it to the list of tasks that are ready to run.
 *
 * Internally, within the FreeRTOS implementation, tasks use two blocks of
 * memory.  The first block is used to hold the task's data structures.  The
 * second block is used by the task as its stack.  If a task is created using
 * xTaskCreate() then both blocks of memory are automatically dynamically
 * allocated inside the xTaskCreate() function.  (see
 * https://www.FreeRTOS.org/a00111.html).  If a task is created using
 * xTaskCreateStatic() then the application writer must provide the required
 * memory.  xTaskCreateStatic() therefore allows a task to be created without
 * using any dynamic memory allocation.
 *
 * See xTaskCreateStatic() for a version that does not use any dynamic memory
 * allocation.
 *
 * xTaskCreate() can only be used to create a task that has unrestricted
 * access to the entire microcontroller memory map.  Systems that include MPU
 * support can alternatively create an MPU constrained task using
 * xTaskCreateRestricted().
 *
 * @param pxTaskCode Pointer to the task entry function.  Tasks
 * must be implemented to never return (i.e. continuous loop).
 *
 * @param pcName A descriptive name for the task.  This is mainly used to
 * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
 * is 16.
 *
 * @param usStackDepth The size of the task stack specified as the number of
 * variables the stack can hold - not the number of bytes.  For example, if
 * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
 * will be allocated for stack storage.
 *
 * @param pvParameters Pointer that will be used as the parameter for the task
 * being created.
 *
 * @param uxPriority The priority at which the task should run.  Systems that
 * include MPU support can optionally create tasks in a privileged (system)
 * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
 * example, to create a privileged task at priority 2 the uxPriority parameter
 * should be set to ( 2 | portPRIVILEGE_BIT ).
 *
 * @param pxCreatedTask Used to pass back a handle by which the created task
 * can be referenced.
 *
 * @return pdPASS if the task was successfully created and added to a ready
 * list, otherwise an error code defined in the file projdefs.h
 *
 * Example usage:
 * @code{c}
 * // Task to be created.
 * void vTaskCode( void * pvParameters )
 * {
 *   for( ;; )
 *   {
 *       // Task code goes here.
 *   }
 * }
 *
 * // Function that creates a task.
 * void vOtherFunction( void )
 * {
 * static uint8_t ucParameterToPass;
 * TaskHandle_t xHandle = NULL;
 *
 *   // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
 *   // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
 *   // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
 *   // the new task attempts to access it.
 *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
 *   configASSERT( xHandle );
 *
 *   // Use the handle to delete the task.
 *   if( xHandle != NULL )
 *   {
 *      vTaskDelete( xHandle );
 *   }
 * }
 * @endcode
 * \defgroup xTaskCreate xTaskCreate
 * \ingroup Tasks
 *//*-----------------------------------------------------------
* TASK CREATION API
*----------------------------------------------------------*//* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
 * 0 to generate more optimal code when configASSERT() is defined as the constant
 * is used in assert() statements. *//**
 * task. h
 *
 * Macro to enable microcontroller interrupts.
 *
 * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
 * \ingroup SchedulerControl
 *//**
 * task. h
 *
 * Macro to disable all maskable interrupts.
 *
 * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
 * \ingroup SchedulerControl
 *//**
 * task. h
 *
 * Macro to mark the end of a critical code region.  Preemptive context
 * switches cannot occur when in a critical region.
 *
 * NOTE: This may alter the stack (depending on the portable implementation)
 * so must be used with care!
 *
 * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
 * \ingroup SchedulerControl
 *//**
 * task. h
 *
 * Macro to mark the start of a critical code region.  Preemptive context
 * switches cannot occur when in a critical region.
 *
 * NOTE: This may alter the stack (depending on the portable implementation)
 * so must be used with care!
 *
 * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
 * \ingroup SchedulerControl
 *//**
 * task. h
 *
 * Macro for forcing a context switch.
 *
 * \defgroup taskYIELD taskYIELD
 * \ingroup SchedulerControl
 *//**
 * Defines the priority used by the idle task.  This must not be modified.
 *
 * \ingroup TaskUtils
 *//* INCLUDE_vTaskSuspend *//* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. *//* Enter a sleep mode that will not last any longer than the expected idle time. *//* A task has been made ready or a context switch pended since portSUPPRESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. *//* Possible return values for eTaskConfirmSleepModeStatus(). *//* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. *//* Points to the end address of the task's stack area. *//* Points to the top address of the task's stack area. *//* Points to the lowest address of the task's stack area. *//* The total run time allocated to the task so far, as defined by the run time stats clock.  See https://www.FreeRTOS.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. *//* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. *//* The priority at which the task was running (may be inherited) when the structure was populated. *//* The state in which the task existed when the structure was populated. *//* A number unique to the task. *//* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! *//* The handle of the task to which the rest of the information in the structure relates. *//* Used with the uxTaskGetSystemState() function to return the state of each task
 * in the system. *//*
 * Parameters required to create an MPU protected task.
 *//*
 * Defines the memory ranges allocated to the task when an MPU is used.
 *//*
 * Used internally only.
 *//* Set the task's notification value if the previous value has been read by the task. *//* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. *//* Increment the task's notification value. *//* Set bits in the task's notification value. *//* Notify the task without updating its notify value. *//* Actions that can be performed when vTaskNotify() is called. *//* Used as an 'invalid state' value. *//* The task being queried has been deleted, but its TCB has not yet been freed. *//* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. *//* The task being queried is in the Blocked state. *//* The task being queried is in a ready or pending ready list. *//* A task is querying the state of itself, so must be running. *//* Task states returned by eTaskGetState. *//*
 * Defines the prototype to which the application task hook function must
 * conform.
 *//* The old naming convention is used to prevent breaking kernel aware debuggers. *//**
 * task. h
 *
 * Type by which tasks are referenced.  For example, a call to xTaskCreate
 * returns (via a pointer parameter) an TaskHandle_t variable that can then
 * be used as a parameter to vTaskDelete to delete the task.
 *
 * \defgroup TaskHandle_t TaskHandle_t
 * \ingroup Tasks
 *//* The direct to task notification feature used to have only a single notification
 * per task.  Now there is an array of notifications per task that is dimensioned by
 * configTASK_NOTIFICATION_ARRAY_ENTRIES.  For backward compatibility, any use of the
 * original direct to task notification defaults to using the first index in the
 * array. *//* MPU region parameters passed in ulParameters
 * of MemoryRegion_t struct. *//*
 * If tskKERNEL_VERSION_NUMBER ends with + it represents the version in development
 * after the numbered release.
 *
 * The tskKERNEL_VERSION_MAJOR, tskKERNEL_VERSION_MINOR, tskKERNEL_VERSION_BUILD
 * values will reflect the last released version number.
 *//*-----------------------------------------------------------
* MACROS AND DEFINITIONS
*----------------------------------------------------------*/pxTimeOutxTicksToJumpxTaskuxHandlepxMutexHolderuxHighestPriorityWaitingTaskpxEventListItempxEventListxTicksToWaitxWaitIndefinitelyxTicksToCatchUppxTicksToWaituxIndexToClearulBitsToClearuxIndexToWaitOnxClearCountOnExitxTaskToNotifyuxIndexToNotifypxHigherPriorityTaskWokenulBitsToClearOnEntryulBitsToClearOnExitpulNotificationValueulValueeActionpulPreviousNotificationValuepcWriteBufferpxTaskStatusArrayuxArraySizepulTotalRunTimepvParameterxTaskToQueryxIndexxTaskToSetpvValuepxHookFunctionpcNameToQueryxTaskToResumexTaskToSuspenduxNewPrioritypxTaskStatusxGetFreeStackSpaceeStatepxPreviousWakeTimexTimeIncrementxTicksToDelayxTaskToDeletepxRegionspxTaskDefinitionpxCreatedTaskpxTaskCode__va_copy(d,s)__builtin_va_copy(d,s)va_copy(d,s)va_arg(v,l)__builtin_va_arg(v,l)va_end(v)__builtin_va_end(v)va_start(v,l)__builtin_va_start(v,l)/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/main.c<FreeRTOSConfig.h><task.h><FreeRTOS.h>argpcFormatvolatile unsigned longlooping0LUvApplicationIdleHook/* Use the debugger to set ul to a non-zero value in order to step out
         *      of this function to determine why it was called. *//Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/mpu_demo.cavHandleMemoryFaultulPCusOffendingInstructionvolatile uint8_t[32]unsigned char[32]SHARED_MEMORY_SIZEuint16_t *634880xF8000x001F0x001E0x001DxROAccessTaskStack40961024 * sizeof( StackType_t )xRWAccessTaskStackxROAccessTaskParametersROAccess"ROAccess"char[9]uint8_t[32]3355443226843545630198988850331648318767104xRWAccessTaskParametersRWAccess"RWAccess"TaskParameters_t *prvRWAccessTask10001000000pdMS_TO_TICKS( 1000 )prvROAccessTaskucValucROTaskFaultTrackerucSharedMemory( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 )/* This is an unexpected fault - loop forever. *//* Mark the fault as handled. *//* Save the new program counter on the stack. *//* Since the offending instruction is a 16-bit instruction,
             * increment the program counter by 2 to move to the next
             * instruction. *//* Since the offending instruction is a 32-bit instruction,
             * increment the program counter by 4 to move to the next
             * instruction. *//* Determine if the offending instruction is a 32-bit instruction or
         * a 16-bit instruction. *//* Extract bits[15:11] of the offending instruction. *//* From ARM docs:
         * If the value of bits[15:11] of the halfword being decoded is one of
         * the following, the halfword is the first halfword of a 32-bit
         * instruction:
         * - 0b11101.
         * - 0b11110.
         * - 0b11111.
         * Otherwise, the halfword is a 16-bit instruction.
         *//* Read the offending instruction. *//* Read program counter. *//* Is this an expected fault? *//* Create an unprivileged task with RW access to ucSharedMemory. *//* Create an unprivileged task with RO access to ucSharedMemory. *//**
 * Since stack of a task is protected using MPU, it must satisfy MPU
 * requirements as mentioned at the top of this file.
 *//* Wait for a second. *//* This task has RW access to ucSharedMemory and therefore can write to
         * it. *//* Unused parameters. *//* #if( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) *//* Ensure that the above line did generate MemFault and the fault
             * handler did clear the  ucROTaskFaultTracker[ 0 ]. *//* The following must result in Memory Fault since the task is now
             * running unprivileged. *//* Now the task is running unprivileged and therefore an attempt to
             * write to ucSharedMemory will result in a Memory Fault. Set
             * ucROTaskFaultTracker[ 0 ] to 1 to tell the Memory Fault Handler
             * that this is an expected fault. The handler will then be able to
             * recover from this fault gracefully by jumping to the next
             * instruction.*//* Lower down the privilege. *//* At this point, the task is running privileged. The following
             * access must not result in Memory Fault. If something goes
             * wrong and we do get a fault, the execution will stop in fault
             * handler as ucROTaskFaultTracker[ 0 ] is not set (i.e.
             * un-expected fault). *//* Generate an SVC to raise the privilege. Since
             * configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY is not enabled, the
             * task will be able to escalate privilege. *//* if ( configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY == 1 ) *//*configASSERT( ucROTaskFaultTracker[ 0 ] == 0 ); *//* The following must still result in Memory Fault since the task
             * is still running unprivileged. *//* Set ucROTaskFaultTracker[ 0 ] to 1 to tell the Memory Fault
             * Handler that this is an expected fault. The handler will then be
             * able to recover from this fault gracefully by jumping to the
             * next instruction.*//* Generate an SVC to raise the privilege. Since privilege
             * escalation is only allowed from kernel code, this request must
             * get rejected and the task must remain unprivileged. As a result,
             * trying to write to ucSharedMemory will still result in Memory
             * Fault. *//* Ensure that the above line did generate MemFault and the fault
         * handler did clear the  ucROTaskFaultTracker[ 0 ]. *//* Illegal access to generate Memory Fault. *//* Since this task has Read Only access to the ucSharedMemory region,
         * writing to it results in Memory Fault. Set ucROTaskFaultTracker[ 0 ]
         * to 1 to tell the Memory Fault Handler that this is an expected fault.
         * The handler will recover from this fault gracefully by jumping to the
         * next instruction. *//* Silent compiler warnings about unused variables. *//* This task has RO access to ucSharedMemory and therefore it can read
         * it but cannot modify it. *//**
 * @brief Implements the task which has Read Write access to the memory region
 * ucSharedMemory.
 *
 * @param pvParameters[in] Parameters as passed during task creation.
 *//**
 * @brief Implements the task which has Read Only access to the memory region
 * ucSharedMemory.
 *
 * @param pvParameters[in] Parameters as passed during task creation.
 *//**
 * @brief Memory region used to track Memory Fault intentionally caused by the
 * RO Access task.
 *
 * RO Access task sets ucROTaskFaultTracker[ 0 ] to 1 before accessing illegal
 * memory. Illegal memory access causes Memory Fault and the fault handler
 * checks ucROTaskFaultTracker[ 0 ] to see if this is an expected fault. We
 * recover gracefully from an expected fault by jumping to the next instruction.
 *
 * @note We are declaring a region of 32 bytes even though we need only one.
 * The reason is that the smallest supported MPU region size is 32 bytes.
 *//**
 * @brief Memory region shared between two tasks.
 *//**
 * @brief Size of the shared memory region.
 *//** ARMv7 MPU Details:
 *
 * - ARMv7 MPU requires that the size of a MPU region is a power of 2.
 * - Smallest supported region size is 32 bytes.
 * - Start address of a region must be aligned to an integer multiple of the
 *   region size. For example, if the region size is 4 KB(0x1000), the starting
 *   address must be N x 0x1000, where N is an integer.
 *//* FreeRTOS includes. *//Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/syscall.c_getpid_kill_exit_isatty_lseek_sbrkprev_heap_end4294967295( void * ) -1todoUART0_ADDR( ( UART_t * ) ( 0x40004000 ) )1073758208UART_t *_fstatUART_CTRL_TX_ENUART_theap_endg_ulBase_heap_top_heap_bottomUART_CTRL_RX_EN( 1 << 1 )( 1 << 0 )UART_STATE_TXFULLUART_DR(baseaddr)( *( unsigned int * ) ( baseaddr ) )/**
 * @brief function called by malloc and friends to reserve memory on the heap
 * @param [in] incr the amount of bytes to increase or decrease
 * @returns the previous top of the heap
 * @note uses a global variable <b>heap_end</b> to keep track of the previous top
 *//**
 * @brief  Write bytes to the UART channel to be displayed on the command line
 *         with qemu
 * @param [in] file  ignored
 * @param [in] buf   buffer to send
 * @param [in] len   length of the buffer
 * @returns the number of bytes written
 *//**
 * @brief not used anywhere in the code
 * @todo  implement if necessary
 *
 *//**
 * @brief initializes the UART emulated hardware
 */pidsigexit_codefiledesoffsetwhencefdincrfilebuf__attribute__( ( section( "freertos_system_calls" ) ) )__attribute__( ( section( "privileged_functions" ) ) )/Users/mac/Downloads/FreeRTOS/Source/include/event_groups.h"timers.h"EventGroupDef_t *EventGroupHandle_tEventBits_txEventGroupGetBits(xEventGroup)xEventGroupClearBits( ( xEventGroup ), 0 )EVENT_GROUPS_HvEventGroupSetNumberprivileged_functionschar[21]uxEventGroupGetNumbervEventGroupClearBitsCallbackvEventGroupSetBitsCallbackxEventGroupGetBitsFromISRconst EventBits_txEventGroupSetBitsFromISRxEventGroupClearBitsFromISRStaticEventGroup_t *xSTATIC_EVENT_GROUP *EventGroupDef_t/* EVENT_GROUPS_H *//* For internal use only. *//**
 * event_groups.h
 * @code{c}
 *  void xEventGroupDelete( EventGroupHandle_t xEventGroup );
 * @endcode
 *
 * Delete an event group that was previously created by a call to
 * xEventGroupCreate().  Tasks that are blocked on the event group will be
 * unblocked and obtain 0 as the event group's value.
 *
 * @param xEventGroup The event group being deleted.
 *//**
 * event_groups.h
 * @code{c}
 *  EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup );
 * @endcode
 *
 * A version of xEventGroupGetBits() that can be called from an ISR.
 *
 * @param xEventGroup The event group being queried.
 *
 * @return The event group bits at the time xEventGroupGetBitsFromISR() was called.
 *
 * \defgroup xEventGroupGetBitsFromISR xEventGroupGetBitsFromISR
 * \ingroup EventGroup
 *//**
 * event_groups.h
 * @code{c}
 *  EventBits_t xEventGroupGetBits( EventGroupHandle_t xEventGroup );
 * @endcode
 *
 * Returns the current value of the bits in an event group.  This function
 * cannot be used from an interrupt.
 *
 * @param xEventGroup The event group being queried.
 *
 * @return The event group bits at the time xEventGroupGetBits() was called.
 *
 * \defgroup xEventGroupGetBits xEventGroupGetBits
 * \ingroup EventGroup
 *//**
 * event_groups.h
 * @code{c}
 *  EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,
 *                                  const EventBits_t uxBitsToSet,
 *                                  const EventBits_t uxBitsToWaitFor,
 *                                  TickType_t xTicksToWait );
 * @endcode
 *
 * Atomically set bits within an event group, then wait for a combination of
 * bits to be set within the same event group.  This functionality is typically
 * used to synchronise multiple tasks, where each task has to wait for the other
 * tasks to reach a synchronisation point before proceeding.
 *
 * This function cannot be used from an interrupt.
 *
 * The function will return before its block time expires if the bits specified
 * by the uxBitsToWait parameter are set, or become set within that time.  In
 * this case all the bits specified by uxBitsToWait will be automatically
 * cleared before the function returns.
 *
 * @param xEventGroup The event group in which the bits are being tested.  The
 * event group must have previously been created using a call to
 * xEventGroupCreate().
 *
 * @param uxBitsToSet The bits to set in the event group before determining
 * if, and possibly waiting for, all the bits specified by the uxBitsToWait
 * parameter are set.
 *
 * @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
 * inside the event group.  For example, to wait for bit 0 and bit 2 set
 * uxBitsToWaitFor to 0x05.  To wait for bits 0 and bit 1 and bit 2 set
 * uxBitsToWaitFor to 0x07.  Etc.
 *
 * @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
 * for all of the bits specified by uxBitsToWaitFor to become set.
 *
 * @return The value of the event group at the time either the bits being waited
 * for became set, or the block time expired.  Test the return value to know
 * which bits were set.  If xEventGroupSync() returned because its timeout
 * expired then not all the bits being waited for will be set.  If
 * xEventGroupSync() returned because all the bits it was waiting for were
 * set then the returned value is the event group value before any bits were
 * automatically cleared.
 *
 * Example usage:
 * @code{c}
 * // Bits used by the three tasks.
 * #define TASK_0_BIT     ( 1 << 0 )
 * #define TASK_1_BIT     ( 1 << 1 )
 * #define TASK_2_BIT     ( 1 << 2 )
 *
 * #define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )
 *
 * // Use an event group to synchronise three tasks.  It is assumed this event
 * // group has already been created elsewhere.
 * EventGroupHandle_t xEventBits;
 *
 * void vTask0( void *pvParameters )
 * {
 * EventBits_t uxReturn;
 * TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;
 *
 *   for( ;; )
 *   {
 *      // Perform task functionality here.
 *
 *      // Set bit 0 in the event flag to note this task has reached the
 *      // sync point.  The other two tasks will set the other two bits defined
 *      // by ALL_SYNC_BITS.  All three tasks have reached the synchronisation
 *      // point when all the ALL_SYNC_BITS are set.  Wait a maximum of 100ms
 *      // for this to happen.
 *      uxReturn = xEventGroupSync( xEventBits, TASK_0_BIT, ALL_SYNC_BITS, xTicksToWait );
 *
 *      if( ( uxReturn & ALL_SYNC_BITS ) == ALL_SYNC_BITS )
 *      {
 *          // All three tasks reached the synchronisation point before the call
 *          // to xEventGroupSync() timed out.
 *      }
 *  }
 * }
 *
 * void vTask1( void *pvParameters )
 * {
 *   for( ;; )
 *   {
 *      // Perform task functionality here.
 *
 *      // Set bit 1 in the event flag to note this task has reached the
 *      // synchronisation point.  The other two tasks will set the other two
 *      // bits defined by ALL_SYNC_BITS.  All three tasks have reached the
 *      // synchronisation point when all the ALL_SYNC_BITS are set.  Wait
 *      // indefinitely for this to happen.
 *      xEventGroupSync( xEventBits, TASK_1_BIT, ALL_SYNC_BITS, portMAX_DELAY );
 *
 *      // xEventGroupSync() was called with an indefinite block time, so
 *      // this task will only reach here if the synchronisation was made by all
 *      // three tasks, so there is no need to test the return value.
 *   }
 * }
 *
 * void vTask2( void *pvParameters )
 * {
 *   for( ;; )
 *   {
 *      // Perform task functionality here.
 *
 *      // Set bit 2 in the event flag to note this task has reached the
 *      // synchronisation point.  The other two tasks will set the other two
 *      // bits defined by ALL_SYNC_BITS.  All three tasks have reached the
 *      // synchronisation point when all the ALL_SYNC_BITS are set.  Wait
 *      // indefinitely for this to happen.
 *      xEventGroupSync( xEventBits, TASK_2_BIT, ALL_SYNC_BITS, portMAX_DELAY );
 *
 *      // xEventGroupSync() was called with an indefinite block time, so
 *      // this task will only reach here if the synchronisation was made by all
 *      // three tasks, so there is no need to test the return value.
 *  }
 * }
 *
 * @endcode
 * \defgroup xEventGroupSync xEventGroupSync
 * \ingroup EventGroup
 *//**
 * event_groups.h
 * @code{c}
 *  BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken );
 * @endcode
 *
 * A version of xEventGroupSetBits() that can be called from an interrupt.
 *
 * Setting bits in an event group is not a deterministic operation because there
 * are an unknown number of tasks that may be waiting for the bit or bits being
 * set.  FreeRTOS does not allow nondeterministic operations to be performed in
 * interrupts or from critical sections.  Therefore xEventGroupSetBitsFromISR()
 * sends a message to the timer task to have the set operation performed in the
 * context of the timer task - where a scheduler lock is used in place of a
 * critical section.
 *
 * @param xEventGroup The event group in which the bits are to be set.
 *
 * @param uxBitsToSet A bitwise value that indicates the bit or bits to set.
 * For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
 * and bit 0 set uxBitsToSet to 0x09.
 *
 * @param pxHigherPriorityTaskWoken As mentioned above, calling this function
 * will result in a message being sent to the timer daemon task.  If the
 * priority of the timer daemon task is higher than the priority of the
 * currently running task (the task the interrupt interrupted) then
 * *pxHigherPriorityTaskWoken will be set to pdTRUE by
 * xEventGroupSetBitsFromISR(), indicating that a context switch should be
 * requested before the interrupt exits.  For that reason
 * *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
 * example code below.
 *
 * @return If the request to execute the function was posted successfully then
 * pdPASS is returned, otherwise pdFALSE is returned.  pdFALSE will be returned
 * if the timer service queue was full.
 *
 * Example usage:
 * @code{c}
 * #define BIT_0 ( 1 << 0 )
 * #define BIT_4 ( 1 << 4 )
 *
 * // An event group which it is assumed has already been created by a call to
 * // xEventGroupCreate().
 * EventGroupHandle_t xEventGroup;
 *
 * void anInterruptHandler( void )
 * {
 * BaseType_t xHigherPriorityTaskWoken, xResult;
 *
 *      // xHigherPriorityTaskWoken must be initialised to pdFALSE.
 *      xHigherPriorityTaskWoken = pdFALSE;
 *
 *      // Set bit 0 and bit 4 in xEventGroup.
 *      xResult = xEventGroupSetBitsFromISR(
 *                          xEventGroup,    // The event group being updated.
 *                          BIT_0 | BIT_4   // The bits being set.
 *                          &xHigherPriorityTaskWoken );
 *
 *      // Was the message posted successfully?
 *      if( xResult == pdPASS )
 *      {
 *          // If xHigherPriorityTaskWoken is now set to pdTRUE then a context
 *          // switch should be requested.  The macro used is port specific and
 *          // will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -
 *          // refer to the documentation page for the port being used.
 *          portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 *      }
 * }
 * @endcode
 * \defgroup xEventGroupSetBitsFromISR xEventGroupSetBitsFromISR
 * \ingroup EventGroup
 *//**
 * event_groups.h
 * @code{c}
 *  EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
 * @endcode
 *
 * Set bits within an event group.
 * This function cannot be called from an interrupt.  xEventGroupSetBitsFromISR()
 * is a version that can be called from an interrupt.
 *
 * Setting bits in an event group will automatically unblock tasks that are
 * blocked waiting for the bits.
 *
 * @param xEventGroup The event group in which the bits are to be set.
 *
 * @param uxBitsToSet A bitwise value that indicates the bit or bits to set.
 * For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
 * and bit 0 set uxBitsToSet to 0x09.
 *
 * @return The value of the event group at the time the call to
 * xEventGroupSetBits() returns.  There are two reasons why the returned value
 * might have the bits specified by the uxBitsToSet parameter cleared.  First,
 * if setting a bit results in a task that was waiting for the bit leaving the
 * blocked state then it is possible the bit will be cleared automatically
 * (see the xClearBitOnExit parameter of xEventGroupWaitBits()).  Second, any
 * unblocked (or otherwise Ready state) task that has a priority above that of
 * the task that called xEventGroupSetBits() will execute and may change the
 * event group value before the call to xEventGroupSetBits() returns.
 *
 * Example usage:
 * @code{c}
 * #define BIT_0 ( 1 << 0 )
 * #define BIT_4 ( 1 << 4 )
 *
 * void aFunction( EventGroupHandle_t xEventGroup )
 * {
 * EventBits_t uxBits;
 *
 *      // Set bit 0 and bit 4 in xEventGroup.
 *      uxBits = xEventGroupSetBits(
 *                          xEventGroup,    // The event group being updated.
 *                          BIT_0 | BIT_4 );// The bits being set.
 *
 *      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
 *      {
 *          // Both bit 0 and bit 4 remained set when the function returned.
 *      }
 *      else if( ( uxBits & BIT_0 ) != 0 )
 *      {
 *          // Bit 0 remained set when the function returned, but bit 4 was
 *          // cleared.  It might be that bit 4 was cleared automatically as a
 *          // task that was waiting for bit 4 was removed from the Blocked
 *          // state.
 *      }
 *      else if( ( uxBits & BIT_4 ) != 0 )
 *      {
 *          // Bit 4 remained set when the function returned, but bit 0 was
 *          // cleared.  It might be that bit 0 was cleared automatically as a
 *          // task that was waiting for bit 0 was removed from the Blocked
 *          // state.
 *      }
 *      else
 *      {
 *          // Neither bit 0 nor bit 4 remained set.  It might be that a task
 *          // was waiting for both of the bits to be set, and the bits were
 *          // cleared as the task left the Blocked state.
 *      }
 * }
 * @endcode
 * \defgroup xEventGroupSetBits xEventGroupSetBits
 * \ingroup EventGroup
 *//**
 * event_groups.h
 * @code{c}
 *  BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
 * @endcode
 *
 * A version of xEventGroupClearBits() that can be called from an interrupt.
 *
 * Setting bits in an event group is not a deterministic operation because there
 * are an unknown number of tasks that may be waiting for the bit or bits being
 * set.  FreeRTOS does not allow nondeterministic operations to be performed
 * while interrupts are disabled, so protects event groups that are accessed
 * from tasks by suspending the scheduler rather than disabling interrupts.  As
 * a result event groups cannot be accessed directly from an interrupt service
 * routine.  Therefore xEventGroupClearBitsFromISR() sends a message to the
 * timer task to have the clear operation performed in the context of the timer
 * task.
 *
 * @note If this function returns pdPASS then the timer task is ready to run
 * and a portYIELD_FROM_ISR(pdTRUE) should be executed to perform the needed
 * clear on the event group.  This behavior is different from
 * xEventGroupSetBitsFromISR because the parameter xHigherPriorityTaskWoken is
 * not present.
 *
 * @param xEventGroup The event group in which the bits are to be cleared.
 *
 * @param uxBitsToClear A bitwise value that indicates the bit or bits to clear.
 * For example, to clear bit 3 only, set uxBitsToClear to 0x08.  To clear bit 3
 * and bit 0 set uxBitsToClear to 0x09.
 *
 * @return If the request to execute the function was posted successfully then
 * pdPASS is returned, otherwise pdFALSE is returned.  pdFALSE will be returned
 * if the timer service queue was full.
 *
 * Example usage:
 * @code{c}
 * #define BIT_0 ( 1 << 0 )
 * #define BIT_4 ( 1 << 4 )
 *
 * // An event group which it is assumed has already been created by a call to
 * // xEventGroupCreate().
 * EventGroupHandle_t xEventGroup;
 *
 * void anInterruptHandler( void )
 * {
 *      // Clear bit 0 and bit 4 in xEventGroup.
 *      xResult = xEventGroupClearBitsFromISR(
 *                          xEventGroup,     // The event group being updated.
 *                          BIT_0 | BIT_4 ); // The bits being set.
 *
 *      if( xResult == pdPASS )
 *      {
 *          // The message was posted successfully.
 *          portYIELD_FROM_ISR(pdTRUE);
 *      }
 * }
 * @endcode
 * \defgroup xEventGroupClearBitsFromISR xEventGroupClearBitsFromISR
 * \ingroup EventGroup
 *//**
 * event_groups.h
 * @code{c}
 *  EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear );
 * @endcode
 *
 * Clear bits within an event group.  This function cannot be called from an
 * interrupt.
 *
 * @param xEventGroup The event group in which the bits are to be cleared.
 *
 * @param uxBitsToClear A bitwise value that indicates the bit or bits to clear
 * in the event group.  For example, to clear bit 3 only, set uxBitsToClear to
 * 0x08.  To clear bit 3 and bit 0 set uxBitsToClear to 0x09.
 *
 * @return The value of the event group before the specified bits were cleared.
 *
 * Example usage:
 * @code{c}
 * #define BIT_0 ( 1 << 0 )
 * #define BIT_4 ( 1 << 4 )
 *
 * void aFunction( EventGroupHandle_t xEventGroup )
 * {
 * EventBits_t uxBits;
 *
 *      // Clear bit 0 and bit 4 in xEventGroup.
 *      uxBits = xEventGroupClearBits(
 *                              xEventGroup,    // The event group being updated.
 *                              BIT_0 | BIT_4 );// The bits being cleared.
 *
 *      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
 *      {
 *          // Both bit 0 and bit 4 were set before xEventGroupClearBits() was
 *          // called.  Both will now be clear (not set).
 *      }
 *      else if( ( uxBits & BIT_0 ) != 0 )
 *      {
 *          // Bit 0 was set before xEventGroupClearBits() was called.  It will
 *          // now be clear.
 *      }
 *      else if( ( uxBits & BIT_4 ) != 0 )
 *      {
 *          // Bit 4 was set before xEventGroupClearBits() was called.  It will
 *          // now be clear.
 *      }
 *      else
 *      {
 *          // Neither bit 0 nor bit 4 were set in the first place.
 *      }
 * }
 * @endcode
 * \defgroup xEventGroupClearBits xEventGroupClearBits
 * \ingroup EventGroup
 *//**
 * event_groups.h
 * @code{c}
 *  EventBits_t xEventGroupWaitBits(    EventGroupHandle_t xEventGroup,
 *                                      const EventBits_t uxBitsToWaitFor,
 *                                      const BaseType_t xClearOnExit,
 *                                      const BaseType_t xWaitForAllBits,
 *                                      const TickType_t xTicksToWait );
 * @endcode
 *
 * [Potentially] block to wait for one or more bits to be set within a
 * previously created event group.
 *
 * This function cannot be called from an interrupt.
 *
 * @param xEventGroup The event group in which the bits are being tested.  The
 * event group must have previously been created using a call to
 * xEventGroupCreate().
 *
 * @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
 * inside the event group.  For example, to wait for bit 0 and/or bit 2 set
 * uxBitsToWaitFor to 0x05.  To wait for bits 0 and/or bit 1 and/or bit 2 set
 * uxBitsToWaitFor to 0x07.  Etc.
 *
 * @param xClearOnExit If xClearOnExit is set to pdTRUE then any bits within
 * uxBitsToWaitFor that are set within the event group will be cleared before
 * xEventGroupWaitBits() returns if the wait condition was met (if the function
 * returns for a reason other than a timeout).  If xClearOnExit is set to
 * pdFALSE then the bits set in the event group are not altered when the call to
 * xEventGroupWaitBits() returns.
 *
 * @param xWaitForAllBits If xWaitForAllBits is set to pdTRUE then
 * xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor
 * are set or the specified block time expires.  If xWaitForAllBits is set to
 * pdFALSE then xEventGroupWaitBits() will return when any one of the bits set
 * in uxBitsToWaitFor is set or the specified block time expires.  The block
 * time is specified by the xTicksToWait parameter.
 *
 * @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
 * for one/all (depending on the xWaitForAllBits value) of the bits specified by
 * uxBitsToWaitFor to become set. A value of portMAX_DELAY can be used to block
 * indefinitely (provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).
 *
 * @return The value of the event group at the time either the bits being waited
 * for became set, or the block time expired.  Test the return value to know
 * which bits were set.  If xEventGroupWaitBits() returned because its timeout
 * expired then not all the bits being waited for will be set.  If
 * xEventGroupWaitBits() returned because the bits it was waiting for were set
 * then the returned value is the event group value before any bits were
 * automatically cleared in the case that xClearOnExit parameter was set to
 * pdTRUE.
 *
 * Example usage:
 * @code{c}
 * #define BIT_0 ( 1 << 0 )
 * #define BIT_4 ( 1 << 4 )
 *
 * void aFunction( EventGroupHandle_t xEventGroup )
 * {
 * EventBits_t uxBits;
 * const TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;
 *
 *      // Wait a maximum of 100ms for either bit 0 or bit 4 to be set within
 *      // the event group.  Clear the bits before exiting.
 *      uxBits = xEventGroupWaitBits(
 *                  xEventGroup,    // The event group being tested.
 *                  BIT_0 | BIT_4,  // The bits within the event group to wait for.
 *                  pdTRUE,         // BIT_0 and BIT_4 should be cleared before returning.
 *                  pdFALSE,        // Don't wait for both bits, either bit will do.
 *                  xTicksToWait ); // Wait a maximum of 100ms for either bit to be set.
 *
 *      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
 *      {
 *          // xEventGroupWaitBits() returned because both bits were set.
 *      }
 *      else if( ( uxBits & BIT_0 ) != 0 )
 *      {
 *          // xEventGroupWaitBits() returned because just BIT_0 was set.
 *      }
 *      else if( ( uxBits & BIT_4 ) != 0 )
 *      {
 *          // xEventGroupWaitBits() returned because just BIT_4 was set.
 *      }
 *      else
 *      {
 *          // xEventGroupWaitBits() returned because xTicksToWait ticks passed
 *          // without either BIT_0 or BIT_4 becoming set.
 *      }
 * }
 * @endcode
 * \defgroup xEventGroupWaitBits xEventGroupWaitBits
 * \ingroup EventGroup
 *//**
 * event_groups.h
 * @code{c}
 * EventGroupHandle_t xEventGroupCreateStatic( EventGroupHandle_t * pxEventGroupBuffer );
 * @endcode
 *
 * Create a new event group.
 *
 * Internally, within the FreeRTOS implementation, event groups use a [small]
 * block of memory, in which the event group's structure is stored.  If an event
 * groups is created using xEventGroupCreate() then the required memory is
 * automatically dynamically allocated inside the xEventGroupCreate() function.
 * (see https://www.FreeRTOS.org/a00111.html).  If an event group is created
 * using xEventGroupCreateStatic() then the application writer must instead
 * provide the memory that will get used by the event group.
 * xEventGroupCreateStatic() therefore allows an event group to be created
 * without using any dynamic memory allocation.
 *
 * Although event groups are not related to ticks, for internal implementation
 * reasons the number of bits available for use in an event group is dependent
 * on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h.  If
 * configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit
 * 0 to bit 7).  If configUSE_16_BIT_TICKS is set to 0 then each event group has
 * 24 usable bits (bit 0 to bit 23).  The EventBits_t type is used to store
 * event bits within an event group.
 *
 * @param pxEventGroupBuffer pxEventGroupBuffer must point to a variable of type
 * StaticEventGroup_t, which will be then be used to hold the event group's data
 * structures, removing the need for the memory to be allocated dynamically.
 *
 * @return If the event group was created then a handle to the event group is
 * returned.  If pxEventGroupBuffer was NULL then NULL is returned.
 *
 * Example usage:
 * @code{c}
 *  // StaticEventGroup_t is a publicly accessible structure that has the same
 *  // size and alignment requirements as the real event group structure.  It is
 *  // provided as a mechanism for applications to know the size of the event
 *  // group (which is dependent on the architecture and configuration file
 *  // settings) without breaking the strict data hiding policy by exposing the
 *  // real event group internals.  This StaticEventGroup_t variable is passed
 *  // into the xSemaphoreCreateEventGroupStatic() function and is used to store
 *  // the event group's data structures
 *  StaticEventGroup_t xEventGroupBuffer;
 *
 *  // Create the event group without dynamically allocating any memory.
 *  xEventGroup = xEventGroupCreateStatic( &xEventGroupBuffer );
 * @endcode
 *//**
 * event_groups.h
 * @code{c}
 * EventGroupHandle_t xEventGroupCreate( void );
 * @endcode
 *
 * Create a new event group.
 *
 * Internally, within the FreeRTOS implementation, event groups use a [small]
 * block of memory, in which the event group's structure is stored.  If an event
 * groups is created using xEventGroupCreate() then the required memory is
 * automatically dynamically allocated inside the xEventGroupCreate() function.
 * (see https://www.FreeRTOS.org/a00111.html).  If an event group is created
 * using xEventGroupCreateStatic() then the application writer must instead
 * provide the memory that will get used by the event group.
 * xEventGroupCreateStatic() therefore allows an event group to be created
 * without using any dynamic memory allocation.
 *
 * Although event groups are not related to ticks, for internal implementation
 * reasons the number of bits available for use in an event group is dependent
 * on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h.  If
 * configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit
 * 0 to bit 7).  If configUSE_16_BIT_TICKS is set to 0 then each event group has
 * 24 usable bits (bit 0 to bit 23).  The EventBits_t type is used to store
 * event bits within an event group.
 *
 * @return If the event group was created then a handle to the event group is
 * returned.  If there was insufficient FreeRTOS heap available to create the
 * event group then NULL is returned.  See https://www.FreeRTOS.org/a00111.html
 *
 * Example usage:
 * @code{c}
 *  // Declare a variable to hold the created event group.
 *  EventGroupHandle_t xCreatedEventGroup;
 *
 *  // Attempt to create the event group.
 *  xCreatedEventGroup = xEventGroupCreate();
 *
 *  // Was the event group created successfully?
 *  if( xCreatedEventGroup == NULL )
 *  {
 *      // The event group was not created because there was insufficient
 *      // FreeRTOS heap available.
 *  }
 *  else
 *  {
 *      // The event group was created.
 *  }
 * @endcode
 * \defgroup xEventGroupCreate xEventGroupCreate
 * \ingroup EventGroup
 *//*
 * The type that holds event bits always matches TickType_t - therefore the
 * number of bits it holds is set by configUSE_16_BIT_TICKS (16 bits if set to 1,
 * 32 bits if set to 0.
 *
 * \defgroup EventBits_t EventBits_t
 * \ingroup EventGroup
 *//**
 * event_groups.h
 *
 * Type by which event groups are referenced.  For example, a call to
 * xEventGroupCreate() returns an EventGroupHandle_t variable that can then
 * be used as a parameter to other event group functions.
 *
 * \defgroup EventGroupHandle_t EventGroupHandle_t
 * \ingroup EventGroup
 *//**
 * An event group is a collection of bits to which an application can assign a
 * meaning.  For example, an application may create an event group to convey
 * the status of various CAN bus related events in which bit 0 might mean "A CAN
 * message has been received and is ready for processing", bit 1 might mean "The
 * application has queued a message that is ready for sending onto the CAN
 * network", and bit 2 might mean "It is time to send a SYNC message onto the
 * CAN network" etc.  A task can then test the bit values to see which events
 * are active, and optionally enter the Blocked state to wait for a specified
 * bit or a group of specified bits to be active.  To continue the CAN bus
 * example, a CAN controlling task can enter the Blocked state (and therefore
 * not consume any processing time) until either bit 0, bit 1 or bit 2 are
 * active, at which time the bit that was actually active would inform the task
 * which action it had to take (process a received message, send a message, or
 * send a SYNC).
 *
 * The event groups implementation contains intelligence to avoid race
 * conditions that would otherwise occur were an application to use a simple
 * variable for the same purpose.  This is particularly important with respect
 * to when a bit within an event group is to be cleared, and when bits have to
 * be set and then tested atomically - as is the case where event groups are
 * used to create a synchronisation point between multiple tasks (a
 * 'rendezvous').
 */xEventGroupuxEventGroupNumberpvEventGroupulBitsToSetuxBitsToSetuxBitsToWaitForuxBitsToClearxClearOnExitxWaitForAllBitspxEventGroupBuffer/Users/mac/Downloads/FreeRTOS/Source/include/timers.h/Users/mac/Downloads/FreeRTOS/Source/event_groups.c"event_groups.h"EventGroup_t *const EventGroup_tconst EventGroup_t *pxEventBitsprvTestWaitConditionxWaitConditionMet( EventBits_t ) 0pxTasksWaitingForBitspxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd )( UBaseType_t ) 0const xLIST_ITEMconst xLIST_ITEM *const MiniListItem_tconst MiniListItem_t *xMINI_LIST_ITEM *const ListItem_tconst ListItem_t *eventUNBLOCKED_DUE_TO_BIT_SET( uint8_t ) pdFALSEpxListItempxListEnduxBitsWaitedForuxControlBitsxMatchFound( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0( uxBitsToSet & 0xff000000UL ) == 04278190080eventEVENT_BITS_CONTROL_BYTES~eventEVENT_BITS_CONTROL_BYTES67108864eventWAIT_FOR_ALL_BITS16777216eventCLEAR_EVENTS_ON_EXIT_BITuxSavedInterruptStatusconst EventGroup_t *constuxReturn( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0( uxBitsToClear & 0xff000000UL ) == 0xAlreadyYieldedxTimeoutOccurred( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0( uxBitsToWaitFor & 0xff000000UL ) == 0uxBitsToWaitFor != 0!( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) )!( ( xTaskGetSchedulerState() == ( ( BaseType_t ) 0 ) ) && ( xTicksToWait != 0 ) )uxCurrentEventBits( TickType_t ) 03758157060uxOriginalBitValuesizeof( EventGroup_t )volatile size_tsizeof( StaticEventGroup_t )xSize == sizeof( EventGroup_t )EventGroup_tucStaticallyAllocatedxTasksWaitingForBitsuxEventBits0xff000000UL0x04000000UL0x02000000UL0x01000000ULconfigUSE_16_BIT_TICKS == 1( configASSERT_DEFINED == 1 )( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )/* configUSE_TRACE_FACILITY *//*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. *//* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) *//*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. *//* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? *//* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? *//*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. *//* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. *//* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. *//* configSUPPORT_DYNAMIC_ALLOCATION *//* The event group could have been allocated statically or
         * dynamically, so check before attempting to free the memory. *//* The event group can only have been allocated dynamically - free
         * it again. *//* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. *//* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. *//* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. *//* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. *//* The bits match.  Should the bits be cleared on exit? *//* Need all bits to be set, but not all the bits were set. *//* All bits are set. *//* Just looking for single bit being set. *//* Split the bits waited for from the control bits. *//* See if the new bit value should unblock any tasks. *//* Set the bits. *//*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//* Check the user is not attempting to set the bits used by the kernel
     * itself. *//*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. *//* Clear the bits. *//* The value returned is the event group value prior to the bits being
         * cleared. *//* Check the user is not attempting to clear the bits used by the kernel
     * itself. *//* Prevent compiler warnings when trace macros are not used. *//* The task blocked so control bits may have been set. *//* The task unblocked because the bits were set. *//* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. *//* The task timed out, just return the current event bit value. *//* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. *//* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. *//* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. *//* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. *//* The wait condition has not been met, but no block time was
             * specified, so just return the current value. *//* Clear the wait bits if requested to do so. *//* The wait condition has already been met so there is no need to
             * block. *//* Check to see if the wait condition is already met or not. *//* Check the user is not attempting to wait on the bits used by the kernel
     * itself, and that at least one bit is being requested. *//* Control bits might be set as the task had blocked should not be
         * returned. *//* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. *//* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. *//* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. *//* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. *//* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. *//* All the rendezvous bits are now set - no need to block. *//*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. *//* Both static and dynamic allocation can be used, so note this
                 * event group was allocated statically in case the event group is
                 * later deleted. *//*lint !e9087 !e9079 see comment above. *//* Allocate the event group.  Justification for MISRA deviation as
         * follows:  pvPortMalloc() always ensures returned memory blocks are
         * aligned per the requirements of the MCU stack.  In this case
         * pvPortMalloc() must return a pointer that is guaranteed to meet the
         * alignment requirements of the EventGroup_t structure - which (if you
         * follow it through) is the alignment requirements of the TickType_t type
         * (EventBits_t being of TickType_t itself).  Therefore, whenever the
         * stack alignment requirements are greater than or equal to the
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. *//* xEventGroupCreateStatic should only ever be called with
             * pxEventGroupBuffer pointing to a pre-allocated (compile time
             * allocated) StaticEventGroup_t variable. *//* Both static and dynamic allocation can be used, so note that
                 * this event group was created statically in case the event group
                 * is later deleted. *//*lint !e740 !e9087 EventGroup_t and StaticEventGroup_t are deliberately aliased for data hiding purposes and guaranteed to have the same size and alignment requirement - checked by configASSERT(). *//* The user has provided a statically allocated event group - use it. *//* configASSERT_DEFINED *//*lint !e529 xSize is referenced if configASSERT() is defined. *//* Sanity check that the size of the structure used to declare a
             * variable of type StaticEventGroup_t equals the size of the real
             * event group structure. *//* A StaticEventGroup_t object must be provided. *//*
 * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
 * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
 * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
 * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
 * wait condition is met if any of the bits set in uxBitsToWait for are also set
 * in uxCurrentEventBits.
 *//*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. *//*< List of tasks waiting for a bit to be set. *//* The following bit fields convey control information in a task's event list
 * item value.  It is important they don't clash with the
 * taskEVENT_LIST_ITEM_VALUE_IN_USE definition. *//*lint !e961 !e750 !e9021 See comment above. *//* Lint e961, e750 and e9021 are suppressed as a MISRA exception justified
 * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
 * for the header files above, but not in this file, in order to generate the
 * correct privileged Vs unprivileged linkage and placement. *//* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
 * all the API functions to use the MPU wrappers.  That should only be done when
 * task.h is included from an application file. *//* Standard includes. *//Users/mac/Downloads/FreeRTOS/Source/list.cpxIteratorxValueOfInsertionMiniListItem_t *( UBaseType_t ) 0U&( pxList->xListEnd )( configUSE_MINI_LIST_ITEM == 0 )/* Only used during decision coverage testing. *//* The list item knows which list it is in.  Obtain the list from the list
 * item. *//* Remember which list the item is in.  This allows fast removal of the
     * item later. *//* There is nothing to do here, just iterating to the wanted
             * insertion position. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. *//* *** NOTE ***********************************************************
        *  If you find your application is crashing here then likely causes are
        *  listed below.  In addition see https://www.FreeRTOS.org/FAQHelp.html for
        *  more tips, and ensure configASSERT() is defined!
        *  https://www.FreeRTOS.org/a00110.html#configASSERT
        *
        *   1) Stack overflow -
        *      see https://www.FreeRTOS.org/Stacks-and-stack-overflow-checking.html
        *   2) Incorrect interrupt priority assignment, especially on Cortex-M
        *      parts where numerically high priority values denote low actual
        *      interrupt priorities, which can seem counter intuitive.  See
        *      https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html and the definition
        *      of configMAX_SYSCALL_INTERRUPT_PRIORITY on
        *      https://www.FreeRTOS.org/a00110.html
        *   3) Calling an API function from within a critical section or when
        *      the scheduler is suspended, or calling an API function that does
        *      not end in "FromISR" from an interrupt.
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************//* Insert the new list item into the list, sorted in xItemValue order.
     *
     * If the list already contains a list item with the same item value then the
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. *//* Only effective when configASSERT() is also defined, these tests may catch
     * the list data structures being overwritten in memory.  They will not catch
     * data errors caused by incorrect configuration or use of FreeRTOS. *//* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). *//* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. *//* Make sure the list item is not recorded as being on a list. *//* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. *//* Initialize the remaining fields of xListEnd when it is a proper ListItem_t *//* The list end next and previous pointers point to itself so we know
     * when the list is empty. *//* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. *//* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. *//*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*//*lint !e961 !e750 !e9021. *//* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
 * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be
 * defined for the header files above, but not in this file, in order to
 * generate the correct privileged Vs unprivileged linkage and placement. *//Users/mac/Downloads/FreeRTOS/Source/include/queue.hucQueueGetQueueTypeuxQueueGetQueueNumbervQueueSetQueueNumbervQueueWaitForMessageRestrictedxQueueSelectFromSetFromISRStaticQueue_t *xSTATIC_QUEUE *const uint8_txQueueGetMutexHolderFromISRxQueueCRReceivexQueueCRSendxQueueCRReceiveFromISRxQueueCRSendFromISRuxQueueMessagesWaitingFromISRconst QueueHandle_tQueueDefinition *xQueueIsQueueFullFromISRxQueueIsQueueEmptyFromISRxQueueReceiveFromISRBaseType_t *constxQueueGiveFromISRxQueueGenericSendFromISRconst void *constxQueuePeekFromISRQueueDefinitionxQueueReset(xQueue)xQueueGenericReset( ( xQueue ), pdFALSE )xQueueSendFromISR(xQueue,pvItemToQueue,pxHigherPriorityTaskWoken)xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )xQueueOverwriteFromISR(xQueue,pvItemToQueue,pxHigherPriorityTaskWoken)xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )xQueueSendToBackFromISR(xQueue,pvItemToQueue,pxHigherPriorityTaskWoken)xQueueSendToFrontFromISR(xQueue,pvItemToQueue,pxHigherPriorityTaskWoken)xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )xQueueOverwrite(xQueue,pvItemToQueue)xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )xQueueSend(xQueue,pvItemToQueue,xTicksToWait)xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )xQueueSendToBack(xQueue,pvItemToQueue,xTicksToWait)xQueueSendToFront(xQueue,pvItemToQueue,xTicksToWait)xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )xQueueCreateStatic(uxQueueLength,uxItemSize,pucQueueStorage,pxQueueBuffer)xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )xQueueCreate(uxQueueLength,uxItemSize)xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )queueQUEUE_TYPE_RECURSIVE_MUTEX( ( uint8_t ) 4U )queueQUEUE_TYPE_BINARY_SEMAPHORE( ( uint8_t ) 3U )queueQUEUE_TYPE_COUNTING_SEMAPHORE( ( uint8_t ) 2U )queueQUEUE_TYPE_MUTEX( ( uint8_t ) 1U )queueQUEUE_TYPE_SET( ( uint8_t ) 0U )queueQUEUE_TYPE_BASEqueueOVERWRITEqueueSEND_TO_FRONTqueueSEND_TO_BACKQUEUE_H/* QUEUE_H *//* Not public API functions. *//*
 * A version of xQueueSelectFromSet() that can be used from an ISR.
 *//*
 * xQueueSelectFromSet() selects from the members of a queue set a queue or
 * semaphore that either contains data (in the case of a queue) or is available
 * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
 * allows a task to block (pend) on a read operation on all the queues and
 * semaphores in a queue set simultaneously.
 *
 * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
 * function.
 *
 * Note 1:  See the documentation on https://www.FreeRTOS.org/RTOS-queue-sets.html
 * for reasons why queue sets are very rarely needed in practice as there are
 * simpler methods of blocking on multiple objects.
 *
 * Note 2:  Blocking on a queue set that contains a mutex will not cause the
 * mutex holder to inherit the priority of the blocked task.
 *
 * Note 3:  A receive (in the case of a queue) or take (in the case of a
 * semaphore) operation must not be performed on a member of a queue set unless
 * a call to xQueueSelectFromSet() has first returned a handle to that set member.
 *
 * @param xQueueSet The queue set on which the task will (potentially) block.
 *
 * @param xTicksToWait The maximum time, in ticks, that the calling task will
 * remain in the Blocked state (with other tasks executing) to wait for a member
 * of the queue set to be ready for a successful queue read or semaphore take
 * operation.
 *
 * @return xQueueSelectFromSet() will return the handle of a queue (cast to
 * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
 * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
 * in the queue set that is available, or NULL if no such queue or semaphore
 * exists before before the specified block time expires.
 *//*
 * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
 * be removed from a set if the queue or semaphore is empty.
 *
 * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
 * function.
 *
 * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
 * from the queue set (cast to an QueueSetMemberHandle_t type).
 *
 * @param xQueueSet The handle of the queue set in which the queue or semaphore
 * is included.
 *
 * @return If the queue or semaphore was successfully removed from the queue set
 * then pdPASS is returned.  If the queue was not in the queue set, or the
 * queue (or semaphore) was not empty, then pdFAIL is returned.
 *//*
 * Adds a queue or semaphore to a queue set that was previously created by a
 * call to xQueueCreateSet().
 *
 * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
 * function.
 *
 * Note 1:  A receive (in the case of a queue) or take (in the case of a
 * semaphore) operation must not be performed on a member of a queue set unless
 * a call to xQueueSelectFromSet() has first returned a handle to that set member.
 *
 * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
 * the queue set (cast to an QueueSetMemberHandle_t type).
 *
 * @param xQueueSet The handle of the queue set to which the queue or semaphore
 * is being added.
 *
 * @return If the queue or semaphore was successfully added to the queue set
 * then pdPASS is returned.  If the queue could not be successfully added to the
 * queue set because it is already a member of a different queue set then pdFAIL
 * is returned.
 *//*
 * Queue sets provide a mechanism to allow a task to block (pend) on a read
 * operation from multiple queues or semaphores simultaneously.
 *
 * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
 * function.
 *
 * A queue set must be explicitly created using a call to xQueueCreateSet()
 * before it can be used.  Once created, standard FreeRTOS queues and semaphores
 * can be added to the set using calls to xQueueAddToSet().
 * xQueueSelectFromSet() is then used to determine which, if any, of the queues
 * or semaphores contained in the set is in a state where a queue read or
 * semaphore take operation would be successful.
 *
 * Note 1:  See the documentation on https://www.FreeRTOS.org/RTOS-queue-sets.html
 * for reasons why queue sets are very rarely needed in practice as there are
 * simpler methods of blocking on multiple objects.
 *
 * Note 2:  Blocking on a queue set that contains a mutex will not cause the
 * mutex holder to inherit the priority of the blocked task.
 *
 * Note 3:  An additional 4 bytes of RAM is required for each space in a every
 * queue added to a queue set.  Therefore counting semaphores that have a high
 * maximum count value should not be added to a queue set.
 *
 * Note 4:  A receive (in the case of a queue) or take (in the case of a
 * semaphore) operation must not be performed on a member of a queue set unless
 * a call to xQueueSelectFromSet() has first returned a handle to that set member.
 *
 * @param uxEventQueueLength Queue sets store events that occur on
 * the queues and semaphores contained in the set.  uxEventQueueLength specifies
 * the maximum number of events that can be queued at once.  To be absolutely
 * certain that events are not lost uxEventQueueLength should be set to the
 * total sum of the length of the queues added to the set, where binary
 * semaphores and mutexes have a length of 1, and counting semaphores have a
 * length set by their maximum count value.  Examples:
 *  + If a queue set is to hold a queue of length 5, another queue of length 12,
 *    and a binary semaphore, then uxEventQueueLength should be set to
 *    (5 + 12 + 1), or 18.
 *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
 *    should be set to (1 + 1 + 1 ), or 3.
 *  + If a queue set is to hold a counting semaphore that has a maximum count of
 *    5, and a counting semaphore that has a maximum count of 3, then
 *    uxEventQueueLength should be set to (5 + 3), or 8.
 *
 * @return If the queue set is created successfully then a handle to the created
 * queue set is returned.  Otherwise NULL is returned.
 *//*
 * Generic version of the function used to create a queue using dynamic memory
 * allocation.  This is called by other functions and macros that create other
 * RTOS objects that use the queue structure as their base.
 *//*
 * The queue registry is provided as a means for kernel aware debuggers to
 * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
 * up and return the name of a queue in the queue registry from the queue's
 * handle.
 *
 * @param xQueue The handle of the queue the name of which will be returned.
 * @return If the queue is in the registry then a pointer to the name of the
 * queue is returned.  If the queue is not in the registry then NULL is
 * returned.
 *//*
 * The registry is provided as a means for kernel aware debuggers to
 * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
 * a queue, semaphore or mutex handle to the registry if you want the handle
 * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
 * remove the queue, semaphore or mutex from the register.  If you are not using
 * a kernel aware debugger then this function can be ignored.
 *
 * @param xQueue The handle of the queue being removed from the registry.
 *//*
 * The registry is provided as a means for kernel aware debuggers to
 * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
 * a queue, semaphore or mutex handle to the registry if you want the handle
 * to be available to a kernel aware debugger.  If you are not using a kernel
 * aware debugger then this function can be ignored.
 *
 * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
 * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
 * within FreeRTOSConfig.h for the registry to be available.  Its value
 * does not affect the number of queues, semaphores and mutexes that can be
 * created - just the number that the registry can hold.
 *
 * If vQueueAddToRegistry is called more than once with the same xQueue
 * parameter, the registry will store the pcQueueName parameter from the
 * most recent call to vQueueAddToRegistry.
 *
 * @param xQueue The handle of the queue being added to the registry.  This
 * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
 * handles can also be passed in here.
 *
 * @param pcQueueName The name to be associated with the handle.  This is the
 * name that the kernel aware debugger will display.  The queue registry only
 * stores a pointer to the string - so the string must be persistent (global or
 * preferably in ROM/Flash), not on the stack.
 *//*
 * Reset a queue back to its original empty state.  The return value is now
 * obsolete and is always set to pdPASS.
 *//*
 * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
 * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
 *//*
 * For internal use only.  Use xSemaphoreCreateMutex(),
 * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
 * these functions directly.
 *//*
 * The functions defined above are for passing data to and from tasks.  The
 * functions below are the equivalents for passing data to and from
 * co-routines.
 *
 * These functions are called from the co-routine macro implementation and
 * should not be called directly from application code.  Instead use the macro
 * wrappers defined within croutine.h.
 *//*
 * Utilities to query queues that are safe to use from an ISR.  These utilities
 * should be used only from within an ISR, or within a critical section.
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueReceiveFromISR(
 *                                     QueueHandle_t    xQueue,
 *                                     void             *pvBuffer,
 *                                     BaseType_t       *pxTaskWoken
 *                                 );
 * @endcode
 *
 * Receive an item from a queue.  It is safe to use this function from within an
 * interrupt service routine.
 *
 * @param xQueue The handle to the queue from which the item is to be
 * received.
 *
 * @param pvBuffer Pointer to the buffer into which the received item will
 * be copied.
 *
 * @param pxTaskWoken A task may be blocked waiting for space to become
 * available on the queue.  If xQueueReceiveFromISR causes such a task to
 * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
 * remain unchanged.
 *
 * @return pdTRUE if an item was successfully received from the queue,
 * otherwise pdFALSE.
 *
 * Example usage:
 * @code{c}
 *
 * QueueHandle_t xQueue;
 *
 * // Function to create a queue and post some values.
 * void vAFunction( void *pvParameters )
 * {
 * char cValueToPost;
 * const TickType_t xTicksToWait = ( TickType_t )0xff;
 *
 *  // Create a queue capable of containing 10 characters.
 *  xQueue = xQueueCreate( 10, sizeof( char ) );
 *  if( xQueue == 0 )
 *  {
 *      // Failed to create the queue.
 *  }
 *
 *  // ...
 *
 *  // Post some characters that will be used within an ISR.  If the queue
 *  // is full then this task will block for xTicksToWait ticks.
 *  cValueToPost = 'a';
 *  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
 *  cValueToPost = 'b';
 *  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
 *
 *  // ... keep posting characters ... this task may block when the queue
 *  // becomes full.
 *
 *  cValueToPost = 'c';
 *  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
 * }
 *
 * // ISR that outputs all the characters received on the queue.
 * void vISR_Routine( void )
 * {
 * BaseType_t xTaskWokenByReceive = pdFALSE;
 * char cRxedChar;
 *
 *  while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
 *  {
 *      // A character was received.  Output the character now.
 *      vOutputCharacter( cRxedChar );
 *
 *      // If removing the character from the queue woke the task that was
 *      // posting onto the queue xTaskWokenByReceive will have been set to
 *      // pdTRUE.  No matter how many times this loop iterates only one
 *      // task will be woken.
 *  }
 *
 *  if( xTaskWokenByReceive != ( char ) pdFALSE;
 *  {
 *      taskYIELD ();
 *  }
 * }
 * @endcode
 * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueGenericSendFromISR(
 *                                         QueueHandle_t    xQueue,
 *                                         const    void    *pvItemToQueue,
 *                                         BaseType_t  *pxHigherPriorityTaskWoken,
 *                                         BaseType_t  xCopyPosition
 *                                     );
 * @endcode
 *
 * It is preferred that the macros xQueueSendFromISR(),
 * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
 * of calling this function directly.  xQueueGiveFromISR() is an
 * equivalent for use by semaphores that don't actually copy any data.
 *
 * Post an item on a queue.  It is safe to use this function from within an
 * interrupt service routine.
 *
 * Items are queued by copy not reference so it is preferable to only
 * queue small items, especially when called from an ISR.  In most cases
 * it would be preferable to store a pointer to the item being queued.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
 * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
 * to unblock, and the unblocked task has a priority higher than the currently
 * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
 * a context switch should be requested before the interrupt is exited.
 *
 * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
 * item at the back of the queue, or queueSEND_TO_FRONT to place the item
 * at the front of the queue (for high priority messages).
 *
 * @return pdTRUE if the data was successfully sent to the queue, otherwise
 * errQUEUE_FULL.
 *
 * Example usage for buffered IO (where the ISR can obtain more than one value
 * per call):
 * @code{c}
 * void vBufferISR( void )
 * {
 * char cIn;
 * BaseType_t xHigherPriorityTaskWokenByPost;
 *
 *  // We have not woken a task at the start of the ISR.
 *  xHigherPriorityTaskWokenByPost = pdFALSE;
 *
 *  // Loop until the buffer is empty.
 *  do
 *  {
 *      // Obtain a byte from the buffer.
 *      cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
 *
 *      // Post each byte.
 *      xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
 *
 *  } while( portINPUT_BYTE( BUFFER_COUNT ) );
 *
 *  // Now the buffer is empty we can switch context if necessary.  Note that the
 *  // name of the yield function required is port specific.
 *  if( xHigherPriorityTaskWokenByPost )
 *  {
 *      portYIELD_FROM_ISR();
 *  }
 * }
 * @endcode
 *
 * \defgroup xQueueSendFromISR xQueueSendFromISR
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueSendFromISR(
 *                                   QueueHandle_t xQueue,
 *                                   const void *pvItemToQueue,
 *                                   BaseType_t *pxHigherPriorityTaskWoken
 *                              );
 * @endcode
 *
 * This is a macro that calls xQueueGenericSendFromISR().  It is included
 * for backward compatibility with versions of FreeRTOS.org that did not
 * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
 * macros.
 *
 * Post an item to the back of a queue.  It is safe to use this function from
 * within an interrupt service routine.
 *
 * Items are queued by copy not reference so it is preferable to only
 * queue small items, especially when called from an ISR.  In most cases
 * it would be preferable to store a pointer to the item being queued.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
 * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
 * to unblock, and the unblocked task has a priority higher than the currently
 * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
 * a context switch should be requested before the interrupt is exited.
 *
 * @return pdTRUE if the data was successfully sent to the queue, otherwise
 * errQUEUE_FULL.
 *
 * Example usage for buffered IO (where the ISR can obtain more than one value
 * per call):
 * @code{c}
 * void vBufferISR( void )
 * {
 * char cIn;
 * BaseType_t xHigherPriorityTaskWoken;
 *
 *  // We have not woken a task at the start of the ISR.
 *  xHigherPriorityTaskWoken = pdFALSE;
 *
 *  // Loop until the buffer is empty.
 *  do
 *  {
 *      // Obtain a byte from the buffer.
 *      cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
 *
 *      // Post the byte.
 *      xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
 *
 *  } while( portINPUT_BYTE( BUFFER_COUNT ) );
 *
 *  // Now the buffer is empty we can switch context if necessary.
 *  if( xHigherPriorityTaskWoken )
 *  {
 *      // Actual macro used here is port specific.
 *      portYIELD_FROM_ISR ();
 *  }
 * }
 * @endcode
 *
 * \defgroup xQueueSendFromISR xQueueSendFromISR
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueOverwriteFromISR(
 *                            QueueHandle_t xQueue,
 *                            const void * pvItemToQueue,
 *                            BaseType_t *pxHigherPriorityTaskWoken
 *                       );
 * @endcode
 *
 * A version of xQueueOverwrite() that can be used in an interrupt service
 * routine (ISR).
 *
 * Only for use with queues that can hold a single item - so the queue is either
 * empty or full.
 *
 * Post an item on a queue.  If the queue is already full then overwrite the
 * value held in the queue.  The item is queued by copy, not by reference.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
 * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
 * to unblock, and the unblocked task has a priority higher than the currently
 * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
 * a context switch should be requested before the interrupt is exited.
 *
 * @return xQueueOverwriteFromISR() is a macro that calls
 * xQueueGenericSendFromISR(), and therefore has the same return values as
 * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
 * returned because xQueueOverwriteFromISR() will write to the queue even when
 * the queue is already full.
 *
 * Example usage:
 * @code{c}
 *
 * QueueHandle_t xQueue;
 *
 * void vFunction( void *pvParameters )
 * {
 *  // Create a queue to hold one uint32_t value.  It is strongly
 *  // recommended *not* to use xQueueOverwriteFromISR() on queues that can
 *  // contain more than one value, and doing so will trigger an assertion
 *  // if configASSERT() is defined.
 *  xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
 * }
 *
 * void vAnInterruptHandler( void )
 * {
 * // xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
 * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 * uint32_t ulVarToSend, ulValReceived;
 *
 *  // Write the value 10 to the queue using xQueueOverwriteFromISR().
 *  ulVarToSend = 10;
 *  xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
 *
 *  // The queue is full, but calling xQueueOverwriteFromISR() again will still
 *  // pass because the value held in the queue will be overwritten with the
 *  // new value.
 *  ulVarToSend = 100;
 *  xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
 *
 *  // Reading from the queue will now return 100.
 *
 *  // ...
 *
 *  if( xHigherPrioritytaskWoken == pdTRUE )
 *  {
 *      // Writing to the queue caused a task to unblock and the unblocked task
 *      // has a priority higher than or equal to the priority of the currently
 *      // executing task (the task this interrupt interrupted).  Perform a context
 *      // switch so this interrupt returns directly to the unblocked task.
 *      portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
 *  }
 * }
 * @endcode
 * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueSendToBackFromISR(
 *                                       QueueHandle_t xQueue,
 *                                       const void *pvItemToQueue,
 *                                       BaseType_t *pxHigherPriorityTaskWoken
 *                                    );
 * @endcode
 *
 * This is a macro that calls xQueueGenericSendFromISR().
 *
 * Post an item to the back of a queue.  It is safe to use this macro from
 * within an interrupt service routine.
 *
 * Items are queued by copy not reference so it is preferable to only
 * queue small items, especially when called from an ISR.  In most cases
 * it would be preferable to store a pointer to the item being queued.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
 * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
 * to unblock, and the unblocked task has a priority higher than the currently
 * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
 * a context switch should be requested before the interrupt is exited.
 *
 * @return pdTRUE if the data was successfully sent to the queue, otherwise
 * errQUEUE_FULL.
 *
 * Example usage for buffered IO (where the ISR can obtain more than one value
 * per call):
 * @code{c}
 * void vBufferISR( void )
 * {
 * char cIn;
 * BaseType_t xHigherPriorityTaskWoken;
 *
 *  // We have not woken a task at the start of the ISR.
 *  xHigherPriorityTaskWoken = pdFALSE;
 *
 *  // Loop until the buffer is empty.
 *  do
 *  {
 *      // Obtain a byte from the buffer.
 *      cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
 *
 *      // Post the byte.
 *      xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
 *
 *  } while( portINPUT_BYTE( BUFFER_COUNT ) );
 *
 *  // Now the buffer is empty we can switch context if necessary.
 *  if( xHigherPriorityTaskWoken )
 *  {
 *      taskYIELD ();
 *  }
 * }
 * @endcode
 *
 * \defgroup xQueueSendFromISR xQueueSendFromISR
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueSendToFrontFromISR(
 *                                       QueueHandle_t xQueue,
 *                                       const void *pvItemToQueue,
 *                                       BaseType_t *pxHigherPriorityTaskWoken
 *                                    );
 * @endcode
 *
 * This is a macro that calls xQueueGenericSendFromISR().
 *
 * Post an item to the front of a queue.  It is safe to use this macro from
 * within an interrupt service routine.
 *
 * Items are queued by copy not reference so it is preferable to only
 * queue small items, especially when called from an ISR.  In most cases
 * it would be preferable to store a pointer to the item being queued.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
 * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
 * to unblock, and the unblocked task has a priority higher than the currently
 * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
 * a context switch should be requested before the interrupt is exited.
 *
 * @return pdTRUE if the data was successfully sent to the queue, otherwise
 * errQUEUE_FULL.
 *
 * Example usage for buffered IO (where the ISR can obtain more than one value
 * per call):
 * @code{c}
 * void vBufferISR( void )
 * {
 * char cIn;
 * BaseType_t xHigherPriorityTaskWoken;
 *
 *  // We have not woken a task at the start of the ISR.
 *  xHigherPriorityTaskWoken = pdFALSE;
 *
 *  // Loop until the buffer is empty.
 *  do
 *  {
 *      // Obtain a byte from the buffer.
 *      cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
 *
 *      // Post the byte.
 *      xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
 *
 *  } while( portINPUT_BYTE( BUFFER_COUNT ) );
 *
 *  // Now the buffer is empty we can switch context if necessary.
 *  if( xHigherPriorityTaskWoken )
 *  {
 *      taskYIELD ();
 *  }
 * }
 * @endcode
 *
 * \defgroup xQueueSendFromISR xQueueSendFromISR
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * void vQueueDelete( QueueHandle_t xQueue );
 * @endcode
 *
 * Delete a queue - freeing all the memory allocated for storing of items
 * placed on the queue.
 *
 * @param xQueue A handle to the queue to be deleted.
 *
 * \defgroup vQueueDelete vQueueDelete
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );
 * @endcode
 *
 * Return the number of free spaces available in a queue.  This is equal to the
 * number of items that can be sent to the queue before the queue becomes full
 * if no items are removed.
 *
 * @param xQueue A handle to the queue being queried.
 *
 * @return The number of spaces available in the queue.
 *
 * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );
 * @endcode
 *
 * Return the number of messages stored in a queue.
 *
 * @param xQueue A handle to the queue being queried.
 *
 * @return The number of messages available in the queue.
 *
 * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueReceive(
 *                               QueueHandle_t xQueue,
 *                               void *pvBuffer,
 *                               TickType_t xTicksToWait
 *                          );
 * @endcode
 *
 * Receive an item from a queue.  The item is received by copy so a buffer of
 * adequate size must be provided.  The number of bytes copied into the buffer
 * was defined when the queue was created.
 *
 * Successfully received items are removed from the queue.
 *
 * This function must not be used in an interrupt service routine.  See
 * xQueueReceiveFromISR for an alternative that can.
 *
 * @param xQueue The handle to the queue from which the item is to be
 * received.
 *
 * @param pvBuffer Pointer to the buffer into which the received item will
 * be copied.
 *
 * @param xTicksToWait The maximum amount of time the task should block
 * waiting for an item to receive should the queue be empty at the time
 * of the call. xQueueReceive() will return immediately if xTicksToWait
 * is zero and the queue is empty.  The time is defined in tick periods so the
 * constant portTICK_PERIOD_MS should be used to convert to real time if this is
 * required.
 *
 * @return pdTRUE if an item was successfully received from the queue,
 * otherwise pdFALSE.
 *
 * Example usage:
 * @code{c}
 * struct AMessage
 * {
 *  char ucMessageID;
 *  char ucData[ 20 ];
 * } xMessage;
 *
 * QueueHandle_t xQueue;
 *
 * // Task to create a queue and post a value.
 * void vATask( void *pvParameters )
 * {
 * struct AMessage *pxMessage;
 *
 *  // Create a queue capable of containing 10 pointers to AMessage structures.
 *  // These should be passed by pointer as they contain a lot of data.
 *  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
 *  if( xQueue == 0 )
 *  {
 *      // Failed to create the queue.
 *  }
 *
 *  // ...
 *
 *  // Send a pointer to a struct AMessage object.  Don't block if the
 *  // queue is already full.
 *  pxMessage = & xMessage;
 *  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
 *
 *  // ... Rest of task code.
 * }
 *
 * // Task to receive from the queue.
 * void vADifferentTask( void *pvParameters )
 * {
 * struct AMessage *pxRxedMessage;
 *
 *  if( xQueue != 0 )
 *  {
 *      // Receive a message on the created queue.  Block for 10 ticks if a
 *      // message is not immediately available.
 *      if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
 *      {
 *          // pcRxedMessage now points to the struct AMessage variable posted
 *          // by vATask.
 *      }
 *  }
 *
 *  // ... Rest of task code.
 * }
 * @endcode
 * \defgroup xQueueReceive xQueueReceive
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueuePeekFromISR(
 *                                  QueueHandle_t xQueue,
 *                                  void *pvBuffer,
 *                              );
 * @endcode
 *
 * A version of xQueuePeek() that can be called from an interrupt service
 * routine (ISR).
 *
 * Receive an item from a queue without removing the item from the queue.
 * The item is received by copy so a buffer of adequate size must be
 * provided.  The number of bytes copied into the buffer was defined when
 * the queue was created.
 *
 * Successfully received items remain on the queue so will be returned again
 * by the next call, or a call to xQueueReceive().
 *
 * @param xQueue The handle to the queue from which the item is to be
 * received.
 *
 * @param pvBuffer Pointer to the buffer into which the received item will
 * be copied.
 *
 * @return pdTRUE if an item was successfully received from the queue,
 * otherwise pdFALSE.
 *
 * \defgroup xQueuePeekFromISR xQueuePeekFromISR
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueuePeek(
 *                           QueueHandle_t xQueue,
 *                           void * const pvBuffer,
 *                           TickType_t xTicksToWait
 *                       );
 * @endcode
 *
 * Receive an item from a queue without removing the item from the queue.
 * The item is received by copy so a buffer of adequate size must be
 * provided.  The number of bytes copied into the buffer was defined when
 * the queue was created.
 *
 * Successfully received items remain on the queue so will be returned again
 * by the next call, or a call to xQueueReceive().
 *
 * This macro must not be used in an interrupt service routine.  See
 * xQueuePeekFromISR() for an alternative that can be called from an interrupt
 * service routine.
 *
 * @param xQueue The handle to the queue from which the item is to be
 * received.
 *
 * @param pvBuffer Pointer to the buffer into which the received item will
 * be copied.
 *
 * @param xTicksToWait The maximum amount of time the task should block
 * waiting for an item to receive should the queue be empty at the time
 * of the call. The time is defined in tick periods so the constant
 * portTICK_PERIOD_MS should be used to convert to real time if this is required.
 * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
 * is empty.
 *
 * @return pdTRUE if an item was successfully received from the queue,
 * otherwise pdFALSE.
 *
 * Example usage:
 * @code{c}
 * struct AMessage
 * {
 *  char ucMessageID;
 *  char ucData[ 20 ];
 * } xMessage;
 *
 * QueueHandle_t xQueue;
 *
 * // Task to create a queue and post a value.
 * void vATask( void *pvParameters )
 * {
 * struct AMessage *pxMessage;
 *
 *  // Create a queue capable of containing 10 pointers to AMessage structures.
 *  // These should be passed by pointer as they contain a lot of data.
 *  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
 *  if( xQueue == 0 )
 *  {
 *      // Failed to create the queue.
 *  }
 *
 *  // ...
 *
 *  // Send a pointer to a struct AMessage object.  Don't block if the
 *  // queue is already full.
 *  pxMessage = & xMessage;
 *  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
 *
 *  // ... Rest of task code.
 * }
 *
 * // Task to peek the data from the queue.
 * void vADifferentTask( void *pvParameters )
 * {
 * struct AMessage *pxRxedMessage;
 *
 *  if( xQueue != 0 )
 *  {
 *      // Peek a message on the created queue.  Block for 10 ticks if a
 *      // message is not immediately available.
 *      if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
 *      {
 *          // pcRxedMessage now points to the struct AMessage variable posted
 *          // by vATask, but the item still remains on the queue.
 *      }
 *  }
 *
 *  // ... Rest of task code.
 * }
 * @endcode
 * \defgroup xQueuePeek xQueuePeek
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueGenericSend(
 *                                  QueueHandle_t xQueue,
 *                                  const void * pvItemToQueue,
 *                                  TickType_t xTicksToWait
 *                                  BaseType_t xCopyPosition
 *                              );
 * @endcode
 *
 * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
 * xQueueSendToBack() are used in place of calling this function directly.
 *
 * Post an item on a queue.  The item is queued by copy, not by reference.
 * This function must not be called from an interrupt service routine.
 * See xQueueSendFromISR () for an alternative which may be used in an ISR.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param xTicksToWait The maximum amount of time the task should block
 * waiting for space to become available on the queue, should it already
 * be full.  The call will return immediately if this is set to 0 and the
 * queue is full.  The time is defined in tick periods so the constant
 * portTICK_PERIOD_MS should be used to convert to real time if this is required.
 *
 * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
 * item at the back of the queue, or queueSEND_TO_FRONT to place the item
 * at the front of the queue (for high priority messages).
 *
 * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
 *
 * Example usage:
 * @code{c}
 * struct AMessage
 * {
 *  char ucMessageID;
 *  char ucData[ 20 ];
 * } xMessage;
 *
 * uint32_t ulVar = 10UL;
 *
 * void vATask( void *pvParameters )
 * {
 * QueueHandle_t xQueue1, xQueue2;
 * struct AMessage *pxMessage;
 *
 *  // Create a queue capable of containing 10 uint32_t values.
 *  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
 *
 *  // Create a queue capable of containing 10 pointers to AMessage structures.
 *  // These should be passed by pointer as they contain a lot of data.
 *  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
 *
 *  // ...
 *
 *  if( xQueue1 != 0 )
 *  {
 *      // Send an uint32_t.  Wait for 10 ticks for space to become
 *      // available if necessary.
 *      if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
 *      {
 *          // Failed to post the message, even after 10 ticks.
 *      }
 *  }
 *
 *  if( xQueue2 != 0 )
 *  {
 *      // Send a pointer to a struct AMessage object.  Don't block if the
 *      // queue is already full.
 *      pxMessage = & xMessage;
 *      xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
 *  }
 *
 *  // ... Rest of task code.
 * }
 * @endcode
 * \defgroup xQueueSend xQueueSend
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueOverwrite(
 *                            QueueHandle_t xQueue,
 *                            const void * pvItemToQueue
 *                       );
 * @endcode
 *
 * Only for use with queues that have a length of one - so the queue is either
 * empty or full.
 *
 * Post an item on a queue.  If the queue is already full then overwrite the
 * value held in the queue.  The item is queued by copy, not by reference.
 *
 * This function must not be called from an interrupt service routine.
 * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
 *
 * @param xQueue The handle of the queue to which the data is being sent.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
 * therefore has the same return values as xQueueSendToFront().  However, pdPASS
 * is the only value that can be returned because xQueueOverwrite() will write
 * to the queue even when the queue is already full.
 *
 * Example usage:
 * @code{c}
 *
 * void vFunction( void *pvParameters )
 * {
 * QueueHandle_t xQueue;
 * uint32_t ulVarToSend, ulValReceived;
 *
 *  // Create a queue to hold one uint32_t value.  It is strongly
 *  // recommended *not* to use xQueueOverwrite() on queues that can
 *  // contain more than one value, and doing so will trigger an assertion
 *  // if configASSERT() is defined.
 *  xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
 *
 *  // Write the value 10 to the queue using xQueueOverwrite().
 *  ulVarToSend = 10;
 *  xQueueOverwrite( xQueue, &ulVarToSend );
 *
 *  // Peeking the queue should now return 10, but leave the value 10 in
 *  // the queue.  A block time of zero is used as it is known that the
 *  // queue holds a value.
 *  ulValReceived = 0;
 *  xQueuePeek( xQueue, &ulValReceived, 0 );
 *
 *  if( ulValReceived != 10 )
 *  {
 *      // Error unless the item was removed by a different task.
 *  }
 *
 *  // The queue is still full.  Use xQueueOverwrite() to overwrite the
 *  // value held in the queue with 100.
 *  ulVarToSend = 100;
 *  xQueueOverwrite( xQueue, &ulVarToSend );
 *
 *  // This time read from the queue, leaving the queue empty once more.
 *  // A block time of 0 is used again.
 *  xQueueReceive( xQueue, &ulValReceived, 0 );
 *
 *  // The value read should be the last value written, even though the
 *  // queue was already full when the value was written.
 *  if( ulValReceived != 100 )
 *  {
 *      // Error!
 *  }
 *
 *  // ...
 * }
 * @endcode
 * \defgroup xQueueOverwrite xQueueOverwrite
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueSend(
 *                            QueueHandle_t xQueue,
 *                            const void * pvItemToQueue,
 *                            TickType_t xTicksToWait
 *                       );
 * @endcode
 *
 * This is a macro that calls xQueueGenericSend().  It is included for
 * backward compatibility with versions of FreeRTOS.org that did not
 * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
 * equivalent to xQueueSendToBack().
 *
 * Post an item on a queue.  The item is queued by copy, not by reference.
 * This function must not be called from an interrupt service routine.
 * See xQueueSendFromISR () for an alternative which may be used in an ISR.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param xTicksToWait The maximum amount of time the task should block
 * waiting for space to become available on the queue, should it already
 * be full.  The call will return immediately if this is set to 0 and the
 * queue is full.  The time is defined in tick periods so the constant
 * portTICK_PERIOD_MS should be used to convert to real time if this is required.
 *
 * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
 *
 * Example usage:
 * @code{c}
 * struct AMessage
 * {
 *  char ucMessageID;
 *  char ucData[ 20 ];
 * } xMessage;
 *
 * uint32_t ulVar = 10UL;
 *
 * void vATask( void *pvParameters )
 * {
 * QueueHandle_t xQueue1, xQueue2;
 * struct AMessage *pxMessage;
 *
 *  // Create a queue capable of containing 10 uint32_t values.
 *  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
 *
 *  // Create a queue capable of containing 10 pointers to AMessage structures.
 *  // These should be passed by pointer as they contain a lot of data.
 *  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
 *
 *  // ...
 *
 *  if( xQueue1 != 0 )
 *  {
 *      // Send an uint32_t.  Wait for 10 ticks for space to become
 *      // available if necessary.
 *      if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
 *      {
 *          // Failed to post the message, even after 10 ticks.
 *      }
 *  }
 *
 *  if( xQueue2 != 0 )
 *  {
 *      // Send a pointer to a struct AMessage object.  Don't block if the
 *      // queue is already full.
 *      pxMessage = & xMessage;
 *      xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
 *  }
 *
 *  // ... Rest of task code.
 * }
 * @endcode
 * \defgroup xQueueSend xQueueSend
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueSendToBack(
 *                                 QueueHandle_t    xQueue,
 *                                 const void       *pvItemToQueue,
 *                                 TickType_t       xTicksToWait
 *                             );
 * @endcode
 *
 * This is a macro that calls xQueueGenericSend().
 *
 * Post an item to the back of a queue.  The item is queued by copy, not by
 * reference.  This function must not be called from an interrupt service
 * routine.  See xQueueSendFromISR () for an alternative which may be used
 * in an ISR.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param xTicksToWait The maximum amount of time the task should block
 * waiting for space to become available on the queue, should it already
 * be full.  The call will return immediately if this is set to 0 and the queue
 * is full.  The  time is defined in tick periods so the constant
 * portTICK_PERIOD_MS should be used to convert to real time if this is required.
 *
 * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
 *
 * Example usage:
 * @code{c}
 * struct AMessage
 * {
 *  char ucMessageID;
 *  char ucData[ 20 ];
 * } xMessage;
 *
 * uint32_t ulVar = 10UL;
 *
 * void vATask( void *pvParameters )
 * {
 * QueueHandle_t xQueue1, xQueue2;
 * struct AMessage *pxMessage;
 *
 *  // Create a queue capable of containing 10 uint32_t values.
 *  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
 *
 *  // Create a queue capable of containing 10 pointers to AMessage structures.
 *  // These should be passed by pointer as they contain a lot of data.
 *  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
 *
 *  // ...
 *
 *  if( xQueue1 != 0 )
 *  {
 *      // Send an uint32_t.  Wait for 10 ticks for space to become
 *      // available if necessary.
 *      if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
 *      {
 *          // Failed to post the message, even after 10 ticks.
 *      }
 *  }
 *
 *  if( xQueue2 != 0 )
 *  {
 *      // Send a pointer to a struct AMessage object.  Don't block if the
 *      // queue is already full.
 *      pxMessage = & xMessage;
 *      xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
 *  }
 *
 *  // ... Rest of task code.
 * }
 * @endcode
 * \defgroup xQueueSend xQueueSend
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * BaseType_t xQueueSendToToFront(
 *                                 QueueHandle_t    xQueue,
 *                                 const void       *pvItemToQueue,
 *                                 TickType_t       xTicksToWait
 *                             );
 * @endcode
 *
 * Post an item to the front of a queue.  The item is queued by copy, not by
 * reference.  This function must not be called from an interrupt service
 * routine.  See xQueueSendFromISR () for an alternative which may be used
 * in an ISR.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param xTicksToWait The maximum amount of time the task should block
 * waiting for space to become available on the queue, should it already
 * be full.  The call will return immediately if this is set to 0 and the
 * queue is full.  The time is defined in tick periods so the constant
 * portTICK_PERIOD_MS should be used to convert to real time if this is required.
 *
 * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
 *
 * Example usage:
 * @code{c}
 * struct AMessage
 * {
 *  char ucMessageID;
 *  char ucData[ 20 ];
 * } xMessage;
 *
 * uint32_t ulVar = 10UL;
 *
 * void vATask( void *pvParameters )
 * {
 * QueueHandle_t xQueue1, xQueue2;
 * struct AMessage *pxMessage;
 *
 *  // Create a queue capable of containing 10 uint32_t values.
 *  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
 *
 *  // Create a queue capable of containing 10 pointers to AMessage structures.
 *  // These should be passed by pointer as they contain a lot of data.
 *  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
 *
 *  // ...
 *
 *  if( xQueue1 != 0 )
 *  {
 *      // Send an uint32_t.  Wait for 10 ticks for space to become
 *      // available if necessary.
 *      if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
 *      {
 *          // Failed to post the message, even after 10 ticks.
 *      }
 *  }
 *
 *  if( xQueue2 != 0 )
 *  {
 *      // Send a pointer to a struct AMessage object.  Don't block if the
 *      // queue is already full.
 *      pxMessage = & xMessage;
 *      xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
 *  }
 *
 *  // ... Rest of task code.
 * }
 * @endcode
 * \defgroup xQueueSend xQueueSend
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * QueueHandle_t xQueueCreateStatic(
 *                            UBaseType_t uxQueueLength,
 *                            UBaseType_t uxItemSize,
 *                            uint8_t *pucQueueStorage,
 *                            StaticQueue_t *pxQueueBuffer
 *                        );
 * @endcode
 *
 * Creates a new queue instance, and returns a handle by which the new queue
 * can be referenced.
 *
 * Internally, within the FreeRTOS implementation, queues use two blocks of
 * memory.  The first block is used to hold the queue's data structures.  The
 * second block is used to hold items placed into the queue.  If a queue is
 * created using xQueueCreate() then both blocks of memory are automatically
 * dynamically allocated inside the xQueueCreate() function.  (see
 * https://www.FreeRTOS.org/a00111.html).  If a queue is created using
 * xQueueCreateStatic() then the application writer must provide the memory that
 * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
 * be created without using any dynamic memory allocation.
 *
 * https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
 *
 * @param uxQueueLength The maximum number of items that the queue can contain.
 *
 * @param uxItemSize The number of bytes each item in the queue will require.
 * Items are queued by copy, not by reference, so this is the number of bytes
 * that will be copied for each posted item.  Each item on the queue must be
 * the same size.
 *
 * @param pucQueueStorage If uxItemSize is not zero then
 * pucQueueStorage must point to a uint8_t array that is at least large
 * enough to hold the maximum number of items that can be in the queue at any
 * one time - which is ( uxQueueLength * uxItemsSize ) bytes.  If uxItemSize is
 * zero then pucQueueStorage can be NULL.
 *
 * @param pxQueueBuffer Must point to a variable of type StaticQueue_t, which
 * will be used to hold the queue's data structure.
 *
 * @return If the queue is created then a handle to the created queue is
 * returned.  If pxQueueBuffer is NULL then NULL is returned.
 *
 * Example usage:
 * @code{c}
 * struct AMessage
 * {
 *  char ucMessageID;
 *  char ucData[ 20 ];
 * };
 *
 #define QUEUE_LENGTH 10
 #define ITEM_SIZE sizeof( uint32_t )
 *
 * // xQueueBuffer will hold the queue structure.
 * StaticQueue_t xQueueBuffer;
 *
 * // ucQueueStorage will hold the items posted to the queue.  Must be at least
 * // [(queue length) * ( queue item size)] bytes long.
 * uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
 *
 * void vATask( void *pvParameters )
 * {
 *  QueueHandle_t xQueue1;
 *
 *  // Create a queue capable of containing 10 uint32_t values.
 *  xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold.
 *                          ITEM_SIZE     // The size of each item in the queue
 *                          &( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue.
 *                          &xQueueBuffer ); // The buffer that will hold the queue structure.
 *
 *  // The queue is guaranteed to be created successfully as no dynamic memory
 *  // allocation is used.  Therefore xQueue1 is now a handle to a valid queue.
 *
 *  // ... Rest of task code.
 * }
 * @endcode
 * \defgroup xQueueCreateStatic xQueueCreateStatic
 * \ingroup QueueManagement
 *//**
 * queue. h
 * @code{c}
 * QueueHandle_t xQueueCreate(
 *                            UBaseType_t uxQueueLength,
 *                            UBaseType_t uxItemSize
 *                        );
 * @endcode
 *
 * Creates a new queue instance, and returns a handle by which the new queue
 * can be referenced.
 *
 * Internally, within the FreeRTOS implementation, queues use two blocks of
 * memory.  The first block is used to hold the queue's data structures.  The
 * second block is used to hold items placed into the queue.  If a queue is
 * created using xQueueCreate() then both blocks of memory are automatically
 * dynamically allocated inside the xQueueCreate() function.  (see
 * https://www.FreeRTOS.org/a00111.html).  If a queue is created using
 * xQueueCreateStatic() then the application writer must provide the memory that
 * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
 * be created without using any dynamic memory allocation.
 *
 * https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
 *
 * @param uxQueueLength The maximum number of items that the queue can contain.
 *
 * @param uxItemSize The number of bytes each item in the queue will require.
 * Items are queued by copy, not by reference, so this is the number of bytes
 * that will be copied for each posted item.  Each item on the queue must be
 * the same size.
 *
 * @return If the queue is successfully create then a handle to the newly
 * created queue is returned.  If the queue cannot be created then 0 is
 * returned.
 *
 * Example usage:
 * @code{c}
 * struct AMessage
 * {
 *  char ucMessageID;
 *  char ucData[ 20 ];
 * };
 *
 * void vATask( void *pvParameters )
 * {
 * QueueHandle_t xQueue1, xQueue2;
 *
 *  // Create a queue capable of containing 10 uint32_t values.
 *  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
 *  if( xQueue1 == 0 )
 *  {
 *      // Queue was not created and must not be used.
 *  }
 *
 *  // Create a queue capable of containing 10 pointers to AMessage structures.
 *  // These should be passed by pointer as they contain a lot of data.
 *  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
 *  if( xQueue2 == 0 )
 *  {
 *      // Queue was not created and must not be used.
 *  }
 *
 *  // ... Rest of task code.
 * }
 * @endcode
 * \defgroup xQueueCreate xQueueCreate
 * \ingroup QueueManagement
 *//* For internal use only.  These definitions *must* match those in queue.c. *//**
 * Queue sets can contain both queues and semaphores, so the
 * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
 * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
 *//**
 * Type by which queue sets are referenced.  For example, a call to
 * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
 * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
 *//* Using old naming convention so as not to break kernel aware debuggers. *//**
 * Type by which queues are referenced.  For example, a call to xQueueCreate()
 * returns an QueueHandle_t variable that can then be used as a parameter to
 * xQueueSend(), xQueueReceive(), etc.
 */xQueueuxQueueNumberxNewQueuexQueueSetxQueueOrSemaphoreuxEventQueueLengthuxQueueLengthuxItemSizepucQueueStoragepxStaticQueueucQueueTypepcQueueNamexMutexxSemaphoreuxMaxCountuxInitialCountpvBufferpvItemToQueuepxTaskWokenxCoRoutinePreviouslyWokenxCopyPositionuxTimerGetTimerNumbervTimerSetTimerNumberxTimerCreateTimerTaskxTimerGetReloadModexTimerPendFunctionCallxTimerPendFunctionCallFromISRconst TimerHandle_ttmrTimerControl *xTimerCreateStaticStaticTimer_t *xSTATIC_TIMER *xTimerCreatePendedFunction_ttmrTimerControlxTimerResetFromISR(xTimer,pxHigherPriorityTaskWoken)xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )xTimerChangePeriodFromISR(xTimer,xNewPeriod,pxHigherPriorityTaskWoken)xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD_FROM_ISR, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )xTimerStopFromISR(xTimer,pxHigherPriorityTaskWoken)xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP_FROM_ISR, 0, ( pxHigherPriorityTaskWoken ), 0U )xTimerStartFromISR(xTimer,pxHigherPriorityTaskWoken)xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )xTimerReset(xTimer,xTicksToWait)xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )xTimerDelete(xTimer,xTicksToWait)xTimerGenericCommand( ( xTimer ), tmrCOMMAND_DELETE, 0U, NULL, ( xTicksToWait ) )xTimerChangePeriod(xTimer,xNewPeriod,xTicksToWait)xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD, ( xNewPeriod ), NULL, ( xTicksToWait ) )xTimerStop(xTimer,xTicksToWait)xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP, 0U, NULL, ( xTicksToWait ) )xTimerStart(xTimer,xTicksToWait)xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )tmrCOMMAND_CHANGE_PERIOD_FROM_ISR( ( BaseType_t ) 9 )tmrCOMMAND_STOP_FROM_ISR( ( BaseType_t ) 8 )tmrCOMMAND_RESET_FROM_ISR( ( BaseType_t ) 7 )tmrCOMMAND_START_FROM_ISR( ( BaseType_t ) 6 )tmrFIRST_FROM_ISR_COMMANDtmrCOMMAND_DELETE( ( BaseType_t ) 5 )tmrCOMMAND_CHANGE_PERIOD( ( BaseType_t ) 4 )tmrCOMMAND_STOP( ( BaseType_t ) 3 )tmrCOMMAND_RESETtmrCOMMAND_STARTtmrCOMMAND_START_DONT_TRACEtmrCOMMAND_EXECUTE_CALLBACK( ( BaseType_t ) -1 )tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR( ( BaseType_t ) -2 )TIMERS_H/* TIMERS_H *//**
 * task.h
 * @code{c}
 * void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer, StackType_t ** ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize )
 * @endcode
 *
 * This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Timer Task TCB.  This function is required when
 * configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION
 *
 * @param ppxTimerTaskTCBBuffer   A handle to a statically allocated TCB buffer
 * @param ppxTimerTaskStackBuffer A handle to a statically allocated Stack buffer for the idle task
 * @param pulTimerTaskStackSize   A pointer to the number of elements that will fit in the allocated stack buffer
 *//*
 * Functions beyond this part are not part of the public API and are intended
 * for use by the kernel only.
 *//**
 * TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );
 *
 * Returns the time in ticks at which the timer will expire.  If this is less
 * than the current tick count then the expiry time has overflowed from the
 * current time.
 *
 * @param xTimer The handle of the timer being queried.
 *
 * @return If the timer is running then the time in ticks at which the timer
 * will next expire is returned.  If the timer is not running then the return
 * value is undefined.
 *//**
 * TickType_t xTimerGetPeriod( TimerHandle_t xTimer );
 *
 * Returns the period of a timer.
 *
 * @param xTimer The handle of the timer being queried.
 *
 * @return The period of the timer in ticks.
 *//**
 * UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer );
 *
 * Queries a timer to determine if it is an auto-reload timer, in which case the timer
 * automatically resets itself each time it expires, or a one-shot timer, in
 * which case the timer will only expire once unless it is manually restarted.
 *
 * @param xTimer The handle of the timer being queried.
 *
 * @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise
 * pdFALSE is returned.
 *//**
 * BaseType_t xTimerGetReloadMode( TimerHandle_t xTimer );
 *
 * Queries a timer to determine if it is an auto-reload timer, in which case the timer
 * automatically resets itself each time it expires, or a one-shot timer, in
 * which case the timer will only expire once unless it is manually restarted.
 *
 * @param xTimer The handle of the timer being queried.
 *
 * @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise
 * pdFALSE is returned.
 *//**
 * void vTimerSetReloadMode( TimerHandle_t xTimer, const BaseType_t xAutoReload );
 *
 * Updates a timer to be either an auto-reload timer, in which case the timer
 * automatically resets itself each time it expires, or a one-shot timer, in
 * which case the timer will only expire once unless it is manually restarted.
 *
 * @param xTimer The handle of the timer being updated.
 *
 * @param xAutoReload If xAutoReload is set to pdTRUE then the timer will
 * expire repeatedly with a frequency set by the timer's period (see the
 * xTimerPeriodInTicks parameter of the xTimerCreate() API function).  If
 * xAutoReload is set to pdFALSE then the timer will be a one-shot timer and
 * enter the dormant state after it expires.
 *//**
 * const char * const pcTimerGetName( TimerHandle_t xTimer );
 *
 * Returns the name that was assigned to a timer when the timer was created.
 *
 * @param xTimer The handle of the timer being queried.
 *
 * @return The name assigned to the timer specified by the xTimer parameter.
 *//**
 * BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
 *                                    void *pvParameter1,
 *                                    uint32_t ulParameter2,
 *                                    TickType_t xTicksToWait );
 *
 *
 * Used to defer the execution of a function to the RTOS daemon task (the timer
 * service task, hence this function is implemented in timers.c and is prefixed
 * with 'Timer').
 *
 * @param xFunctionToPend The function to execute from the timer service/
 * daemon task.  The function must conform to the PendedFunction_t
 * prototype.
 *
 * @param pvParameter1 The value of the callback function's first parameter.
 * The parameter has a void * type to allow it to be used to pass any type.
 * For example, unsigned longs can be cast to a void *, or the void * can be
 * used to point to a structure.
 *
 * @param ulParameter2 The value of the callback function's second parameter.
 *
 * @param xTicksToWait Calling this function will result in a message being
 * sent to the timer daemon task on a queue.  xTicksToWait is the amount of
 * time the calling task should remain in the Blocked state (so not using any
 * processing time) for space to become available on the timer queue if the
 * queue is found to be full.
 *
 * @return pdPASS is returned if the message was successfully sent to the
 * timer daemon task, otherwise pdFALSE is returned.
 *
 *//**
 * BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,
 *                                          void *pvParameter1,
 *                                          uint32_t ulParameter2,
 *                                          BaseType_t *pxHigherPriorityTaskWoken );
 *
 *
 * Used from application interrupt service routines to defer the execution of a
 * function to the RTOS daemon task (the timer service task, hence this function
 * is implemented in timers.c and is prefixed with 'Timer').
 *
 * Ideally an interrupt service routine (ISR) is kept as short as possible, but
 * sometimes an ISR either has a lot of processing to do, or needs to perform
 * processing that is not deterministic.  In these cases
 * xTimerPendFunctionCallFromISR() can be used to defer processing of a function
 * to the RTOS daemon task.
 *
 * A mechanism is provided that allows the interrupt to return directly to the
 * task that will subsequently execute the pended callback function.  This
 * allows the callback function to execute contiguously in time with the
 * interrupt - just as if the callback had executed in the interrupt itself.
 *
 * @param xFunctionToPend The function to execute from the timer service/
 * daemon task.  The function must conform to the PendedFunction_t
 * prototype.
 *
 * @param pvParameter1 The value of the callback function's first parameter.
 * The parameter has a void * type to allow it to be used to pass any type.
 * For example, unsigned longs can be cast to a void *, or the void * can be
 * used to point to a structure.
 *
 * @param ulParameter2 The value of the callback function's second parameter.
 *
 * @param pxHigherPriorityTaskWoken As mentioned above, calling this function
 * will result in a message being sent to the timer daemon task.  If the
 * priority of the timer daemon task (which is set using
 * configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of
 * the currently running task (the task the interrupt interrupted) then
 * *pxHigherPriorityTaskWoken will be set to pdTRUE within
 * xTimerPendFunctionCallFromISR(), indicating that a context switch should be
 * requested before the interrupt exits.  For that reason
 * *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
 * example code below.
 *
 * @return pdPASS is returned if the message was successfully sent to the
 * timer daemon task, otherwise pdFALSE is returned.
 *
 * Example usage:
 * @verbatim
 *
 *  // The callback function that will execute in the context of the daemon task.
 *  // Note callback functions must all use this same prototype.
 *  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )
 *  {
 *      BaseType_t xInterfaceToService;
 *
 *      // The interface that requires servicing is passed in the second
 *      // parameter.  The first parameter is not used in this case.
 *      xInterfaceToService = ( BaseType_t ) ulParameter2;
 *
 *      // ...Perform the processing here...
 *  }
 *
 *  // An ISR that receives data packets from multiple interfaces
 *  void vAnISR( void )
 *  {
 *      BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;
 *
 *      // Query the hardware to determine which interface needs processing.
 *      xInterfaceToService = prvCheckInterfaces();
 *
 *      // The actual processing is to be deferred to a task.  Request the
 *      // vProcessInterface() callback function is executed, passing in the
 *      // number of the interface that needs processing.  The interface to
 *      // service is passed in the second parameter.  The first parameter is
 *      // not used in this case.
 *      xHigherPriorityTaskWoken = pdFALSE;
 *      xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );
 *
 *      // If xHigherPriorityTaskWoken is now set to pdTRUE then a context
 *      // switch should be requested.  The macro used is port specific and will
 *      // be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
 *      // the documentation page for the port being used.
 *      portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 *
 *  }
 * @endverbatim
 *//**
 * BaseType_t xTimerResetFromISR(   TimerHandle_t xTimer,
 *                                  BaseType_t *pxHigherPriorityTaskWoken );
 *
 * A version of xTimerReset() that can be called from an interrupt service
 * routine.
 *
 * @param xTimer The handle of the timer that is to be started, reset, or
 * restarted.
 *
 * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
 * of its time in the Blocked state, waiting for messages to arrive on the timer
 * command queue.  Calling xTimerResetFromISR() writes a message to the timer
 * command queue, so has the potential to transition the timer service/daemon
 * task out of the Blocked state.  If calling xTimerResetFromISR() causes the
 * timer service/daemon task to leave the Blocked state, and the timer service/
 * daemon task has a priority equal to or greater than the currently executing
 * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
 * get set to pdTRUE internally within the xTimerResetFromISR() function.  If
 * xTimerResetFromISR() sets this value to pdTRUE then a context switch should
 * be performed before the interrupt exits.
 *
 * @return pdFAIL will be returned if the reset command could not be sent to
 * the timer command queue.  pdPASS will be returned if the command was
 * successfully sent to the timer command queue.  When the command is actually
 * processed will depend on the priority of the timer service/daemon task
 * relative to other tasks in the system, although the timers expiry time is
 * relative to when xTimerResetFromISR() is actually called.  The timer service/daemon
 * task priority is set by the configTIMER_TASK_PRIORITY configuration constant.
 *
 * Example usage:
 * @verbatim
 * // This scenario assumes xBacklightTimer has already been created.  When a
 * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
 * // without a key being pressed, then the LCD back-light is switched off.  In
 * // this case, the timer is a one-shot timer, and unlike the example given for
 * // the xTimerReset() function, the key press event handler is an interrupt
 * // service routine.
 *
 * // The callback function assigned to the one-shot timer.  In this case the
 * // parameter is not used.
 * void vBacklightTimerCallback( TimerHandle_t pxTimer )
 * {
 *     // The timer expired, therefore 5 seconds must have passed since a key
 *     // was pressed.  Switch off the LCD back-light.
 *     vSetBacklightState( BACKLIGHT_OFF );
 * }
 *
 * // The key press interrupt service routine.
 * void vKeyPressEventInterruptHandler( void )
 * {
 * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 *
 *     // Ensure the LCD back-light is on, then reset the timer that is
 *     // responsible for turning the back-light off after 5 seconds of
 *     // key inactivity.  This is an interrupt service routine so can only
 *     // call FreeRTOS API functions that end in "FromISR".
 *     vSetBacklightState( BACKLIGHT_ON );
 *
 *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
 *     // as both cause the timer to re-calculate its expiry time.
 *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
 *     // declared (in this function).
 *     if( xTimerResetFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
 *     {
 *         // The reset command was not executed successfully.  Take appropriate
 *         // action here.
 *     }
 *
 *     // Perform the rest of the key processing here.
 *
 *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
 *     // should be performed.  The syntax required to perform a context switch
 *     // from inside an ISR varies from port to port, and from compiler to
 *     // compiler.  Inspect the demos for the port you are using to find the
 *     // actual syntax required.
 *     if( xHigherPriorityTaskWoken != pdFALSE )
 *     {
 *         // Call the interrupt safe yield function here (actual function
 *         // depends on the FreeRTOS port being used).
 *     }
 * }
 * @endverbatim
 *//**
 * BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer,
 *                                       TickType_t xNewPeriod,
 *                                       BaseType_t *pxHigherPriorityTaskWoken );
 *
 * A version of xTimerChangePeriod() that can be called from an interrupt
 * service routine.
 *
 * @param xTimer The handle of the timer that is having its period changed.
 *
 * @param xNewPeriod The new period for xTimer. Timer periods are specified in
 * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
 * that has been specified in milliseconds.  For example, if the timer must
 * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
 * if the timer must expire after 500ms, then xNewPeriod can be set to
 * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
 * or equal to 1000.
 *
 * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
 * of its time in the Blocked state, waiting for messages to arrive on the timer
 * command queue.  Calling xTimerChangePeriodFromISR() writes a message to the
 * timer command queue, so has the potential to transition the timer service/
 * daemon task out of the Blocked state.  If calling xTimerChangePeriodFromISR()
 * causes the timer service/daemon task to leave the Blocked state, and the
 * timer service/daemon task has a priority equal to or greater than the
 * currently executing task (the task that was interrupted), then
 * *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the
 * xTimerChangePeriodFromISR() function.  If xTimerChangePeriodFromISR() sets
 * this value to pdTRUE then a context switch should be performed before the
 * interrupt exits.
 *
 * @return pdFAIL will be returned if the command to change the timers period
 * could not be sent to the timer command queue.  pdPASS will be returned if the
 * command was successfully sent to the timer command queue.  When the command
 * is actually processed will depend on the priority of the timer service/daemon
 * task relative to other tasks in the system.  The timer service/daemon task
 * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
 *
 * Example usage:
 * @verbatim
 * // This scenario assumes xTimer has already been created and started.  When
 * // an interrupt occurs, the period of xTimer should be changed to 500ms.
 *
 * // The interrupt service routine that changes the period of xTimer.
 * void vAnExampleInterruptServiceRoutine( void )
 * {
 * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 *
 *     // The interrupt has occurred - change the period of xTimer to 500ms.
 *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
 *     // (within this function).  As this is an interrupt service routine, only
 *     // FreeRTOS API functions that end in "FromISR" can be used.
 *     if( xTimerChangePeriodFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
 *     {
 *         // The command to change the timers period was not executed
 *         // successfully.  Take appropriate action here.
 *     }
 *
 *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
 *     // should be performed.  The syntax required to perform a context switch
 *     // from inside an ISR varies from port to port, and from compiler to
 *     // compiler.  Inspect the demos for the port you are using to find the
 *     // actual syntax required.
 *     if( xHigherPriorityTaskWoken != pdFALSE )
 *     {
 *         // Call the interrupt safe yield function here (actual function
 *         // depends on the FreeRTOS port being used).
 *     }
 * }
 * @endverbatim
 *//**
 * BaseType_t xTimerStopFromISR(    TimerHandle_t xTimer,
 *                                  BaseType_t *pxHigherPriorityTaskWoken );
 *
 * A version of xTimerStop() that can be called from an interrupt service
 * routine.
 *
 * @param xTimer The handle of the timer being stopped.
 *
 * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
 * of its time in the Blocked state, waiting for messages to arrive on the timer
 * command queue.  Calling xTimerStopFromISR() writes a message to the timer
 * command queue, so has the potential to transition the timer service/daemon
 * task out of the Blocked state.  If calling xTimerStopFromISR() causes the
 * timer service/daemon task to leave the Blocked state, and the timer service/
 * daemon task has a priority equal to or greater than the currently executing
 * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
 * get set to pdTRUE internally within the xTimerStopFromISR() function.  If
 * xTimerStopFromISR() sets this value to pdTRUE then a context switch should
 * be performed before the interrupt exits.
 *
 * @return pdFAIL will be returned if the stop command could not be sent to
 * the timer command queue.  pdPASS will be returned if the command was
 * successfully sent to the timer command queue.  When the command is actually
 * processed will depend on the priority of the timer service/daemon task
 * relative to other tasks in the system.  The timer service/daemon task
 * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
 *
 * Example usage:
 * @verbatim
 * // This scenario assumes xTimer has already been created and started.  When
 * // an interrupt occurs, the timer should be simply stopped.
 *
 * // The interrupt service routine that stops the timer.
 * void vAnExampleInterruptServiceRoutine( void )
 * {
 * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 *
 *     // The interrupt has occurred - simply stop the timer.
 *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
 *     // (within this function).  As this is an interrupt service routine, only
 *     // FreeRTOS API functions that end in "FromISR" can be used.
 *     if( xTimerStopFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
 *     {
 *         // The stop command was not executed successfully.  Take appropriate
 *         // action here.
 *     }
 *
 *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
 *     // should be performed.  The syntax required to perform a context switch
 *     // from inside an ISR varies from port to port, and from compiler to
 *     // compiler.  Inspect the demos for the port you are using to find the
 *     // actual syntax required.
 *     if( xHigherPriorityTaskWoken != pdFALSE )
 *     {
 *         // Call the interrupt safe yield function here (actual function
 *         // depends on the FreeRTOS port being used).
 *     }
 * }
 * @endverbatim
 *//**
 * BaseType_t xTimerStartFromISR(   TimerHandle_t xTimer,
 *                                  BaseType_t *pxHigherPriorityTaskWoken );
 *
 * A version of xTimerStart() that can be called from an interrupt service
 * routine.
 *
 * @param xTimer The handle of the timer being started/restarted.
 *
 * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
 * of its time in the Blocked state, waiting for messages to arrive on the timer
 * command queue.  Calling xTimerStartFromISR() writes a message to the timer
 * command queue, so has the potential to transition the timer service/daemon
 * task out of the Blocked state.  If calling xTimerStartFromISR() causes the
 * timer service/daemon task to leave the Blocked state, and the timer service/
 * daemon task has a priority equal to or greater than the currently executing
 * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
 * get set to pdTRUE internally within the xTimerStartFromISR() function.  If
 * xTimerStartFromISR() sets this value to pdTRUE then a context switch should
 * be performed before the interrupt exits.
 *
 * @return pdFAIL will be returned if the start command could not be sent to
 * the timer command queue.  pdPASS will be returned if the command was
 * successfully sent to the timer command queue.  When the command is actually
 * processed will depend on the priority of the timer service/daemon task
 * relative to other tasks in the system, although the timers expiry time is
 * relative to when xTimerStartFromISR() is actually called.  The timer
 * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
 * configuration constant.
 *
 * Example usage:
 * @verbatim
 * // This scenario assumes xBacklightTimer has already been created.  When a
 * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
 * // without a key being pressed, then the LCD back-light is switched off.  In
 * // this case, the timer is a one-shot timer, and unlike the example given for
 * // the xTimerReset() function, the key press event handler is an interrupt
 * // service routine.
 *
 * // The callback function assigned to the one-shot timer.  In this case the
 * // parameter is not used.
 * void vBacklightTimerCallback( TimerHandle_t pxTimer )
 * {
 *     // The timer expired, therefore 5 seconds must have passed since a key
 *     // was pressed.  Switch off the LCD back-light.
 *     vSetBacklightState( BACKLIGHT_OFF );
 * }
 *
 * // The key press interrupt service routine.
 * void vKeyPressEventInterruptHandler( void )
 * {
 * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 *
 *     // Ensure the LCD back-light is on, then restart the timer that is
 *     // responsible for turning the back-light off after 5 seconds of
 *     // key inactivity.  This is an interrupt service routine so can only
 *     // call FreeRTOS API functions that end in "FromISR".
 *     vSetBacklightState( BACKLIGHT_ON );
 *
 *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
 *     // as both cause the timer to re-calculate its expiry time.
 *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
 *     // declared (in this function).
 *     if( xTimerStartFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
 *     {
 *         // The start command was not executed successfully.  Take appropriate
 *         // action here.
 *     }
 *
 *     // Perform the rest of the key processing here.
 *
 *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
 *     // should be performed.  The syntax required to perform a context switch
 *     // from inside an ISR varies from port to port, and from compiler to
 *     // compiler.  Inspect the demos for the port you are using to find the
 *     // actual syntax required.
 *     if( xHigherPriorityTaskWoken != pdFALSE )
 *     {
 *         // Call the interrupt safe yield function here (actual function
 *         // depends on the FreeRTOS port being used).
 *     }
 * }
 * @endverbatim
 *//**
 * BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );
 *
 * Timer functionality is provided by a timer service/daemon task.  Many of the
 * public FreeRTOS timer API functions send commands to the timer service task
 * through a queue called the timer command queue.  The timer command queue is
 * private to the kernel itself and is not directly accessible to application
 * code.  The length of the timer command queue is set by the
 * configTIMER_QUEUE_LENGTH configuration constant.
 *
 * xTimerReset() re-starts a timer that was previously created using the
 * xTimerCreate() API function.  If the timer had already been started and was
 * already in the active state, then xTimerReset() will cause the timer to
 * re-evaluate its expiry time so that it is relative to when xTimerReset() was
 * called.  If the timer was in the dormant state then xTimerReset() has
 * equivalent functionality to the xTimerStart() API function.
 *
 * Resetting a timer ensures the timer is in the active state.  If the timer
 * is not stopped, deleted, or reset in the mean time, the callback function
 * associated with the timer will get called 'n' ticks after xTimerReset() was
 * called, where 'n' is the timers defined period.
 *
 * It is valid to call xTimerReset() before the scheduler has been started, but
 * when this is done the timer will not actually start until the scheduler is
 * started, and the timers expiry time will be relative to when the scheduler is
 * started, not relative to when xTimerReset() was called.
 *
 * The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset()
 * to be available.
 *
 * @param xTimer The handle of the timer being reset/started/restarted.
 *
 * @param xTicksToWait Specifies the time, in ticks, that the calling task should
 * be held in the Blocked state to wait for the reset command to be successfully
 * sent to the timer command queue, should the queue already be full when
 * xTimerReset() was called.  xTicksToWait is ignored if xTimerReset() is called
 * before the scheduler is started.
 *
 * @return pdFAIL will be returned if the reset command could not be sent to
 * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
 * be returned if the command was successfully sent to the timer command queue.
 * When the command is actually processed will depend on the priority of the
 * timer service/daemon task relative to other tasks in the system, although the
 * timers expiry time is relative to when xTimerStart() is actually called.  The
 * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
 * configuration constant.
 *
 * Example usage:
 * @verbatim
 * // When a key is pressed, an LCD back-light is switched on.  If 5 seconds pass
 * // without a key being pressed, then the LCD back-light is switched off.  In
 * // this case, the timer is a one-shot timer.
 *
 * TimerHandle_t xBacklightTimer = NULL;
 *
 * // The callback function assigned to the one-shot timer.  In this case the
 * // parameter is not used.
 * void vBacklightTimerCallback( TimerHandle_t pxTimer )
 * {
 *     // The timer expired, therefore 5 seconds must have passed since a key
 *     // was pressed.  Switch off the LCD back-light.
 *     vSetBacklightState( BACKLIGHT_OFF );
 * }
 *
 * // The key press event handler.
 * void vKeyPressEventHandler( char cKey )
 * {
 *     // Ensure the LCD back-light is on, then reset the timer that is
 *     // responsible for turning the back-light off after 5 seconds of
 *     // key inactivity.  Wait 10 ticks for the command to be successfully sent
 *     // if it cannot be sent immediately.
 *     vSetBacklightState( BACKLIGHT_ON );
 *     if( xTimerReset( xBacklightTimer, 100 ) != pdPASS )
 *     {
 *         // The reset command was not executed successfully.  Take appropriate
 *         // action here.
 *     }
 *
 *     // Perform the rest of the key processing here.
 * }
 *
 * void main( void )
 * {
 * int32_t x;
 *
 *     // Create then start the one-shot timer that is responsible for turning
 *     // the back-light off if no keys are pressed within a 5 second period.
 *     xBacklightTimer = xTimerCreate( "BacklightTimer",           // Just a text name, not used by the kernel.
 *                                     ( 5000 / portTICK_PERIOD_MS), // The timer period in ticks.
 *                                     pdFALSE,                    // The timer is a one-shot timer.
 *                                     0,                          // The id is not used by the callback so can take any value.
 *                                     vBacklightTimerCallback     // The callback function that switches the LCD back-light off.
 *                                   );
 *
 *     if( xBacklightTimer == NULL )
 *     {
 *         // The timer was not created.
 *     }
 *     else
 *     {
 *         // Start the timer.  No block time is specified, and even if one was
 *         // it would be ignored because the scheduler has not yet been
 *         // started.
 *         if( xTimerStart( xBacklightTimer, 0 ) != pdPASS )
 *         {
 *             // The timer could not be set into the Active state.
 *         }
 *     }
 *
 *     // ...
 *     // Create tasks here.
 *     // ...
 *
 *     // Starting the scheduler will start the timer running as it has already
 *     // been set into the active state.
 *     vTaskStartScheduler();
 *
 *     // Should not reach here.
 *     for( ;; );
 * }
 * @endverbatim
 *//**
 * BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait );
 *
 * Timer functionality is provided by a timer service/daemon task.  Many of the
 * public FreeRTOS timer API functions send commands to the timer service task
 * through a queue called the timer command queue.  The timer command queue is
 * private to the kernel itself and is not directly accessible to application
 * code.  The length of the timer command queue is set by the
 * configTIMER_QUEUE_LENGTH configuration constant.
 *
 * xTimerDelete() deletes a timer that was previously created using the
 * xTimerCreate() API function.
 *
 * The configUSE_TIMERS configuration constant must be set to 1 for
 * xTimerDelete() to be available.
 *
 * @param xTimer The handle of the timer being deleted.
 *
 * @param xTicksToWait Specifies the time, in ticks, that the calling task should
 * be held in the Blocked state to wait for the delete command to be
 * successfully sent to the timer command queue, should the queue already be
 * full when xTimerDelete() was called.  xTicksToWait is ignored if xTimerDelete()
 * is called before the scheduler is started.
 *
 * @return pdFAIL will be returned if the delete command could not be sent to
 * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
 * be returned if the command was successfully sent to the timer command queue.
 * When the command is actually processed will depend on the priority of the
 * timer service/daemon task relative to other tasks in the system.  The timer
 * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
 * configuration constant.
 *
 * Example usage:
 *
 * See the xTimerChangePeriod() API function example usage scenario.
 *//**
 * BaseType_t xTimerChangePeriod(   TimerHandle_t xTimer,
 *                                  TickType_t xNewPeriod,
 *                                  TickType_t xTicksToWait );
 *
 * Timer functionality is provided by a timer service/daemon task.  Many of the
 * public FreeRTOS timer API functions send commands to the timer service task
 * through a queue called the timer command queue.  The timer command queue is
 * private to the kernel itself and is not directly accessible to application
 * code.  The length of the timer command queue is set by the
 * configTIMER_QUEUE_LENGTH configuration constant.
 *
 * xTimerChangePeriod() changes the period of a timer that was previously
 * created using the xTimerCreate() API function.
 *
 * xTimerChangePeriod() can be called to change the period of an active or
 * dormant state timer.
 *
 * The configUSE_TIMERS configuration constant must be set to 1 for
 * xTimerChangePeriod() to be available.
 *
 * @param xTimer The handle of the timer that is having its period changed.
 *
 * @param xNewPeriod The new period for xTimer. Timer periods are specified in
 * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
 * that has been specified in milliseconds.  For example, if the timer must
 * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
 * if the timer must expire after 500ms, then xNewPeriod can be set to
 * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
 * or equal to 1000.
 *
 * @param xTicksToWait Specifies the time, in ticks, that the calling task should
 * be held in the Blocked state to wait for the change period command to be
 * successfully sent to the timer command queue, should the queue already be
 * full when xTimerChangePeriod() was called.  xTicksToWait is ignored if
 * xTimerChangePeriod() is called before the scheduler is started.
 *
 * @return pdFAIL will be returned if the change period command could not be
 * sent to the timer command queue even after xTicksToWait ticks had passed.
 * pdPASS will be returned if the command was successfully sent to the timer
 * command queue.  When the command is actually processed will depend on the
 * priority of the timer service/daemon task relative to other tasks in the
 * system.  The timer service/daemon task priority is set by the
 * configTIMER_TASK_PRIORITY configuration constant.
 *
 * Example usage:
 * @verbatim
 * // This function assumes xTimer has already been created.  If the timer
 * // referenced by xTimer is already active when it is called, then the timer
 * // is deleted.  If the timer referenced by xTimer is not active when it is
 * // called, then the period of the timer is set to 500ms and the timer is
 * // started.
 * void vAFunction( TimerHandle_t xTimer )
 * {
 *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
 *     {
 *         // xTimer is already active - delete it.
 *         xTimerDelete( xTimer );
 *     }
 *     else
 *     {
 *         // xTimer is not active, change its period to 500ms.  This will also
 *         // cause the timer to start.  Block for a maximum of 100 ticks if the
 *         // change period command cannot immediately be sent to the timer
 *         // command queue.
 *         if( xTimerChangePeriod( xTimer, 500 / portTICK_PERIOD_MS, 100 ) == pdPASS )
 *         {
 *             // The command was successfully sent.
 *         }
 *         else
 *         {
 *             // The command could not be sent, even after waiting for 100 ticks
 *             // to pass.  Take appropriate action here.
 *         }
 *     }
 * }
 * @endverbatim
 *//**
 * BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );
 *
 * Timer functionality is provided by a timer service/daemon task.  Many of the
 * public FreeRTOS timer API functions send commands to the timer service task
 * through a queue called the timer command queue.  The timer command queue is
 * private to the kernel itself and is not directly accessible to application
 * code.  The length of the timer command queue is set by the
 * configTIMER_QUEUE_LENGTH configuration constant.
 *
 * xTimerStop() stops a timer that was previously started using either of the
 * The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(),
 * xTimerChangePeriod() or xTimerChangePeriodFromISR() API functions.
 *
 * Stopping a timer ensures the timer is not in the active state.
 *
 * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop()
 * to be available.
 *
 * @param xTimer The handle of the timer being stopped.
 *
 * @param xTicksToWait Specifies the time, in ticks, that the calling task should
 * be held in the Blocked state to wait for the stop command to be successfully
 * sent to the timer command queue, should the queue already be full when
 * xTimerStop() was called.  xTicksToWait is ignored if xTimerStop() is called
 * before the scheduler is started.
 *
 * @return pdFAIL will be returned if the stop command could not be sent to
 * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
 * be returned if the command was successfully sent to the timer command queue.
 * When the command is actually processed will depend on the priority of the
 * timer service/daemon task relative to other tasks in the system.  The timer
 * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
 * configuration constant.
 *
 * Example usage:
 *
 * See the xTimerCreate() API function example usage scenario.
 *
 *//**
 * BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );
 *
 * Timer functionality is provided by a timer service/daemon task.  Many of the
 * public FreeRTOS timer API functions send commands to the timer service task
 * through a queue called the timer command queue.  The timer command queue is
 * private to the kernel itself and is not directly accessible to application
 * code.  The length of the timer command queue is set by the
 * configTIMER_QUEUE_LENGTH configuration constant.
 *
 * xTimerStart() starts a timer that was previously created using the
 * xTimerCreate() API function.  If the timer had already been started and was
 * already in the active state, then xTimerStart() has equivalent functionality
 * to the xTimerReset() API function.
 *
 * Starting a timer ensures the timer is in the active state.  If the timer
 * is not stopped, deleted, or reset in the mean time, the callback function
 * associated with the timer will get called 'n' ticks after xTimerStart() was
 * called, where 'n' is the timers defined period.
 *
 * It is valid to call xTimerStart() before the scheduler has been started, but
 * when this is done the timer will not actually start until the scheduler is
 * started, and the timers expiry time will be relative to when the scheduler is
 * started, not relative to when xTimerStart() was called.
 *
 * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart()
 * to be available.
 *
 * @param xTimer The handle of the timer being started/restarted.
 *
 * @param xTicksToWait Specifies the time, in ticks, that the calling task should
 * be held in the Blocked state to wait for the start command to be successfully
 * sent to the timer command queue, should the queue already be full when
 * xTimerStart() was called.  xTicksToWait is ignored if xTimerStart() is called
 * before the scheduler is started.
 *
 * @return pdFAIL will be returned if the start command could not be sent to
 * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
 * be returned if the command was successfully sent to the timer command queue.
 * When the command is actually processed will depend on the priority of the
 * timer service/daemon task relative to other tasks in the system, although the
 * timers expiry time is relative to when xTimerStart() is actually called.  The
 * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
 * configuration constant.
 *
 * Example usage:
 *
 * See the xTimerCreate() API function example usage scenario.
 *
 *//**
 * TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );
 *
 * Simply returns the handle of the timer service/daemon task.  It it not valid
 * to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started.
 *//**
 * BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );
 *
 * Queries a timer to see if it is active or dormant.
 *
 * A timer will be dormant if:
 *     1) It has been created but not started, or
 *     2) It is an expired one-shot timer that has not been restarted.
 *
 * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
 * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
 * xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the
 * active state.
 *
 * @param xTimer The timer being queried.
 *
 * @return pdFALSE will be returned if the timer is dormant.  A value other than
 * pdFALSE will be returned if the timer is active.
 *
 * Example usage:
 * @verbatim
 * // This function assumes xTimer has already been created.
 * void vAFunction( TimerHandle_t xTimer )
 * {
 *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
 *     {
 *         // xTimer is active, do something.
 *     }
 *     else
 *     {
 *         // xTimer is not active, do something else.
 *     }
 * }
 * @endverbatim
 *//**
 * void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );
 *
 * Sets the ID assigned to the timer.
 *
 * IDs are assigned to timers using the pvTimerID parameter of the call to
 * xTimerCreated() that was used to create the timer.
 *
 * If the same callback function is assigned to multiple timers then the timer
 * ID can be used as time specific (timer local) storage.
 *
 * @param xTimer The timer being updated.
 *
 * @param pvNewID The ID to assign to the timer.
 *
 * Example usage:
 *
 * See the xTimerCreate() API function example usage scenario.
 *//**
 * void *pvTimerGetTimerID( TimerHandle_t xTimer );
 *
 * Returns the ID assigned to the timer.
 *
 * IDs are assigned to timers using the pvTimerID parameter of the call to
 * xTimerCreated() that was used to create the timer, and by calling the
 * vTimerSetTimerID() API function.
 *
 * If the same callback function is assigned to multiple timers then the timer
 * ID can be used as time specific (timer local) storage.
 *
 * @param xTimer The timer being queried.
 *
 * @return The ID assigned to the timer being queried.
 *
 * Example usage:
 *
 * See the xTimerCreate() API function example usage scenario.
 *//**
 * TimerHandle_t xTimerCreateStatic(const char * const pcTimerName,
 *                                  TickType_t xTimerPeriodInTicks,
 *                                  BaseType_t xAutoReload,
 *                                  void * pvTimerID,
 *                                  TimerCallbackFunction_t pxCallbackFunction,
 *                                  StaticTimer_t *pxTimerBuffer );
 *
 * Creates a new software timer instance, and returns a handle by which the
 * created software timer can be referenced.
 *
 * Internally, within the FreeRTOS implementation, software timers use a block
 * of memory, in which the timer data structure is stored.  If a software timer
 * is created using xTimerCreate() then the required memory is automatically
 * dynamically allocated inside the xTimerCreate() function.  (see
 * https://www.FreeRTOS.org/a00111.html).  If a software timer is created using
 * xTimerCreateStatic() then the application writer must provide the memory that
 * will get used by the software timer.  xTimerCreateStatic() therefore allows a
 * software timer to be created without using any dynamic memory allocation.
 *
 * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
 * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
 * xTimerChangePeriodFromISR() API functions can all be used to transition a
 * timer into the active state.
 *
 * @param pcTimerName A text name that is assigned to the timer.  This is done
 * purely to assist debugging.  The kernel itself only ever references a timer
 * by its handle, and never by its name.
 *
 * @param xTimerPeriodInTicks The timer period.  The time is defined in tick
 * periods so the constant portTICK_PERIOD_MS can be used to convert a time that
 * has been specified in milliseconds.  For example, if the timer must expire
 * after 100 ticks, then xTimerPeriodInTicks should be set to 100.
 * Alternatively, if the timer must expire after 500ms, then xPeriod can be set
 * to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or
 * equal to 1000.  The timer period must be greater than 0.
 *
 * @param xAutoReload If xAutoReload is set to pdTRUE then the timer will
 * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.
 * If xAutoReload is set to pdFALSE then the timer will be a one-shot timer and
 * enter the dormant state after it expires.
 *
 * @param pvTimerID An identifier that is assigned to the timer being created.
 * Typically this would be used in the timer callback function to identify which
 * timer expired when the same callback function is assigned to more than one
 * timer.
 *
 * @param pxCallbackFunction The function to call when the timer expires.
 * Callback functions must have the prototype defined by TimerCallbackFunction_t,
 * which is "void vCallbackFunction( TimerHandle_t xTimer );".
 *
 * @param pxTimerBuffer Must point to a variable of type StaticTimer_t, which
 * will be then be used to hold the software timer's data structures, removing
 * the need for the memory to be allocated dynamically.
 *
 * @return If the timer is created then a handle to the created timer is
 * returned.  If pxTimerBuffer was NULL then NULL is returned.
 *
 * Example usage:
 * @verbatim
 *
 * // The buffer used to hold the software timer's data structure.
 * static StaticTimer_t xTimerBuffer;
 *
 * // A variable that will be incremented by the software timer's callback
 * // function.
 * UBaseType_t uxVariableToIncrement = 0;
 *
 * // A software timer callback function that increments a variable passed to
 * // it when the software timer was created.  After the 5th increment the
 * // callback function stops the software timer.
 * static void prvTimerCallback( TimerHandle_t xExpiredTimer )
 * {
 * UBaseType_t *puxVariableToIncrement;
 * BaseType_t xReturned;
 *
 *     // Obtain the address of the variable to increment from the timer ID.
 *     puxVariableToIncrement = ( UBaseType_t * ) pvTimerGetTimerID( xExpiredTimer );
 *
 *     // Increment the variable to show the timer callback has executed.
 *     ( *puxVariableToIncrement )++;
 *
 *     // If this callback has executed the required number of times, stop the
 *     // timer.
 *     if( *puxVariableToIncrement == 5 )
 *     {
 *         // This is called from a timer callback so must not block.
 *         xTimerStop( xExpiredTimer, staticDONT_BLOCK );
 *     }
 * }
 *
 *
 * void main( void )
 * {
 *     // Create the software time.  xTimerCreateStatic() has an extra parameter
 *     // than the normal xTimerCreate() API function.  The parameter is a pointer
 *     // to the StaticTimer_t structure that will hold the software timer
 *     // structure.  If the parameter is passed as NULL then the structure will be
 *     // allocated dynamically, just as if xTimerCreate() had been called.
 *     xTimer = xTimerCreateStatic( "T1",             // Text name for the task.  Helps debugging only.  Not used by FreeRTOS.
 *                                  xTimerPeriod,     // The period of the timer in ticks.
 *                                  pdTRUE,           // This is an auto-reload timer.
 *                                  ( void * ) &uxVariableToIncrement,    // A variable incremented by the software timer's callback function
 *                                  prvTimerCallback, // The function to execute when the timer expires.
 *                                  &xTimerBuffer );  // The buffer that will hold the software timer structure.
 *
 *     // The scheduler has not started yet so a block time is not used.
 *     xReturned = xTimerStart( xTimer, 0 );
 *
 *     // ...
 *     // Create tasks here.
 *     // ...
 *
 *     // Starting the scheduler will start the timers running as they have already
 *     // been set into the active state.
 *     vTaskStartScheduler();
 *
 *     // Should not reach here.
 *     for( ;; );
 * }
 * @endverbatim
 *//**
 * TimerHandle_t xTimerCreate(  const char * const pcTimerName,
 *                              TickType_t xTimerPeriodInTicks,
 *                              BaseType_t xAutoReload,
 *                              void * pvTimerID,
 *                              TimerCallbackFunction_t pxCallbackFunction );
 *
 * Creates a new software timer instance, and returns a handle by which the
 * created software timer can be referenced.
 *
 * Internally, within the FreeRTOS implementation, software timers use a block
 * of memory, in which the timer data structure is stored.  If a software timer
 * is created using xTimerCreate() then the required memory is automatically
 * dynamically allocated inside the xTimerCreate() function.  (see
 * https://www.FreeRTOS.org/a00111.html).  If a software timer is created using
 * xTimerCreateStatic() then the application writer must provide the memory that
 * will get used by the software timer.  xTimerCreateStatic() therefore allows a
 * software timer to be created without using any dynamic memory allocation.
 *
 * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
 * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
 * xTimerChangePeriodFromISR() API functions can all be used to transition a
 * timer into the active state.
 *
 * @param pcTimerName A text name that is assigned to the timer.  This is done
 * purely to assist debugging.  The kernel itself only ever references a timer
 * by its handle, and never by its name.
 *
 * @param xTimerPeriodInTicks The timer period.  The time is defined in tick
 * periods so the constant portTICK_PERIOD_MS can be used to convert a time that
 * has been specified in milliseconds.  For example, if the timer must expire
 * after 100 ticks, then xTimerPeriodInTicks should be set to 100.
 * Alternatively, if the timer must expire after 500ms, then xPeriod can be set
 * to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or
 * equal to 1000.  Time timer period must be greater than 0.
 *
 * @param xAutoReload If xAutoReload is set to pdTRUE then the timer will
 * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.
 * If xAutoReload is set to pdFALSE then the timer will be a one-shot timer and
 * enter the dormant state after it expires.
 *
 * @param pvTimerID An identifier that is assigned to the timer being created.
 * Typically this would be used in the timer callback function to identify which
 * timer expired when the same callback function is assigned to more than one
 * timer.
 *
 * @param pxCallbackFunction The function to call when the timer expires.
 * Callback functions must have the prototype defined by TimerCallbackFunction_t,
 * which is "void vCallbackFunction( TimerHandle_t xTimer );".
 *
 * @return If the timer is successfully created then a handle to the newly
 * created timer is returned.  If the timer cannot be created because there is
 * insufficient FreeRTOS heap remaining to allocate the timer
 * structures then NULL is returned.
 *
 * Example usage:
 * @verbatim
 * #define NUM_TIMERS 5
 *
 * // An array to hold handles to the created timers.
 * TimerHandle_t xTimers[ NUM_TIMERS ];
 *
 * // An array to hold a count of the number of times each timer expires.
 * int32_t lExpireCounters[ NUM_TIMERS ] = { 0 };
 *
 * // Define a callback function that will be used by multiple timer instances.
 * // The callback function does nothing but count the number of times the
 * // associated timer expires, and stop the timer once the timer has expired
 * // 10 times.
 * void vTimerCallback( TimerHandle_t pxTimer )
 * {
 * int32_t lArrayIndex;
 * const int32_t xMaxExpiryCountBeforeStopping = 10;
 *
 *     // Optionally do something if the pxTimer parameter is NULL.
 *     configASSERT( pxTimer );
 *
 *     // Which timer expired?
 *     lArrayIndex = ( int32_t ) pvTimerGetTimerID( pxTimer );
 *
 *     // Increment the number of times that pxTimer has expired.
 *     lExpireCounters[ lArrayIndex ] += 1;
 *
 *     // If the timer has expired 10 times then stop it from running.
 *     if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
 *     {
 *         // Do not use a block time if calling a timer API function from a
 *         // timer callback function, as doing so could cause a deadlock!
 *         xTimerStop( pxTimer, 0 );
 *     }
 * }
 *
 * void main( void )
 * {
 * int32_t x;
 *
 *     // Create then start some timers.  Starting the timers before the scheduler
 *     // has been started means the timers will start running immediately that
 *     // the scheduler starts.
 *     for( x = 0; x < NUM_TIMERS; x++ )
 *     {
 *         xTimers[ x ] = xTimerCreate(    "Timer",             // Just a text name, not used by the kernel.
 *                                         ( 100 * ( x + 1 ) ), // The timer period in ticks.
 *                                         pdTRUE,              // The timers will auto-reload themselves when they expire.
 *                                         ( void * ) x,        // Assign each timer a unique id equal to its array index.
 *                                         vTimerCallback       // Each timer calls the same callback when it expires.
 *                                     );
 *
 *         if( xTimers[ x ] == NULL )
 *         {
 *             // The timer was not created.
 *         }
 *         else
 *         {
 *             // Start the timer.  No block time is specified, and even if one was
 *             // it would be ignored because the scheduler has not yet been
 *             // started.
 *             if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
 *             {
 *                 // The timer could not be set into the Active state.
 *             }
 *         }
 *     }
 *
 *     // ...
 *     // Create tasks here.
 *     // ...
 *
 *     // Starting the scheduler will start the timers running as they have already
 *     // been set into the active state.
 *     vTaskStartScheduler();
 *
 *     // Should not reach here.
 *     for( ;; );
 * }
 * @endverbatim
 *//*
 * Defines the prototype to which functions used with the
 * xTimerPendFunctionCallFromISR() function must conform.
 *//*
 * Defines the prototype to which timer callback functions must conform.
 *//**
 * Type by which software timers are referenced.  For example, a call to
 * xTimerCreate() returns an TimerHandle_t variable that can then be used to
 * reference the subject timer in calls to other software timer API functions
 * (for example, xTimerStart(), xTimerReset(), etc.).
 *//* IDs for commands that can be sent/received on the timer queue.  These are to
 * be used solely through the macros that make up the public software timer API,
 * as defined below.  The commands that are sent from interrupts must use the
 * highest numbers as tmrFIRST_FROM_ISR_COMMAND is used to determine if the task
 * or interrupt version of the queue send function should be used. *//*lint -restore *//*lint -save -e537 This headers are only multiply included if the application code
 * happens to also be including task.h. */xTimeruxTimerNumberxCommandIDxOptionalValuexAutoReloadxFunctionToPendpvParameter1ulParameter2pvNewIDpcTimerNamexTimerPeriodInTickspvTimerIDpxCallbackFunctionpxTimerBuffer/Users/mac/Downloads/FreeRTOS/Source/include/stream_buffer.hucStreamBufferGetStreamBufferTypeuxStreamBufferGetStreamBufferNumbervStreamBufferSetStreamBufferNumberuint8_t *constStaticStreamBuffer_t *xSTATIC_STREAM_BUFFER *StaticStreamBuffer_t *constxStreamBufferReceiveCompletedFromISRxStreamBufferSendCompletedFromISRxStreamBufferReceiveFromISRxStreamBufferSendFromISRStreamBufferCallbackFunction_tStreamBufferDef_t *StreamBufferHandle_tStreamBufferDef_txStreamBufferCreateStatic(xBufferSizeBytes,xTriggerLevelBytes,pucStreamBufferStorageArea,pxStaticStreamBuffer)xStreamBufferGenericCreateStatic( ( xBufferSizeBytes ), ( xTriggerLevelBytes ), pdFALSE, ( pucStreamBufferStorageArea ), ( pxStaticStreamBuffer ), NULL, NULL )xStreamBufferCreate(xBufferSizeBytes,xTriggerLevelBytes)xStreamBufferGenericCreate( ( xBufferSizeBytes ), ( xTriggerLevelBytes ), pdFALSE, NULL, NULL )STREAM_BUFFER_Hdefined( __cplusplus )/* !defined( STREAM_BUFFER_H ) *//* Functions below here are not part of the public API. *//**
 * stream_buffer.h
 *
 * @code{c}
 * BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
 * @endcode
 *
 * For advanced users only.
 *
 * The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when
 * data is read out of a message buffer or stream buffer.  If there was a task
 * that was blocked on the message or stream buffer waiting for data to arrive
 * then the sbRECEIVE_COMPLETED() macro sends a notification to the task to
 * remove it from the Blocked state.  xStreamBufferReceiveCompletedFromISR()
 * does the same thing.  It is provided to enable application writers to
 * implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT
 * ANY OTHER TIME.
 *
 * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
 * additional information.
 *
 * @param xStreamBuffer The handle of the stream buffer from which data was
 * read.
 *
 * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
 * initialised to pdFALSE before it is passed into
 * xStreamBufferReceiveCompletedFromISR().  If calling
 * xStreamBufferReceiveCompletedFromISR() removes a task from the Blocked state,
 * and the task has a priority above the priority of the currently running task,
 * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
 * context switch should be performed before exiting the ISR.
 *
 * @return If a task was removed from the Blocked state then pdTRUE is returned.
 * Otherwise pdFALSE is returned.
 *
 * \defgroup xStreamBufferReceiveCompletedFromISR xStreamBufferReceiveCompletedFromISR
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
 * @endcode
 *
 * For advanced users only.
 *
 * The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when
 * data is sent to a message buffer or stream buffer.  If there was a task that
 * was blocked on the message or stream buffer waiting for data to arrive then
 * the sbSEND_COMPLETED() macro sends a notification to the task to remove it
 * from the Blocked state.  xStreamBufferSendCompletedFromISR() does the same
 * thing.  It is provided to enable application writers to implement their own
 * version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.
 *
 * See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
 * additional information.
 *
 * @param xStreamBuffer The handle of the stream buffer to which data was
 * written.
 *
 * @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
 * initialised to pdFALSE before it is passed into
 * xStreamBufferSendCompletedFromISR().  If calling
 * xStreamBufferSendCompletedFromISR() removes a task from the Blocked state,
 * and the task has a priority above the priority of the currently running task,
 * then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
 * context switch should be performed before exiting the ISR.
 *
 * @return If a task was removed from the Blocked state then pdTRUE is returned.
 * Otherwise pdFALSE is returned.
 *
 * \defgroup xStreamBufferSendCompletedFromISR xStreamBufferSendCompletedFromISR
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel );
 * @endcode
 *
 * A stream buffer's trigger level is the number of bytes that must be in the
 * stream buffer before a task that is blocked on the stream buffer to
 * wait for data is moved out of the blocked state.  For example, if a task is
 * blocked on a read of an empty stream buffer that has a trigger level of 1
 * then the task will be unblocked when a single byte is written to the buffer
 * or the task's block time expires.  As another example, if a task is blocked
 * on a read of an empty stream buffer that has a trigger level of 10 then the
 * task will not be unblocked until the stream buffer contains at least 10 bytes
 * or the task's block time expires.  If a reading task's block time expires
 * before the trigger level is reached then the task will still receive however
 * many bytes are actually available.  Setting a trigger level of 0 will result
 * in a trigger level of 1 being used.  It is not valid to specify a trigger
 * level that is greater than the buffer size.
 *
 * A trigger level is set when the stream buffer is created, and can be modified
 * using xStreamBufferSetTriggerLevel().
 *
 * @param xStreamBuffer The handle of the stream buffer being updated.
 *
 * @param xTriggerLevel The new trigger level for the stream buffer.
 *
 * @return If xTriggerLevel was less than or equal to the stream buffer's length
 * then the trigger level will be updated and pdTRUE is returned.  Otherwise
 * pdFALSE is returned.
 *
 * \defgroup xStreamBufferSetTriggerLevel xStreamBufferSetTriggerLevel
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer );
 * @endcode
 *
 * Queries a stream buffer to see how much data it contains, which is equal to
 * the number of bytes that can be read from the stream buffer before the stream
 * buffer would be empty.
 *
 * @param xStreamBuffer The handle of the stream buffer being queried.
 *
 * @return The number of bytes that can be read from the stream buffer before
 * the stream buffer would be empty.
 *
 * \defgroup xStreamBufferBytesAvailable xStreamBufferBytesAvailable
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer );
 * @endcode
 *
 * Queries a stream buffer to see how much free space it contains, which is
 * equal to the amount of data that can be sent to the stream buffer before it
 * is full.
 *
 * @param xStreamBuffer The handle of the stream buffer being queried.
 *
 * @return The number of bytes that can be written to the stream buffer before
 * the stream buffer would be full.
 *
 * \defgroup xStreamBufferSpacesAvailable xStreamBufferSpacesAvailable
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer );
 * @endcode
 *
 * Resets a stream buffer to its initial, empty, state.  Any data that was in
 * the stream buffer is discarded.  A stream buffer can only be reset if there
 * are no tasks blocked waiting to either send to or receive from the stream
 * buffer.
 *
 * @param xStreamBuffer The handle of the stream buffer being reset.
 *
 * @return If the stream buffer is reset then pdPASS is returned.  If there was
 * a task blocked waiting to send to or read from the stream buffer then the
 * stream buffer is not reset and pdFAIL is returned.
 *
 * \defgroup xStreamBufferReset xStreamBufferReset
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer );
 * @endcode
 *
 * Queries a stream buffer to see if it is empty.  A stream buffer is empty if
 * it does not contain any data.
 *
 * @param xStreamBuffer The handle of the stream buffer being queried.
 *
 * @return If the stream buffer is empty then pdTRUE is returned.  Otherwise
 * pdFALSE is returned.
 *
 * \defgroup xStreamBufferIsEmpty xStreamBufferIsEmpty
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer );
 * @endcode
 *
 * Queries a stream buffer to see if it is full.  A stream buffer is full if it
 * does not have any free space, and therefore cannot accept any more data.
 *
 * @param xStreamBuffer The handle of the stream buffer being queried.
 *
 * @return If the stream buffer is full then pdTRUE is returned.  Otherwise
 * pdFALSE is returned.
 *
 * \defgroup xStreamBufferIsFull xStreamBufferIsFull
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer );
 * @endcode
 *
 * Deletes a stream buffer that was previously created using a call to
 * xStreamBufferCreate() or xStreamBufferCreateStatic().  If the stream
 * buffer was created using dynamic memory (that is, by xStreamBufferCreate()),
 * then the allocated memory is freed.
 *
 * A stream buffer handle must not be used after the stream buffer has been
 * deleted.
 *
 * @param xStreamBuffer The handle of the stream buffer to be deleted.
 *
 * \defgroup vStreamBufferDelete vStreamBufferDelete
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
 *                                  void *pvRxData,
 *                                  size_t xBufferLengthBytes,
 *                                  BaseType_t *pxHigherPriorityTaskWoken );
 * @endcode
 *
 * An interrupt safe version of the API function that receives bytes from a
 * stream buffer.
 *
 * Use xStreamBufferReceive() to read bytes from a stream buffer from a task.
 * Use xStreamBufferReceiveFromISR() to read bytes from a stream buffer from an
 * interrupt service routine (ISR).
 *
 * @param xStreamBuffer The handle of the stream buffer from which a stream
 * is being received.
 *
 * @param pvRxData A pointer to the buffer into which the received bytes are
 * copied.
 *
 * @param xBufferLengthBytes The length of the buffer pointed to by the
 * pvRxData parameter.  This sets the maximum number of bytes to receive in one
 * call.  xStreamBufferReceive will return as many bytes as possible up to a
 * maximum set by xBufferLengthBytes.
 *
 * @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
 * have a task blocked on it waiting for space to become available.  Calling
 * xStreamBufferReceiveFromISR() can make space available, and so cause a task
 * that is waiting for space to leave the Blocked state.  If calling
 * xStreamBufferReceiveFromISR() causes a task to leave the Blocked state, and
 * the unblocked task has a priority higher than the currently executing task
 * (the task that was interrupted), then, internally,
 * xStreamBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE.
 * If xStreamBufferReceiveFromISR() sets this value to pdTRUE, then normally a
 * context switch should be performed before the interrupt is exited.  That will
 * ensure the interrupt returns directly to the highest priority Ready state
 * task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it is
 * passed into the function.  See the code example below for an example.
 *
 * @return The number of bytes read from the stream buffer, if any.
 *
 * Example use:
 * @code{c}
 * // A stream buffer that has already been created.
 * StreamBuffer_t xStreamBuffer;
 *
 * void vAnInterruptServiceRoutine( void )
 * {
 * uint8_t ucRxData[ 20 ];
 * size_t xReceivedBytes;
 * BaseType_t xHigherPriorityTaskWoken = pdFALSE;  // Initialised to pdFALSE.
 *
 *  // Receive the next stream from the stream buffer.
 *  xReceivedBytes = xStreamBufferReceiveFromISR( xStreamBuffer,
 *                                                ( void * ) ucRxData,
 *                                                sizeof( ucRxData ),
 *                                                &xHigherPriorityTaskWoken );
 *
 *  if( xReceivedBytes > 0 )
 *  {
 *      // ucRxData contains xReceivedBytes read from the stream buffer.
 *      // Process the stream here....
 *  }
 *
 *  // If xHigherPriorityTaskWoken was set to pdTRUE inside
 *  // xStreamBufferReceiveFromISR() then a task that has a priority above the
 *  // priority of the currently executing task was unblocked and a context
 *  // switch should be performed to ensure the ISR returns to the unblocked
 *  // task.  In most FreeRTOS ports this is done by simply passing
 *  // xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the
 *  // variables value, and perform the context switch if necessary.  Check the
 *  // documentation for the port in use for port specific instructions.
 *  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 * }
 * @endcode
 * \defgroup xStreamBufferReceiveFromISR xStreamBufferReceiveFromISR
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
 *                           void *pvRxData,
 *                           size_t xBufferLengthBytes,
 *                           TickType_t xTicksToWait );
 * @endcode
 *
 * Receives bytes from a stream buffer.
 *
 * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
 * implementation (so also the message buffer implementation, as message buffers
 * are built on top of stream buffers) assumes there is only one task or
 * interrupt that will write to the buffer (the writer), and only one task or
 * interrupt that will read from the buffer (the reader).  It is safe for the
 * writer and reader to be different tasks or interrupts, but, unlike other
 * FreeRTOS objects, it is not safe to have multiple different writers or
 * multiple different readers.  If there are to be multiple different writers
 * then the application writer must place each call to a writing API function
 * (such as xStreamBufferSend()) inside a critical section and set the send
 * block time to 0.  Likewise, if there are to be multiple different readers
 * then the application writer must place each call to a reading API function
 * (such as xStreamBufferReceive()) inside a critical section and set the receive
 * block time to 0.
 *
 * Use xStreamBufferReceive() to read from a stream buffer from a task.  Use
 * xStreamBufferReceiveFromISR() to read from a stream buffer from an
 * interrupt service routine (ISR).
 *
 * @param xStreamBuffer The handle of the stream buffer from which bytes are to
 * be received.
 *
 * @param pvRxData A pointer to the buffer into which the received bytes will be
 * copied.
 *
 * @param xBufferLengthBytes The length of the buffer pointed to by the
 * pvRxData parameter.  This sets the maximum number of bytes to receive in one
 * call.  xStreamBufferReceive will return as many bytes as possible up to a
 * maximum set by xBufferLengthBytes.
 *
 * @param xTicksToWait The maximum amount of time the task should remain in the
 * Blocked state to wait for data to become available if the stream buffer is
 * empty.  xStreamBufferReceive() will return immediately if xTicksToWait is
 * zero.  The block time is specified in tick periods, so the absolute time it
 * represents is dependent on the tick frequency.  The macro pdMS_TO_TICKS() can
 * be used to convert a time specified in milliseconds into a time specified in
 * ticks.  Setting xTicksToWait to portMAX_DELAY will cause the task to wait
 * indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1
 * in FreeRTOSConfig.h.  A task does not use any CPU time when it is in the
 * Blocked state.
 *
 * @return The number of bytes actually read from the stream buffer, which will
 * be less than xBufferLengthBytes if the call to xStreamBufferReceive() timed
 * out before xBufferLengthBytes were available.
 *
 * Example use:
 * @code{c}
 * void vAFunction( StreamBuffer_t xStreamBuffer )
 * {
 * uint8_t ucRxData[ 20 ];
 * size_t xReceivedBytes;
 * const TickType_t xBlockTime = pdMS_TO_TICKS( 20 );
 *
 *  // Receive up to another sizeof( ucRxData ) bytes from the stream buffer.
 *  // Wait in the Blocked state (so not using any CPU processing time) for a
 *  // maximum of 100ms for the full sizeof( ucRxData ) number of bytes to be
 *  // available.
 *  xReceivedBytes = xStreamBufferReceive( xStreamBuffer,
 *                                         ( void * ) ucRxData,
 *                                         sizeof( ucRxData ),
 *                                         xBlockTime );
 *
 *  if( xReceivedBytes > 0 )
 *  {
 *      // A ucRxData contains another xReceivedBytes bytes of data, which can
 *      // be processed here....
 *  }
 * }
 * @endcode
 * \defgroup xStreamBufferReceive xStreamBufferReceive
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
 *                               const void *pvTxData,
 *                               size_t xDataLengthBytes,
 *                               BaseType_t *pxHigherPriorityTaskWoken );
 * @endcode
 *
 * Interrupt safe version of the API function that sends a stream of bytes to
 * the stream buffer.
 *
 * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
 * implementation (so also the message buffer implementation, as message buffers
 * are built on top of stream buffers) assumes there is only one task or
 * interrupt that will write to the buffer (the writer), and only one task or
 * interrupt that will read from the buffer (the reader).  It is safe for the
 * writer and reader to be different tasks or interrupts, but, unlike other
 * FreeRTOS objects, it is not safe to have multiple different writers or
 * multiple different readers.  If there are to be multiple different writers
 * then the application writer must place each call to a writing API function
 * (such as xStreamBufferSend()) inside a critical section and set the send
 * block time to 0.  Likewise, if there are to be multiple different readers
 * then the application writer must place each call to a reading API function
 * (such as xStreamBufferReceive()) inside a critical section and set the receive
 * block time to 0.
 *
 * Use xStreamBufferSend() to write to a stream buffer from a task.  Use
 * xStreamBufferSendFromISR() to write to a stream buffer from an interrupt
 * service routine (ISR).
 *
 * @param xStreamBuffer The handle of the stream buffer to which a stream is
 * being sent.
 *
 * @param pvTxData A pointer to the data that is to be copied into the stream
 * buffer.
 *
 * @param xDataLengthBytes The maximum number of bytes to copy from pvTxData
 * into the stream buffer.
 *
 * @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
 * have a task blocked on it waiting for data.  Calling
 * xStreamBufferSendFromISR() can make data available, and so cause a task that
 * was waiting for data to leave the Blocked state.  If calling
 * xStreamBufferSendFromISR() causes a task to leave the Blocked state, and the
 * unblocked task has a priority higher than the currently executing task (the
 * task that was interrupted), then, internally, xStreamBufferSendFromISR()
 * will set *pxHigherPriorityTaskWoken to pdTRUE.  If
 * xStreamBufferSendFromISR() sets this value to pdTRUE, then normally a
 * context switch should be performed before the interrupt is exited.  This will
 * ensure that the interrupt returns directly to the highest priority Ready
 * state task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it
 * is passed into the function.  See the example code below for an example.
 *
 * @return The number of bytes actually written to the stream buffer, which will
 * be less than xDataLengthBytes if the stream buffer didn't have enough free
 * space for all the bytes to be written.
 *
 * Example use:
 * @code{c}
 * // A stream buffer that has already been created.
 * StreamBufferHandle_t xStreamBuffer;
 *
 * void vAnInterruptServiceRoutine( void )
 * {
 * size_t xBytesSent;
 * char *pcStringToSend = "String to send";
 * BaseType_t xHigherPriorityTaskWoken = pdFALSE; // Initialised to pdFALSE.
 *
 *  // Attempt to send the string to the stream buffer.
 *  xBytesSent = xStreamBufferSendFromISR( xStreamBuffer,
 *                                         ( void * ) pcStringToSend,
 *                                         strlen( pcStringToSend ),
 *                                         &xHigherPriorityTaskWoken );
 *
 *  if( xBytesSent != strlen( pcStringToSend ) )
 *  {
 *      // There was not enough free space in the stream buffer for the entire
 *      // string to be written, ut xBytesSent bytes were written.
 *  }
 *
 *  // If xHigherPriorityTaskWoken was set to pdTRUE inside
 *  // xStreamBufferSendFromISR() then a task that has a priority above the
 *  // priority of the currently executing task was unblocked and a context
 *  // switch should be performed to ensure the ISR returns to the unblocked
 *  // task.  In most FreeRTOS ports this is done by simply passing
 *  // xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the
 *  // variables value, and perform the context switch if necessary.  Check the
 *  // documentation for the port in use for port specific instructions.
 *  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 * }
 * @endcode
 * \defgroup xStreamBufferSendFromISR xStreamBufferSendFromISR
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
 *                        const void *pvTxData,
 *                        size_t xDataLengthBytes,
 *                        TickType_t xTicksToWait );
 * @endcode
 *
 * Sends bytes to a stream buffer.  The bytes are copied into the stream buffer.
 *
 * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
 * implementation (so also the message buffer implementation, as message buffers
 * are built on top of stream buffers) assumes there is only one task or
 * interrupt that will write to the buffer (the writer), and only one task or
 * interrupt that will read from the buffer (the reader).  It is safe for the
 * writer and reader to be different tasks or interrupts, but, unlike other
 * FreeRTOS objects, it is not safe to have multiple different writers or
 * multiple different readers.  If there are to be multiple different writers
 * then the application writer must place each call to a writing API function
 * (such as xStreamBufferSend()) inside a critical section and set the send
 * block time to 0.  Likewise, if there are to be multiple different readers
 * then the application writer must place each call to a reading API function
 * (such as xStreamBufferReceive()) inside a critical section and set the receive
 * block time to 0.
 *
 * Use xStreamBufferSend() to write to a stream buffer from a task.  Use
 * xStreamBufferSendFromISR() to write to a stream buffer from an interrupt
 * service routine (ISR).
 *
 * @param xStreamBuffer The handle of the stream buffer to which a stream is
 * being sent.
 *
 * @param pvTxData A pointer to the buffer that holds the bytes to be copied
 * into the stream buffer.
 *
 * @param xDataLengthBytes   The maximum number of bytes to copy from pvTxData
 * into the stream buffer.
 *
 * @param xTicksToWait The maximum amount of time the task should remain in the
 * Blocked state to wait for enough space to become available in the stream
 * buffer, should the stream buffer contain too little space to hold the
 * another xDataLengthBytes bytes.  The block time is specified in tick periods,
 * so the absolute time it represents is dependent on the tick frequency.  The
 * macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds
 * into a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will
 * cause the task to wait indefinitely (without timing out), provided
 * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  If a task times out
 * before it can write all xDataLengthBytes into the buffer it will still write
 * as many bytes as possible.  A task does not use any CPU time when it is in
 * the blocked state.
 *
 * @return The number of bytes written to the stream buffer.  If a task times
 * out before it can write all xDataLengthBytes into the buffer it will still
 * write as many bytes as possible.
 *
 * Example use:
 * @code{c}
 * void vAFunction( StreamBufferHandle_t xStreamBuffer )
 * {
 * size_t xBytesSent;
 * uint8_t ucArrayToSend[] = { 0, 1, 2, 3 };
 * char *pcStringToSend = "String to send";
 * const TickType_t x100ms = pdMS_TO_TICKS( 100 );
 *
 *  // Send an array to the stream buffer, blocking for a maximum of 100ms to
 *  // wait for enough space to be available in the stream buffer.
 *  xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) ucArrayToSend, sizeof( ucArrayToSend ), x100ms );
 *
 *  if( xBytesSent != sizeof( ucArrayToSend ) )
 *  {
 *      // The call to xStreamBufferSend() times out before there was enough
 *      // space in the buffer for the data to be written, but it did
 *      // successfully write xBytesSent bytes.
 *  }
 *
 *  // Send the string to the stream buffer.  Return immediately if there is not
 *  // enough space in the buffer.
 *  xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) pcStringToSend, strlen( pcStringToSend ), 0 );
 *
 *  if( xBytesSent != strlen( pcStringToSend ) )
 *  {
 *      // The entire string could not be added to the stream buffer because
 *      // there was not enough free space in the buffer, but xBytesSent bytes
 *      // were sent.  Could try again to send the remaining bytes.
 *  }
 * }
 * @endcode
 * \defgroup xStreamBufferSend xStreamBufferSend
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * StreamBufferHandle_t xStreamBufferCreateStatic( size_t xBufferSizeBytes,
 *                                              size_t xTriggerLevelBytes,
 *                                              uint8_t *pucStreamBufferStorageArea,
 *                                              StaticStreamBuffer_t *pxStaticStreamBuffer );
 * @endcode
 * Creates a new stream buffer using statically allocated memory.  See
 * xStreamBufferCreate() for a version that uses dynamically allocated memory.
 *
 * configSUPPORT_STATIC_ALLOCATION must be set to 1 in FreeRTOSConfig.h for
 * xStreamBufferCreateStatic() to be available.
 *
 * @param xBufferSizeBytes The size, in bytes, of the buffer pointed to by the
 * pucStreamBufferStorageArea parameter.
 *
 * @param xTriggerLevelBytes The number of bytes that must be in the stream
 * buffer before a task that is blocked on the stream buffer to wait for data is
 * moved out of the blocked state.  For example, if a task is blocked on a read
 * of an empty stream buffer that has a trigger level of 1 then the task will be
 * unblocked when a single byte is written to the buffer or the task's block
 * time expires.  As another example, if a task is blocked on a read of an empty
 * stream buffer that has a trigger level of 10 then the task will not be
 * unblocked until the stream buffer contains at least 10 bytes or the task's
 * block time expires.  If a reading task's block time expires before the
 * trigger level is reached then the task will still receive however many bytes
 * are actually available.  Setting a trigger level of 0 will result in a
 * trigger level of 1 being used.  It is not valid to specify a trigger level
 * that is greater than the buffer size.
 *
 * @param pucStreamBufferStorageArea Must point to a uint8_t array that is at
 * least xBufferSizeBytes big.  This is the array to which streams are
 * copied when they are written to the stream buffer.
 *
 * @param pxStaticStreamBuffer Must point to a variable of type
 * StaticStreamBuffer_t, which will be used to hold the stream buffer's data
 * structure.
 *
 * @param pxSendCompletedCallback Callback invoked when number of bytes at least equal to
 * trigger level is sent to the stream buffer. If the parameter is NULL, it will use the default
 * implementation provided by sbSEND_COMPLETED macro. To enable the callback,
 * configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.
 *
 * @param pxReceiveCompletedCallback Callback invoked when more than zero bytes are read from a
 * stream buffer. If the parameter is NULL, it will use the default
 * implementation provided by sbRECEIVE_COMPLETED macro. To enable the callback,
 * configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.
 *
 * @return If the stream buffer is created successfully then a handle to the
 * created stream buffer is returned. If either pucStreamBufferStorageArea or
 * pxStaticstreamBuffer are NULL then NULL is returned.
 *
 * Example use:
 * @code{c}
 *
 * // Used to dimension the array used to hold the streams.  The available space
 * // will actually be one less than this, so 999.
 #define STORAGE_SIZE_BYTES 1000
 *
 * // Defines the memory that will actually hold the streams within the stream
 * // buffer.
 * static uint8_t ucStorageBuffer[ STORAGE_SIZE_BYTES ];
 *
 * // The variable used to hold the stream buffer structure.
 * StaticStreamBuffer_t xStreamBufferStruct;
 *
 * void MyFunction( void )
 * {
 * StreamBufferHandle_t xStreamBuffer;
 * const size_t xTriggerLevel = 1;
 *
 *  xStreamBuffer = xStreamBufferCreateStatic( sizeof( ucStorageBuffer ),
 *                                             xTriggerLevel,
 *                                             ucStorageBuffer,
 *                                             &xStreamBufferStruct );
 *
 *  // As neither the pucStreamBufferStorageArea or pxStaticStreamBuffer
 *  // parameters were NULL, xStreamBuffer will not be NULL, and can be used to
 *  // reference the created stream buffer in other stream buffer API calls.
 *
 *  // Other code that uses the stream buffer can go here.
 * }
 *
 * @endcode
 * \defgroup xStreamBufferCreateStatic xStreamBufferCreateStatic
 * \ingroup StreamBufferManagement
 *//**
 * stream_buffer.h
 *
 * @code{c}
 * StreamBufferHandle_t xStreamBufferCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes );
 * @endcode
 *
 * Creates a new stream buffer using dynamically allocated memory.  See
 * xStreamBufferCreateStatic() for a version that uses statically allocated
 * memory (memory that is allocated at compile time).
 *
 * configSUPPORT_DYNAMIC_ALLOCATION must be set to 1 or left undefined in
 * FreeRTOSConfig.h for xStreamBufferCreate() to be available.
 *
 * @param xBufferSizeBytes The total number of bytes the stream buffer will be
 * able to hold at any one time.
 *
 * @param xTriggerLevelBytes The number of bytes that must be in the stream
 * buffer before a task that is blocked on the stream buffer to wait for data is
 * moved out of the blocked state.  For example, if a task is blocked on a read
 * of an empty stream buffer that has a trigger level of 1 then the task will be
 * unblocked when a single byte is written to the buffer or the task's block
 * time expires.  As another example, if a task is blocked on a read of an empty
 * stream buffer that has a trigger level of 10 then the task will not be
 * unblocked until the stream buffer contains at least 10 bytes or the task's
 * block time expires.  If a reading task's block time expires before the
 * trigger level is reached then the task will still receive however many bytes
 * are actually available.  Setting a trigger level of 0 will result in a
 * trigger level of 1 being used.  It is not valid to specify a trigger level
 * that is greater than the buffer size.
 *
 * @param pxSendCompletedCallback Callback invoked when number of bytes at least equal to
 * trigger level is sent to the stream buffer. If the parameter is NULL, it will use the default
 * implementation provided by sbSEND_COMPLETED macro. To enable the callback,
 * configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.
 *
 * @param pxReceiveCompletedCallback Callback invoked when more than zero bytes are read from a
 * stream buffer. If the parameter is NULL, it will use the default
 * implementation provided by sbRECEIVE_COMPLETED macro. To enable the callback,
 * configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.
 *
 * @return If NULL is returned, then the stream buffer cannot be created
 * because there is insufficient heap memory available for FreeRTOS to allocate
 * the stream buffer data structures and storage area.  A non-NULL value being
 * returned indicates that the stream buffer has been created successfully -
 * the returned value should be stored as the handle to the created stream
 * buffer.
 *
 * Example use:
 * @code{c}
 *
 * void vAFunction( void )
 * {
 * StreamBufferHandle_t xStreamBuffer;
 * const size_t xStreamBufferSizeBytes = 100, xTriggerLevel = 10;
 *
 *  // Create a stream buffer that can hold 100 bytes.  The memory used to hold
 *  // both the stream buffer structure and the data in the stream buffer is
 *  // allocated dynamically.
 *  xStreamBuffer = xStreamBufferCreate( xStreamBufferSizeBytes, xTriggerLevel );
 *
 *  if( xStreamBuffer == NULL )
 *  {
 *      // There was not enough heap memory space available to create the
 *      // stream buffer.
 *  }
 *  else
 *  {
 *      // The stream buffer was created successfully and can now be used.
 *  }
 * }
 * @endcode
 * \defgroup xStreamBufferCreate xStreamBufferCreate
 * \ingroup StreamBufferManagement
 *//**
 *  Type used as a stream buffer's optional callback.
 *//**
 * Type by which stream buffers are referenced.  For example, a call to
 * xStreamBufferCreate() returns an StreamBufferHandle_t variable that can
 * then be used as a parameter to xStreamBufferSend(), xStreamBufferReceive(),
 * etc.
 *//*
 * Stream buffers are used to send a continuous stream of data from one task or
 * interrupt to another.  Their implementation is light weight, making them
 * particularly suited for interrupt to task and core to core communication
 * scenarios.
 *
 * ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
 * implementation (so also the message buffer implementation, as message buffers
 * are built on top of stream buffers) assumes there is only one task or
 * interrupt that will write to the buffer (the writer), and only one task or
 * interrupt that will read from the buffer (the reader).  It is safe for the
 * writer and reader to be different tasks or interrupts, but, unlike other
 * FreeRTOS objects, it is not safe to have multiple different writers or
 * multiple different readers.  If there are to be multiple different writers
 * then the application writer must place each call to a writing API function
 * (such as xStreamBufferSend()) inside a critical section and set the send
 * block time to 0.  Likewise, if there are to be multiple different readers
 * then the application writer must place each call to a reading API function
 * (such as xStreamBufferReceive()) inside a critical section section and set the
 * receive block time to 0.
 *
 */xStreamBufferuxStreamBufferNumberxBufferSizeBytesxTriggerLevelBytesxIsMessageBufferpucStreamBufferStorageAreapxStaticStreamBufferpxSendCompletedCallbackpxReceiveCompletedCallbackxTriggerLevelpvRxDataxBufferLengthBytespvTxDataxDataLengthBytes/Users/mac/Downloads/FreeRTOS/Source/include/mpu_prototypes.hMPU_uxEventGroupGetNumberMPU_xTimerCreateTimerTaskMPU_xTimerPendFunctionCallMPU_xTimerCreateStaticMPU_xTimerCreateMPU_ucQueueGetQueueTypeMPU_uxQueueGetQueueNumberMPU_vQueueSetQueueNumberMPU_vTaskMissedYieldMPU_xTaskIncrementTickMPU_vTaskStartSchedulerMPU_PROTOTYPES_Hfreertos_system_callschar[22]/* MPU_PROTOTYPES_H *//* MPU versions of message/stream_buffer.h API functions. *//* MPU versions of event_group.h API functions. *//* MPU versions of timers.h API functions. *//* MPU versions of queue.h API functions. *//* MPU versions of task.h API functions. *//*
 * When the MPU is used the standard (non MPU) API functions are mapped to
 * equivalents that start "MPU_", the prototypes for which are defined in this
 * header files.  This will cause the application code to call the MPU_ version
 * which wraps the non-MPU version with privilege promoting then demoting code,
 * so the kernel code always runs will full privileges.
 */uxAutoReloadpxMutex/Users/mac/Downloads/FreeRTOS/Source/portable/Common/mpu_wrappers.c"mpu_prototypes.h""stream_buffer.h""queue.h"( pxSendCompletedCallback == NULL ) && ( pxReceiveCompletedCallback == NULL )( pxSendCompletedCallback == ((void *)0) ) && ( pxReceiveCompletedCallback == ((void *)0) )/Users/mac/Downloads/FreeRTOS/Source/portable/CommonpcReturnpvReturnulReturnxBlockTimeTicksxBlockTimeuxCountValuepxQueueeReturn2147483648( portPRIVILEGE_BIT )2147483647~( portPRIVILEGE_BIT )( INCLUDE_vTaskDelete == 1 )( INCLUDE_xTaskDelayUntil == 1 )( INCLUDE_vTaskDelay == 1 )( INCLUDE_uxTaskPriorityGet == 1 )( INCLUDE_vTaskPrioritySet == 1 )( INCLUDE_eTaskGetState == 1 )( INCLUDE_xTaskGetIdleTaskHandle == 1 )( INCLUDE_xTaskGetHandle == 1 )( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )( INCLUDE_uxTaskGetStackHighWaterMark == 1 )( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )( INCLUDE_xTaskGetSchedulerState == 1 )( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )( configUSE_RECURSIVE_MUTEXES == 1 )( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )configQUEUE_REGISTRY_SIZE > 0( configUSE_TIMERS == 1 )configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS == 1/* portUSING_MPU_WRAPPERS == 1 *//* Functions that the application writer wants to execute in privileged mode
 * can be defined in application_defined_privileged_functions.h.  The functions
 * must take the same format as those above whereby the privilege state on exit
 * equals the privilege state on entry.  For example:
 *
 * void MPU_FunctionName( [parameters ] ) FREERTOS_SYSTEM_CALL;
 * void MPU_FunctionName( [parameters ] )
 * {
 *      if( portIS_PRIVILEGED() == pdFALSE )
 *      {
 *          portRAISE_PRIVILEGE();
 *          portMEMORY_BARRIER();
 *
 *          FunctionName( [parameters ] );
 *          portMEMORY_BARRIER();
 *
 *          portRESET_PRIVILEGE();
 *          portMEMORY_BARRIER();
 *      }
 *      else
 *      {
 *          FunctionName( [parameters ] );
 *      }
 * }
 *//**
             * Streambuffer application level callback functionality is disabled for MPU
             * enabled ports.
             *//* FREERTOS_SYSTEM_CALL *//* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) *//* if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) *//* if ( configUSE_TIMERS == 1 ) *//* if configQUEUE_REGISTRY_SIZE > 0 *//* if ( configUSE_QUEUE_SETS == 1 ) *//* if ( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *//* if ( configUSE_RECURSIVE_MUTEXES == 1 ) *//* if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) *//* if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *//* if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) *//* if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *//* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) *//* if ( configUSE_TASK_NOTIFICATIONS == 1 ) *//* if ( INCLUDE_xTaskGetSchedulerState == 1 ) *//* if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) *//* if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) *//* if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) *//* if ( configUSE_TRACE_FACILITY == 1 ) *//* if ( configUSE_APPLICATION_TASK_TAG == 1 ) *//* if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 ) *//* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) *//* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *//* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *//* if ( INCLUDE_xTaskGetHandle == 1 ) *//* if ( INCLUDE_vTaskSuspend == 1 ) *//* if ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) *//* if ( INCLUDE_eTaskGetState == 1 ) *//* if ( INCLUDE_vTaskPrioritySet == 1 ) *//* if ( INCLUDE_uxTaskPriorityGet == 1 ) *//* if ( INCLUDE_vTaskDelay == 1 ) *//* if ( INCLUDE_xTaskAbortDelay == 1 ) *//* if ( INCLUDE_xTaskDelayUntil == 1 ) *//* if ( INCLUDE_vTaskDelete == 1 ) *//*
 * Implementation of the wrapper functions used to raise the processor privilege
 * before calling a standard FreeRTOS API function.
 */pxTagValuepxTaskToResumepxTaskToSuspendpxTaskToDelete/Users/mac/Downloads/FreeRTOS/Source/portable/GCC/ARM_CM3_MPU/port.cucCurrentPriorityucCurrentPriority >= ucMaxSysCallPriorityportFIRST_USER_INTERRUPT_NUMBERconst volatile uint8_tconst volatile uint8_t *3758154736pcInterruptPriorityRegisters( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue( ( *( ( volatile uint32_t * ) 0xE000ED0C ) ) & ( 0x07UL << 8UL ) ) <= ulMaxPRIGROUPValue3758157068lIndexulxMPU_REGION_REGISTERS *MPU_REGION_REGISTERS *uint32_t[]unsigned long[]portMPU_REGION_VALID( portMPU_REGION_VALID )( portSTACK_REGION )( portMPU_REGION_READ_WRITE )458752( portMPU_REGION_CACHEABLE_BUFFERABLE )50790400( portMPU_REGION_READ_WRITE ) |
            ( portMPU_REGION_CACHEABLE_BUFFERABLE )( portMPU_REGION_EXECUTE_NEVER )319225856( portMPU_REGION_READ_WRITE ) |
            ( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
            ( portMPU_REGION_EXECUTE_NEVER )portMPU_REGION_ENABLE( portMPU_REGION_ENABLE )( portMPU_REGION_READ_WRITE ) |
                ( portMPU_REGION_EXECUTE_NEVER )( uint32_t ) sizeof( StackType_t )prvGetMPURegionSizeSettingulRegionSizeulReturnValue31UL32ULprvSetupMPU2048portEXPECTED_MPU_TYPE_VALUE( portUNPRIVILEGED_FLASH_REGION )3758157216100663296( portMPU_REGION_READ_ONLY )101122048( portMPU_REGION_READ_ONLY ) |
                                       ( portMPU_REGION_CACHEABLE_BUFFERABLE )( portPRIVILEGED_FLASH_REGION )83886080( portMPU_REGION_PRIVILEGED_READ_ONLY )84344832( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
                                       ( portMPU_REGION_CACHEABLE_BUFFERABLE )( portPRIVILEGED_RAM_REGION )( portMPU_REGION_PRIVILEGED_READ_WRITE )17235968( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
                                       ( portMPU_REGION_CACHEABLE_BUFFERABLE )285671424( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
                                       ( portMPU_REGION_CACHEABLE_BUFFERABLE ) |
                                       ( portMPU_REGION_EXECUTE_NEVER )1073741824portPERIPHERALS_START_ADDRESS( portPERIPHERALS_START_ADDRESS )1073741840( portPERIPHERALS_START_ADDRESS ) |
                                          ( portMPU_REGION_VALID )( portGENERAL_PERIPHERALS_REGION )1073741843( portPERIPHERALS_START_ADDRESS ) |
                                          ( portMPU_REGION_VALID ) |
                                          ( portGENERAL_PERIPHERALS_REGION )( portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER )1610612735portPERIPHERALS_END_ADDRESS5368709113758157092portNVIC_MEM_FAULT_ENABLE3758157204portMPU_ENABLEportMPU_BACKGROUND_ENABLE( portMPU_ENABLE | portMPU_BACKGROUND_ENABLE )vPortSetupTimerInterruptweakulActualSizeInBytes375815375237581537482000000020000( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ )19999( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1ULportNVIC_SYSTICK_CLKportNVIC_SYSTICK_INTportNVIC_SYSTICK_ENABLE( portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE )ulDummyuxCriticalNestinguxCriticalNesting == 1000UL( configMAX_SYSCALL_INTERRUPT_PRIORITY )( 191 )ulOriginalPriorityvolatile uint8_t *constpucFirstUserPriorityRegisterportNVIC_IP_REGISTERS_OFFSET_163758154752( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER )ucMaxPriorityValueportMAX_8_BIT_VALUEportMAX_PRIGROUP_BITSportTOP_BIT_OF_BYTE0x01( uint8_t ) 0x01portPRIGROUP_SHIFTportPRIORITY_GROUP_MASK375815708816711680portNVIC_PENDSV_PRIportNVIC_SYSTICK_PRIprvRestoreContextOfFirstTaskprvSVCHandlerucSVCNumberportOFFSET_TO_PC37581570841903187671040portNVIC_SVC_PRIportINITIAL_XPSRportSTART_ADDRESS_MASKportINITIAL_CONTROL_IF_PRIVILEGEDportINITIAL_CONTROL_IF_UNPRIVILEGED__SRAM_segment_end____SRAM_segment_start____privileged_data_end____privileged_data_start____FLASH_segment_end____FLASH_segment_start____privileged_functions_end____privileged_functions_start____syscalls_flash_end____syscalls_flash_start__const volatile uint8_t *const( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16ulMaxPRIGROUPValueucMaxSysCallPriority28633115300xaaaaaaaa( ( StackType_t ) 0xfffffffeUL )( 6 )( 8UL )( 0x07UL << 8UL )( ( uint8_t ) 7 )( ( uint8_t ) 0x80 )( ( uint8_t ) 0xff )portAIRCR_REG( *( ( volatile uint32_t * ) 0xE000ED0C ) )( 0xE000E3F0 )( 16 )( 0x02 )( 0x03 )( 0x01000000 )( ( ( uint32_t ) configMAX_SYSCALL_INTERRUPT_PRIORITY - 1UL ) << 24UL )( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )( 0x00000001UL )( 0x00000002UL )0x5FFFFFFFUL0x40000000UL( 0x01UL )( 0x10UL )portPRIVILEGED_EXECUTION_START_ADDRESS( 8UL << 8UL )portMPU_CTRL_REG( *( ( volatile uint32_t * ) 0xe000ed94 ) )portMPU_REGION_ATTRIBUTE_REG( *( ( volatile uint32_t * ) 0xe000edA0 ) )portMPU_REGION_BASE_ADDRESS_REG( *( ( volatile uint32_t * ) 0xe000ed9C ) )portMPU_TYPE_REG( *( ( volatile uint32_t * ) 0xe000ed90 ) )( 1UL << 16UL )portNVIC_SYS_CTRL_STATE_REG( *( ( volatile uint32_t * ) 0xe000ed24 ) )portNVIC_SHPR2_REG( *( ( volatile uint32_t * ) 0xe000ed1c ) )portNVIC_SHPR3_REG( *( ( volatile uint32_t * ) 0xe000ed20 ) )portNVIC_SYSTICK_CURRENT_VALUE_REG( *( ( volatile uint32_t * ) 0xe000e018 ) )portNVIC_SYSTICK_LOAD_REG( *( ( volatile uint32_t * ) 0xe000e014 ) )portNVIC_SYSTICK_CTRL_REG( *( ( volatile uint32_t * ) 0xe000e010 ) )configSYSTICK_CLOCK_HZ( configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS == 1 )USE_PROCESS_STACKdefined( __ARMCC_VERSION )configPRIO_BITS"3"/* Priority grouping:  The interrupt controller (NVIC) allows the bits
         * that define each interrupt's priority to be split between bits that
         * define the interrupt's pre-emption priority bits and bits that define
         * the interrupt's sub-priority.  For simplicity all bits must be defined
         * to be pre-emption priority bits.  The following assertion will fail if
         * this is not the case (if some bits represent a sub-priority).
         *
         * If the application only uses CMSIS libraries for interrupt
         * configuration then the correct setting can be achieved on all Cortex-M
         * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
         * scheduler.  Note however that some vendor specific peripheral libraries
         * assume a non-zero priority group setting, in which cases using a value
         * of zero will result in unpredicable behaviour. *//* The following assertion will fail if a service routine (ISR) for
             * an interrupt that has been assigned a priority above
             * configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
             * function.  ISR safe FreeRTOS API functions must *only* be called
             * from interrupts that have been assigned a priority at or below
             * configMAX_SYSCALL_INTERRUPT_PRIORITY.
             *
             * Numerically low interrupt priority numbers represent logically high
             * interrupt priorities, therefore the priority of the interrupt must
             * be set to a value equal to or numerically *higher* than
             * configMAX_SYSCALL_INTERRUPT_PRIORITY.
             *
             * Interrupts that	use the FreeRTOS API must not be left at their
             * default priority of	zero as that is the highest possible priority,
             * which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
             * and	therefore also guaranteed to be invalid.
             *
             * FreeRTOS maintains separate thread and ISR API functions to ensure
             * interrupt entry is as fast and simple as possible.
             *
             * The following links provide detailed information:
             * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
             * https://www.FreeRTOS.org/FAQHelp.html *//* Look up the interrupt's priority. *//* Is the interrupt number a user defined interrupt? *//* Invalidate the region. *//* Region number. *//* Translate the generic region definition contained in
                 * xRegions into the CM3 specific MPU settings that are then
                 * stored in xMPUSettings. *//* Define the region that allows access to the stack. *//* This function is called automatically when the task is created - in
         * which case the stack region parameters will be valid.  At all other
         * times the stack parameters will not be valid and it is assumed that the
         * stack region has already been configured. *//* Invalidate user configurable regions. *//* Base address. *//* No MPU regions are specified so allow access to all RAM. *//* Return to the caller. *//* CONTROL = r0. *//* r0 = r0 | 1. *//* r0 = CONTROL. *//* __attribute__ (( naked )) *//* Return. *//* CONTROL[0]==0. Return true to indicate that the processor is privileged. *//* CONTROL[0]!=0. Return false to indicate that the processor is not privileged. *//* Perform r0 & 1 (bitwise AND) and update the conditions flag. *//* Shift the code by one before returning so it can be written directly
     * into the the correct bit position of the attribute register. *//* 32 is the smallest region size, 31 is the largest valid value for
     * ulReturnValue. *//* Enable the MPU with the background region configured. *//* Enable the memory fault exception. *//* By default allow everything to access the general peripherals.  The
         * system peripherals and registers are protected. *//* Setup the privileged data RAM region.  This is where the kernel data
         * is placed. *//* Setup the privileged flash for privileged only access.  This is where
         * the kernel code is * placed. *//* First setup the unprivileged flash for unprivileged read only access. *//* Check the expected MPU is present. *//* Configure SysTick to interrupt at the requested rate. *//* Stop and clear the SysTick. *//*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 *//* Pend a context switch. *//* Increment the RTOS tick. *//* Assemble current literal pool to avoid offset-out-of-bound errors with lto. *//* Pop the registers that are not automatically saved on exception entry. *//* Force memory writes before continuing. *//* Enable MPU. *//* r3 = r3 | 1 i.e. Set the bit 0 in r3. *//* Read the value of MPU_CTRL. *//* MPU_CTRL register. *//* Write 4 sets of MPU registers. *//* Read 4 sets of MPU registers. *//* Region Base Address register. *//* Disable MPU. *//* r3 = r3 & ~1 i.e. Clear the bit 0 in r3. *//* Complete outstanding transfers before disabling MPU. *//* Move onto the second item in the TCB... *//* The first item in the TCB is the task top of stack. *//* Restore the context. *//* Save the new top of stack into the first member of the TCB. *//* Save the remaining registers. *//* Get the location of the current TCB. *//* This is a naked function. *//* Not implemented in ports where there is nothing to return to.
     * Artificially force an assert. *//* Should not get here! *//* System call to start first task. *//* Globally enable interrupts. *//* Set the msp back to the start of the stack. *//* Use the NVIC offset register to locate the stack. *//* Start the first task. *//* Initialise the critical nesting count ready for the first task. *//* Start the timer that generates the tick ISR.  Interrupts are disabled
     * here already. *//* Configure the regions in the MPU that are common to all tasks. *//* Make PendSV and SysTick the same priority as the kernel, and the SVC
     * handler higher priority so it can be used to exit a critical section (where
     * lower priorities are masked). *//* Restore the clobbered interrupt priority register to its original
             * value. *//* Shift the priority group value back to its position within the AIRCR
             * register. *//* Check the FreeRTOS configuration that defines the number of
                     * priority bits matches the number of priority bits actually queried
                     * from the hardware. *//* Check the CMSIS configuration that defines the number of
                     * priority bits matches the number of priority bits actually queried
                     * from the hardware. *//* Calculate the maximum acceptable priority group value for the number
             * of bits read back. *//* Use the same mask on the maximum system call priority. *//* Read the value back to see how many bits stuck. *//* Determine the number of priority bits available.  First write to all
             * possible bits. *//* Determine the maximum priority from which ISR safe FreeRTOS API
             * functions can be called.  ISR safe functions are those that end in
             * "FromISR".  FreeRTOS maintains separate thread and ISR API functions
             * to ensure interrupt entry is as fast and simple as possible.
             *
             * Save the interrupt priority value that is about to be clobbered. *//* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See
     * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html *//*
 * See header file for description.
 *//* Load exec return code. *//* Restore the task stack pointer. *//* Unknown SVC call. *//* Write back new control value. *//* Set privilege bit. *//* Obtain current control value. *//* Only raise the privilege, if the
                                               * svc was raised from any of the
                                               * system calls. *//* Barriers are normally not required
             * but do ensure the code is completely
             * within the specified behaviour for the
             * architecture. *//* The stack contains: r0, r1, r2, r3, r12, LR, PC and xPSR.  The first
     * argument (r0) is pulParam[ 0 ]. *//* #if defined( __ARMCC_VERSION ) *//* Declaration when these variable are exported from linker scripts. *//* Declaration when these variable are defined in code instead of being
             * exported from linker scripts. *//* Code should not be required if a main() is using the process stack. *//* Assumes psp was in use. *//* R11, R10, R9, R8, R7, R6, R5 and R4. *//* R0 *//* R12, R3, R2 and R1. *//* LR *//* PC *//* xPSR *//* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. *//* Simulate the stack frame as it would be created by a context switch
     * interrupt. *//*
 * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
 * FreeRTOS API functions are not called from interrupts that have been assigned
 * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
 *//* Each task maintains its own interrupt status in the critical nesting
 * variable.  Note this is not saved as part of the task context as context
 * switches can only occur when uxCriticalNesting is zero. *//**
 * @brief Exit from critical section.
 *//**
 * @brief Enter critical section.
 *//**
 * @brief Lowers the privilege level by setting the bit 0 of the CONTROL
 * register.
 *
 * Bit 0 of the CONTROL register defines the privilege level of Thread Mode.
 *  Bit[0] = 0 --> The processor is running privileged
 *  Bit[0] = 1 --> The processor is running unprivileged.
 *//*
 * C portion of the SVC handler.  The SVC handler is split between an asm entry
 * and a C wrapper for simplicity of coding and maintenance.
 *//*
 * Starts the scheduler by restoring the context of the first task to run.
 *//*
 * Standard FreeRTOS exception handlers.
 *//*
 * Setup the timer to generate the tick interrupts.  The implementation in this
 * file is weak to allow application writers to change the timer used to
 * generate the tick interrupt.
 *//*
 * Return the smallest MPU region size that a given number of bytes will fit
 * into.  The region size is returned as the value that should be programmed
 * into the region attribute register for that region.
 *//*
 * Configure a number of standard MPU regions that are used by all tasks.
 *//* For strict compliance with the Cortex-M spec the task start address should
 * have bit-0 clear, as it is loaded into the PC on exit from an ISR. *//* Offsets in the stack to the parameters when inside the SVC handler. *//* Constants required to check the validity of an interrupt priority. *//* Constants required to set up the initial stack. *//* Constants required to access and manipulate the SysTick. *//* 8 regions, unified. *//* Constants required to access and manipulate the MPU. *//* Constants required to access and manipulate the NVIC. *//* The way the SysTick is clocked is not modified in case it is not the same
 * as the core. *//* Ensure the SysTick is clocked at the same frequency as the core. *//*-----------------------------------------------------------
* Implementation of functions defined in portable.h for the ARM CM3 MPU port.
*----------------------------------------------------------*/pulParampulRegisters/Users/mac/Downloads/FreeRTOS/Source/portable/MemMang/heap_4.cBlockLink_t *A_BLOCK_LINK *pxBlockxBlocksxMaxSizexMinSizeprvInsertBlockIntoFreeListpucprvHeapInitpxFirstFreeBlockpucAlignedHeapuxAddressxTotalHeapSizeuint8_t[1024]unsigned char[1024]( portBYTE_ALIGNMENT - 1 )( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK )4294967288~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK )( size_t ) 0const size_txHeapStructSizepxLinkheapBLOCK_IS_ALLOCATED( pxLink ) != 0( ( ( pxLink->xBlockSize ) & ( ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * ( ( size_t ) 8 ) ) - 1 ) ) ) != 0 ) != 0pxLink->pxNextFreeBlock == NULLpxLink->pxNextFreeBlock == ((void *)0)pxLink->xBlockSizepxPreviousBlockpxNewBlockLinkxAdditionalRequiredSizexWantedSizexHeapStructSize + portBYTE_ALIGNMENT( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0( ( ( size_t ) pxNewBlockLink ) & ( 0x0007 ) ) == 0heapMINIMUM_BLOCK_SIZE/Users/mac/Downloads/FreeRTOS/Source/portable/MemMangpxBlockToInsert( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0( ( ( size_t ) pvReturn ) & ( size_t ) ( 0x0007 ) ) == 0BlockLink_tA_BLOCK_LINKxBlockSizepxNextFreeBlockprivileged_datachar[16]xFreeBytesRemainingpxEndxStartsizeof( BlockLink_t )( size_t ) ( portBYTE_ALIGNMENT - 1 )( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) )sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) )( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) )( size_t ) portBYTE_ALIGNMENT_MASK( ( size_t ) portBYTE_ALIGNMENT_MASK )~( ( size_t ) portBYTE_ALIGNMENT_MASK )( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK )ucHeapheapFREE_BLOCK(pxBlock)( ( pxBlock->xBlockSize ) &= ~heapBLOCK_ALLOCATED_BITMASK )heapALLOCATE_BLOCK(pxBlock)( ( pxBlock->xBlockSize ) |= heapBLOCK_ALLOCATED_BITMASK )heapBLOCK_IS_ALLOCATED(pxBlock)( ( ( pxBlock->xBlockSize ) & heapBLOCK_ALLOCATED_BITMASK ) != 0 )heapBLOCK_SIZE_IS_VALID(xBlockSize)( ( ( xBlockSize ) & heapBLOCK_ALLOCATED_BITMASK ) == 0 )heapBLOCK_ALLOCATED_BITMASK( ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 ) )heapADD_WILL_OVERFLOW(a,b)( ( a ) > ( heapSIZE_MAX - ( b ) ) )heapMULTIPLY_WILL_OVERFLOW(a,b)( ( ( a ) > 0 ) && ( ( b ) > ( heapSIZE_MAX / ( a ) ) ) )heapSIZE_MAX( ~( ( size_t ) 0 ) )heapBITS_PER_BYTE( ( size_t ) 8 )( ( size_t ) ( xHeapStructSize << 1 ) )configHEAP_CLEAR_MEMORY_ON_FREE( configSUPPORT_DYNAMIC_ALLOCATION == 0 )( configAPPLICATION_ALLOCATED_HEAP == 1 )( configHEAP_CLEAR_MEMORY_ON_FREE == 1 )/* Move to the next block in the chain until the last block is
                 * reached. *//* Increment the number of blocks and record the largest block seen
                 * so far. *//* pxBlock will be NULL if the heap has not been initialised.  The heap
         * is initialised automatically when the first allocation is made. *//* portMAX_DELAY used as a portable way of getting the maximum value. *//* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. *//* Form one big block from the two blocks. *//* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? *//* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? *//* Nothing to do here, just iterate to the right position. *//* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. *//* PRIVILEGED_FUNCTION *//* Only one block exists - and it covers the entire usable heap space. *//* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. *//* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. *//* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. *//* Ensure the heap starts on a correctly aligned boundary. *//* This just exists to keep the linker quiet. *//* Add this block to the list of free blocks. *//* The block is being returned to the heap - it is no longer
                 * allocated. *//* This casting is to keep the compiler from issuing warnings. *//* The memory being freed will have an BlockLink_t structure immediately
         * before it. *//* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) *//* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. *//* Insert the new block into the list of free blocks. *//* Calculate the sizes of two blocks split from the
                         * single block. *//* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. *//* If the block is larger than required it can be split into
                     * two. *//* This block is being returned for use so must be taken out
                     * of the list of free blocks. *//* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. *//* If the end marker was reached then a block of adequate size
                 * was not found. *//* Traverse the list from the start (lowest address) block until
                 * one of adequate size is found. *//* Check the block size we are trying to allocate is not so large that the
         * top bit is set.  The top bit of the block size member of the BlockLink_t
         * structure is used to determine who owns the block - the application or
         * the kernel, so it must be free. *//* The wanted size must be increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. Some
             * additional increment may also be needed for alignment. *//* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. *//* Keeps track of the number of calls to allocate and free memory as well as the
 * number of free bytes remaining, but says nothing about fragmentation. *//* Create a couple of list links to mark the start and end of the list. *//* The size of the structure placed at the beginning of each allocated memory
 * block must by correctly byte aligned. *//*
 * Called automatically to setup the required heap structures the first time
 * pvPortMalloc() is called.
 *//*
 * Inserts a block of memory that is being freed into the correct position in
 * the list of free memory blocks.  The block being freed will be merged with
 * the block in front it and/or the block behind it if the memory blocks are
 * adjacent to each other.
 *//*<< The size of the free block. *//*<< The next free block in the list. *//* Define the linked list structure.  This is used to link free blocks in order
 * of their memory address. *//* configAPPLICATION_ALLOCATED_HEAP *//* The application writer has already defined the array used for the RTOS
* heap - probably so it can be placed in a special segment or address. *//* Allocate the memory for the heap. *//* MSB of the xBlockSize member of an BlockLink_t structure is used to track
 * the allocation status of a block.  When MSB of the xBlockSize member of
 * an BlockLink_t structure is set then the block belongs to the application.
 * When the bit is free the block is still part of the free heap space. *//* Check if adding a and b will result in overflow. *//* Check if multiplying a and b will result in overflow. *//* Max value that fits in a size_t type. *//* Assumes 8bit bytes! *//* Block sizes must not get too small. *//*
 * A sample implementation of pvPortMalloc() and vPortFree() that combines
 * (coalescences) adjacent memory blocks as they are freed, and in so doing
 * limits memory fragmentation.
 *
 * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
 * memory management pages of https://www.FreeRTOS.org for more information.
 *//Users/mac/Downloads/FreeRTOS/Source/queue.cprvNotifyQueueSetContainerconst Queue_tconst Queue_t *const Queue_t *constQueue_t *pxQueueSetContainerpxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength&( pxQueueSetContainer->xTasksWaitingToReceive )cTxLock( cTxLock ) != queueINT8_MAX( cTxLock ) != ( ( int8_t ) 127 )const int8_tvolatile int8_tQueue_t *constconst Queue_t *const *QueueDefinition **queueUNLOCKEDuxNumberOfTasksQueueSetMemberHandle_t *pxQueueOrSemaphore( UBaseType_t ) sizeof( Queue_t * )ux( UBaseType_t ) configQUEUE_REGISTRY_SIZEQueueRegistryItem_t[20]QUEUE_REGISTRY_ITEM[20]QueueRegistryItem_t *QUEUE_REGISTRY_ITEM *( QueueHandle_t ) 0pxEntryToWriteprvIsQueueFullprvIsQueueEmptyprvUnlockQueue&( pxQueue->xTasksWaitingToReceive )queueLOCKED_UNMODIFIEDcRxLock&( pxQueue->xTasksWaitingToSend )prvCopyDataFromQueueint8_t *signed char *prvCopyDataToQueueuxMessagesWaiting( UBaseType_t ) 1prvGetDisinheritPriorityAfterTimeoutuxHighestPriorityOfWaitingTasks( UBaseType_t ) configMAX_PRIORITIESpcOriginalReadPosition!( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) )!( ( pvBuffer == ((void *)0) ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) )pxQueue->uxItemSize != 0( cRxLock ) != queueINT8_MAX( cRxLock ) != ( ( int8_t ) 127 )xEntryTimeSetxTimeOut( pxQueue )!( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) )!( ( ( pvBuffer ) == ((void *)0) ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) )xPositionxInheritanceOccurredpxQueue->uxItemSize == 0uxSemaphoreCountuxHighestWaitingPriority!( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) )!( ( pxQueue->pcHead == ((void *)0) ) && ( pxQueue->u.xSemaphore.xMutexHolder != ((void *)0) ) )!( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) )!( ( pvItemToQueue == ((void *)0) ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) )!( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) )!( ( xCopyPosition == ( ( BaseType_t ) 2 ) ) && ( pxQueue->uxLength != 1 ) )uxPreviousMessagesWaitingxYieldRequiredqueueSEMAPHORE_QUEUE_ITEM_LENGTHqueueMUTEX_GIVE_BLOCK_TIMEpxReturnpxSemaphoreuxMutexLengthuxMutexSizeprvInitialiseMutexpxNewQueue( TickType_t ) 0UprvInitialiseNewQueuexQueueSizeInBytes84sizeof( Queue_t )4294967211( SIZE_MAX - sizeof( Queue_t ) )xSize == sizeof( Queue_t )sizeof( StaticQueue_t )xReturn != pdFAILxReturn != ( ( ( BaseType_t ) 0 ) )QueueRegistryItem_txQueueRegistryItemQUEUE_REGISTRY_ITEMQueue_txQUEUESemaphoreData_tSemaphoreDataQueuePointers_tQueuePointersuxLengthxTasksWaitingToReceivexTasksWaitingToSenduxRecursiveCallCountxMutexHolderpcReadFrompcTailpcWriteTopcHeadxQueueRegistryprvIncrementQueueRxLock(pxQueue,cRxLock){ const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks(); if( ( UBaseType_t ) ( cRxLock ) < uxNumberOfTasks ) { configASSERT( ( cRxLock ) != queueINT8_MAX ); ( pxQueue )->cRxLock = ( int8_t ) ( ( cRxLock ) + ( int8_t ) 1 ); } }prvIncrementQueueTxLock(pxQueue,cTxLock){ const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks(); if( ( UBaseType_t ) ( cTxLock ) < uxNumberOfTasks ) { configASSERT( ( cTxLock ) != queueINT8_MAX ); ( pxQueue )->cTxLock = ( int8_t ) ( ( cTxLock ) + ( int8_t ) 1 ); } }prvLockQueue(pxQueue)taskENTER_CRITICAL(); { if( ( pxQueue )->cRxLock == queueUNLOCKED ) { ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; } if( ( pxQueue )->cTxLock == queueUNLOCKED ) { ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; } } taskEXIT_CRITICAL()queueYIELD_IF_USING_PREEMPTION()( ( TickType_t ) 0U )( ( UBaseType_t ) 0 )queueQUEUE_IS_MUTEXuxQueueTypequeueINT8_MAX( ( int8_t ) 127 )( ( int8_t ) 0 )( ( int8_t ) -1 )( configUSE_CO_ROUTINES == 1 )( configUSE_PREEMPTION == 0 )/* configUSE_QUEUE_SETS *//* The task waiting has a higher priority. *//* The data copied is the handle of the queue that contains data. *//* LCOV_EXCL_BR_LINE *//* The following line is not reachable in unit tests because every call
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL *//* This function must be called form a critical section. *//*lint !e961 Casting from one typedef to another is not redundant. *//*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. *//* The queue is no longer contained in the set. *//* It is dangerous to remove a queue from a set when the queue is
             * not empty because the queue set will still hold pending events for
             * the queue. *//* The queue was not a member of the set. *//* Cannot add a queue/semaphore to a queue set if there are already
                 * items in the queue/semaphore. *//* Cannot add a queue/semaphore to more than one queue set. *//* There is nothing in the queue, block for the specified period. *//* Only do anything if there are no messages in the queue.  This function
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. *//* This function should not be called by application code hence the
         * 'Restricted' in its name.  It is not part of the public API.  It is
         * designed for use by kernel code, and has special calling requirements.
         * It can result in vListInsert() being called on a list that can only
         * possibly ever have one item in it, so the list will be fast, but even
         * so it should be called with the scheduler locked and not from a critical
         * section. *//* configQUEUE_REGISTRY_SIZE *//*lint !e818 xQueue could not be pointer to const because it is a typedef. *//* Set the handle to NULL to ensure the same queue handle cannot
                 * appear in the registry twice if it is added, removed, then
                 * added again. *//* Set the name to NULL to show that this slot if free again. *//* See if the handle of the queue being unregistered in actually in the
         * registry. *//*lint !e818 xQueue cannot be a pointer to const because it is a typedef. *//* Note there is nothing here to protect against another task adding or
         * removing entries from the registry while it is being searched. *//* Store the information on this queue. *//* Otherwise, store in the next empty location *//* Replace an existing entry if the queue is already in the registry. *//* See if there is an empty space in the registry.  A NULL name denotes
             * a free slot. *//* configUSE_CO_ROUTINES *//* Copy the data from the queue. *//* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. *//* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. *//* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. *//* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. *//* Were any co-routines waiting for space to become available? *//* Data is available from the queue. *//* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. *//* There are no messages in the queue, do we want to block or just
                 * leave with nothing? *//* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. *//* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. *//* Were any co-routines waiting for data to become available? *//* There is room in the queue, copy the data into the queue. *//* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. *//* The queue is full - do we want to block or just leave without
                 * posting? *//* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. *//* Do the same for the Rx lock. *//* The task waiting has a higher priority so record that
                         * a context switch is required. *//* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. *//* The task waiting has a higher priority so record that a
                             * context switch is required. *//* Tasks that are removed from the event list will get
                     * added to the pending ready list as the scheduler is still
                     * suspended. *//* The queue is a member of a queue set, and posting to
                         * the queue set caused a higher priority task to unblock.
                         * A context switch is required. *//* Data was posted while the queue was locked.  Are any tasks
             * blocked waiting for data to become available? *//* See if data was added to the queue while it was locked. *//* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. *//* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. *//*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. *//*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. *//*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. *//* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. *//*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. *//*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. *//*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. *//* configUSE_MUTEXES *//* The mutex is no longer being held. *//* This function is called from a critical section. *//* If a task waiting for a mutex causes the mutex holder to inherit a
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. *//* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. *//* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) ) *//* The queue could have been allocated statically or dynamically, so
         * check before attempting to free the memory. *//* The queue can only have been allocated dynamically - free it
         * again. *//*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. *//* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. *//* Cannot block in an ISR, so check there is data available. *//* RTOS ports that support interrupt nesting have the concept of a maximum
     * system call (or maximum API call) interrupt priority.  Interrupts that are
     * above the maximum system call priority are kept permanently enabled, even
     * when the RTOS kernel is in a critical section, but cannot make any calls to
     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
     * failure if a FreeRTOS API function is called from an interrupt that has been
     * assigned a priority above the configured maximum system call priority.
     * Only FreeRTOS functions that end in FromISR can be called from interrupts
     * that have been assigned a priority at or (logically) below the maximum
     * system call interrupt priority.  FreeRTOS maintains a separate interrupt
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html *//* Can't peek a semaphore. *//* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. *//* The task waiting has a higher priority than us so
                         * force a context switch. *//* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. *//* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. *//* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. *//* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. *//* Update the timeout state to see if it has expired yet. *//* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. *//* Entry time was already set. *//* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. *//* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. *//* The task waiting has a higher priority than this task. *//* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. *//* The data is not being removed, so reset the read pointer. *//* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. *//* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. *//*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. *//* Cannot block if the scheduler is suspended. *//* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer. *//* Check the pointer is not NULL. *//* This task blocking on the mutex caused another
                             * task to inherit this task's priority.  Now this task
                             * has timed out the priority should be disinherited
                             * again, but only as low as the next highest priority
                             * task that is waiting for the same mutex. *//* xInheritanceOccurred could only have be set if
                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                     * test the mutex type again to check it is actually a mutex. *//* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. *//* Timed out. *//* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. *//* if ( configUSE_MUTEXES == 1 ) *//* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. *//* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. *//* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. *//* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. *//* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. *//* Record the information required to implement
                         * priority inheritance should it become necessary. *//* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. *//* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. *//*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. *//* Check this really is a semaphore, in which case the item size will be
     * 0. *//* Check the queue pointer is not NULL. *//* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. *//* The queue contains data again.  Loop back to try and read the
                 * data. *//* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. *//* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. *//* The queue was empty and a block time was specified so
                     * configure the timeout structure. *//* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. *//* Data available, remove one item. *//* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer). *//* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. *//* The task waiting has a higher priority so
                                 *  record that a context switch is required. *//* The semaphore is a member of a queue set, and
                             * posting to the queue set caused a higher priority
                             * task to unblock.  A context switch is required. *//* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. *//* A task can only have an inherited priority if it is a mutex
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. *//* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. *//* Normally a mutex would not be given from an interrupt, especially if
     * there is a mutex holder, as priority inheritance makes no sense for an
     * interrupts, only tasks. *//* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
     * if the item size is not 0. *//* Similar to xQueueGenericSendFromISR() but used with semaphores where the
     * item size is 0.  Don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). *//* Not used in this path. *//* The queue is a member of a queue set, and posting
                             * to the queue set caused a higher priority task to
                             * unblock.  A context switch is required. *//* Do not notify the queue set as an existing item
                             * was overwritten in the queue so the number of items
                             * in the queue has not changed. *//* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. *//* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). *//* The timeout has expired. *//* Try again. *//* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. *//* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. *//* The queue was full and a block time was specified so
                     * configure the timeout structure. *//* Return to the original privilege level before exiting
                     * the function. *//* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. *//* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. *//* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. *//* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. *//* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes
                             * and the mutexes were given back in an order that is
                             * different to that in which they were taken. *//* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to
                                 * do this from within the critical section - the
                                 * kernel takes care of that. *//* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. *//* The queue is a member of a queue set, and posting
                             * to the queue set caused a higher priority task to
                             * unblock. A context switch is required. *//* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. *//*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. *//* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *//* configUSE_RECURSIVE_MUTEXES *//* pdPASS will only be returned if the mutex was successfully
             * obtained.  The calling task may have entered the Blocked state
             * before reaching here. *//* Comments regarding mutual exclusion as per those within
         * xQueueGiveMutexRecursive(). *//* The mutex cannot be given because the calling task is not the
             * holder. *//* Return the mutex.  This will automatically unblock any other
                 * task that might be waiting to access the mutex. *//* Has the recursive call count unwound to 0? *//* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
             * the task handle, therefore no underflow check is required.  Also,
             * uxRecursiveCallCount is only modified by the mutex holder, and as
             * there can only be one, no mutual exclusion is required to modify the
             * uxRecursiveCallCount member. *//* If this is the task that holds the mutex then xMutexHolder will not
         * change outside of this task.  If this task does not hold the mutex then
         * pxMutexHolder can never coincidentally equal the tasks handle, and as
         * this is the only condition we are interested in it does not matter if
         * pxMutexHolder is accessed simultaneously by another task.  Therefore no
         * mutual exclusion is required to test the pxMutexHolder variable. *//*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. *//* Mutexes cannot be used in interrupt service routines, so the mutex
         * holder should not change in an ISR, and therefore a critical section is
         * not required here. *//* This function is called by xSemaphoreGetMutexHolder(), and should not
         * be called directly.  Note:  This is a good way of determining if the
         * calling task is the mutex holder, but not a good way of determining the
         * identity of the mutex holder, as the holder may change between the
         * following critical section exiting and the function returning. *//* Prevent compiler warnings about unused parameters if
         * configUSE_TRACE_FACILITY does not equal 1. *//* Start with the semaphore in the expected state. *//* In case this is a recursive mutex. *//* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. *//* Initialise the queue members as described where the queue type is
     * defined. *//* Set the head to the start of the queue storage area. *//* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. *//* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. *//* Queues can be created either statically or dynamically, so
                     * note this task was created dynamically in case it is later
                     * deleted. *//*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. *//* Jump past the queue structure to find the location of the queue
                 * storage area. *//* Allocate the queue and storage area.  Justification for MISRA
             * deviation as follows:  pvPortMalloc() always ensures returned memory
             * blocks are aligned per the requirements of the MCU stack.  In this case
             * pvPortMalloc() must return a pointer that is guaranteed to meet the
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). *//*lint !e961 MISRA exception as the casts are only redundant for some ports. *//* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. *//* Check for addition overflow. *//* Check for multiplication overflow. *//* Queues can be allocated wither statically or dynamically, so
                 * note this queue was allocated statically in case the queue is
                 * later deleted. *//*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. *//* The address of a statically allocated queue was passed in, use it.
             * The address of a statically allocated storage area was also passed in
             * but is already set. *//* Keeps lint quiet when configASSERT() is not defined. *//* This assertion cannot be branch covered in unit tests *//* Sanity check that the size of the structure used to declare a
                 * variable of type StaticQueue_t or StaticSemaphore_t equals the size of
                 * the real queue and semaphore structures. *//* A queue storage area should be provided if the item size is not 0, and
             * should not be provided if the item size is 0. *//* The StaticQueue_t structure and the queue storage area must be
         * supplied. *//* A value is returned for calling semantic consistency with previous
     * versions. *//* Ensure the event queues start in the correct state. *//* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. *//*
 * Macro to increment cRxLock member of the queue data structure. It is
 * capped at the number of tasks in the system as we cannot unblock more
 * tasks than the number of tasks in the system.
 *//*
 * Macro to increment cTxLock member of the queue data structure. It is
 * capped at the number of tasks in the system as we cannot unblock more
 * tasks than the number of tasks in the system.
 *//*
 * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 * accessing the queue event lists.
 *//*
 * If a task waiting for a mutex causes the mutex holder to inherit a
 * priority, but the waiting task times out, then the holder should
 * disinherit the priority - but only down to the highest priority of any
 * other tasks that are waiting for the same mutex.  This function returns
 * that priority.
 *//*
 * Mutexes are a special type of queue.  When a mutex is created, first the
 * queue is created, then prvInitialiseMutex() is called to configure the queue
 * as a mutex.
 *//*
 * Called after a Queue_t structure has been allocated either statically or
 * dynamically to fill in the structure's members.
 *//*
 * Checks to see if a queue is a member of a queue set, and if so, notifies
 * the queue set that the queue contains data.
 *//*
 * Copies an item out of a queue.
 *//*
 * Copies an item into the queue, either at the front of the queue or the
 * back of the queue.
 *//*
 * Uses a critical section to determine if there is any space in a queue.
 *
 * @return pdTRUE if there is no space, otherwise pdFALSE;
 *//*
 * Uses a critical section to determine if there is any data in a queue.
 *
 * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 *//*
 * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 * prevent an ISR from adding or removing items to the queue, but does prevent
 * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 * queue is locked it will instead increment the appropriate queue lock count
 * to indicate that a task may require unblocking.  When the queue in unlocked
 * these lock counts are inspected, and the appropriate action taken.
 *//* The queue registry is simply an array of QueueRegistryItem_t structures.
 * The pcQueueName member of a structure being NULL is indicative of the
 * array position being vacant. *//* The old xQueueRegistryItem name is maintained above then typedefed to the
 * new xQueueRegistryItem name below to enable the use of older kernel aware
 * debuggers. *//* The type stored within the queue registry array.  This allows a name
 * to be assigned to each queue making kernel aware debugging a little
 * more user friendly. *//*
 * The queue registry is just a means for kernel aware debuggers to locate
 * queue structures.  It has no other purpose so is an optional component.
 *//* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 * name below to enable the use of older kernel aware debuggers. *//*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. *//*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *//*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *//*< The size of each items that the queue will hold. *//*< The length of the queue defined as the number of items it will hold, not the number of bytes. *//*< The number of items currently in the queue. *//*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. *//*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. *//*< Data required exclusively when this structure is used as a semaphore. *//*< Data required exclusively when this structure is used as a queue. *//*< Points to the free next place in the storage area. *//*< Points to the beginning of the queue storage area. *//*
 * Definition of the queue used by the scheduler.
 * Items are queued by copy, not reference.  See the following link for the
 * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
 *//* If the cooperative scheduler is being used then a yield should not be
 * performed just because a higher priority task has been woken. *//* Semaphores do not actually store or copy data, so have an item size of
 * zero. *//*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. *//*< The handle of the task that holds the mutex. *//*< Points to the last place that a queued item was read from when the structure is used as a queue. *//*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. *//* When the Queue_t structure is used to represent a base queue its pcHead and
 * pcTail members are used as pointers into the queue storage area.  When the
 * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
 * not necessary, and the pcHead pointer is set to NULL to indicate that the
 * structure instead holds a pointer to the mutex holder (if any).  Map alternative
 * names to the pcHead and structure member to ensure the readability of the code
 * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
 * a union as their usage is mutually exclusive dependent on what the queue is
 * being used for. *//* Constants used with the cRxLock and cTxLock structure members. *//* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
 * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
 * for the header files above, but not in this file, in order to generate the
 * correct privileged Vs unprivileged linkage and placement. *//Users/mac/Downloads/FreeRTOS/Source/stream_buffer.csbFLAGS_IS_MESSAGE_BUFFERprvInitialiseNewStreamBufferStreamBuffer_t *StreamBuffer_t *constxWriteValue850x55memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer0x00sizeof( StreamBuffer_t )prvBytesInBufferconst StreamBuffer_tconst StreamBuffer_t *const StreamBuffer_t *constxCountprvReadBytesFromBufferxFirstLengthxCount != ( size_t ) 0pxStreamBuffer->xLength - xTailxFirstLength <= xCount( xTail + xFirstLength ) <= pxStreamBuffer->xLengthprvWriteBytesToBufferconst uint8_t *xCount > ( size_t ) 0pxStreamBuffer->xLength - xHead( xHead + xFirstLength ) <= pxStreamBuffer->xLength( xCount - xFirstLength ) <= pxStreamBuffer->xLengthpxStreamBuffer( pxStreamBuffer )->xTaskWaitingToSend( uint32_t ) 0volatile TaskHandle_t( pxStreamBuffer )->xTaskWaitingToReceivexBytesToStoreMessageLength( uint8_t ) 0sbBYTES_TO_STORE_MESSAGE_LENGTHxTailprvReadMessageFromBufferxNextMessageLengthxTempNextMessageLengthxNextTailxBytesAvailablexReceivedLength( pxStreamBuffer )( pxHigherPriorityTaskWoken )( ( pxStreamBuffer ) )->xTaskWaitingToSend( ( pxHigherPriorityTaskWoken ) )pucBufferucFlagspucDataxHeadxTempReturnxBytesAvailable == 0pxStreamBuffer->xTaskWaitingToReceive == NULLpxStreamBuffer->xTaskWaitingToReceive == ((void *)0)( xStreamBuffer )( ( xStreamBuffer ) )->xTaskWaitingToSendprvWriteMessageToBufferxNextHeadxMessageLength( size_t ) xMessageLength == xDataLengthBytesxSpacexRequiredSpace( ( pxStreamBuffer ) )->xTaskWaitingToReceivexMaxReportedSpace( size_t ) 1xRequiredSpace > xDataLengthBytespxStreamBuffer->xTaskWaitingToSend == NULLpxStreamBuffer->xTaskWaitingToSend == ((void *)0)xOriginalTailpxSendCallbackpxReceiveCallbacksbFLAGS_IS_STATICALLY_ALLOCATEDxTriggerLevelBytes <= xBufferSizeBytesxBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTHxBufferSizeBytes > ( sizeof( size_t ) )sizeof( StaticStreamBuffer_t )xSize == sizeof( StreamBuffer_t )pucAllocatedMemoryxBufferSizeBytes > 0( ( StreamBuffer_t * ) pucAllocatedMemory )StreamBuffer_txTaskWaitingToSendxTaskWaitingToReceivexLength( ( uint8_t ) 2 )( ( uint8_t ) 1 )( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )prvSEND_COMPLETE_FROM_ISR(pxStreamBuffer,pxHigherPriorityTaskWoken)sbSEND_COMPLETE_FROM_ISR( ( pxStreamBuffer ), ( pxHigherPriorityTaskWoken ) )sbSEND_COMPLETE_FROM_ISR(pxStreamBuffer,pxHigherPriorityTaskWoken){ UBaseType_t uxSavedInterruptStatus; uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR(); { if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL ) { ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive, ( uint32_t ) 0, eNoAction, ( pxHigherPriorityTaskWoken ) ); ( pxStreamBuffer )->xTaskWaitingToReceive = NULL; } } portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus ); }prvSEND_COMPLETED(pxStreamBuffer)sbSEND_COMPLETED( ( pxStreamBuffer ) )sbSEND_COMPLETED(pxStreamBuffer)vTaskSuspendAll(); { if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL ) { ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive, ( uint32_t ) 0, eNoAction ); ( pxStreamBuffer )->xTaskWaitingToReceive = NULL; } } ( void ) xTaskResumeAll();prvRECEIVE_COMPLETED_FROM_ISR(pxStreamBuffer,pxHigherPriorityTaskWoken)sbRECEIVE_COMPLETED_FROM_ISR( ( pxStreamBuffer ), ( pxHigherPriorityTaskWoken ) )sbRECEIVE_COMPLETED_FROM_ISR(pxStreamBuffer,pxHigherPriorityTaskWoken){ UBaseType_t uxSavedInterruptStatus; uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR(); { if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL ) { ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend, ( uint32_t ) 0, eNoAction, ( pxHigherPriorityTaskWoken ) ); ( pxStreamBuffer )->xTaskWaitingToSend = NULL; } } portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus ); }prvRECEIVE_COMPLETED(pxStreamBuffer)sbRECEIVE_COMPLETED( ( pxStreamBuffer ) )sbRECEIVE_COMPLETED(pxStreamBuffer)vTaskSuspendAll(); { if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL ) { ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend, ( uint32_t ) 0, eNoAction ); ( pxStreamBuffer )->xTaskWaitingToSend = NULL; } } ( void ) xTaskResumeAll();( configUSE_TASK_NOTIFICATIONS != 1 )( INCLUDE_xTaskGetCurrentTaskHandle != 1 )sbRECEIVE_COMPLETEDsbRECEIVE_COMPLETED_FROM_ISRsbSEND_COMPLETEDsbSEND_COMPLETE_FROM_ISR/*lint !e9087 memset() requires void *. *//*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. *//* The value written just has to be identifiable when looking at the
         * memory.  Don't use 0xA5 as that is the stack fill value and could
         * result in confusion as to what is actually being observed. *//* Assert here is deliberately writing to the entire buffer to ensure it can
     * be written to without generating exceptions, and is setting the buffer to a
     * known value to assist in development/debugging. *//* Returns the distance between xTail and xHead. *//* Move the tail pointer to effectively remove the data read from the buffer. *//*lint !e9087 memcpy() requires void *. *//* ...then read the remaining bytes from the start of the buffer. *//* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... *//* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. *//* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. *//* ...then write the remaining bytes to the start of the buffer. *//* If the number of bytes written was less than the number that could be
     * written in the first write... *//* Write as many bytes as can be written in the first write. *//* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. *//* True if the available space equals zero. *//* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. *//* True if no bytes are available. *//*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. *//* Read the actual data and update the tail to mark the data as officially consumed. *//* Use the minimum of the wanted bytes and the available bytes. *//* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. *//* The user has provided insufficient space to read the message. *//* Check there is enough space in the buffer provided by the
         * user. *//* Reduce the number of bytes available by the number of bytes just
         * read out. *//* A discrete message is being received.  First receive the length
         * of the message. *//* Was a task waiting for space in the buffer? *//* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. *//* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. *//* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. *//* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. *//* Ensure the stream buffer is being used as a message buffer. *//* Recheck the data available after blocking. *//* Wait for data to be available. *//* Should only be one reader. *//* Clear notification state as going to wait for data. *//* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. *//* Checking if there is data and clearing the notification state must be
         * performed atomically. *//*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. *//* Write the data to the buffer. *//* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. *//* Not enough space, so do not write data to the buffer. *//* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. *//* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. *//* Convert xDataLengthBytes to the message length type. *//* This is a message buffer, as opposed to a stream buffer. *//* Was a task waiting for the data? *//* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. *//* Should only be one writer. *//* Clear notification state as going to wait for space. *//* Wait until the required number of bytes are free in the message
             * buffer. *//* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. *//* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. *//* If this is a message buffer then it must be possible to write the
         * whole message. *//* Overflow? *//* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. *//* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. *//* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. *//* It is not valid for the trigger level to be 0. *//* Can only reset a message buffer if there are no tasks blocked on it. *//* Store the stream buffer number so it can be restored after the
         * reset. *//* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. *//* Should not be possible to get here, ucFlags must be corrupt.
             * Force an assert. *//*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). *//* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. *//* ( configSUPPORT_STATIC_ALLOCATION == 1 ) *//*lint !e9087 Data hiding requires cast to opaque type. *//* Remember this was statically allocated in case it is ever deleted
             * again. *//*lint !e529 xSize is referenced is configASSERT() is defined. *//* Sanity check that the size of the structure used to declare a
             * variable of type StaticStreamBuffer_t equals the size of the real
             * message buffer structure. *//* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. *//* Statically allocated stream buffer. *//* Statically allocated message buffer. *//* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. *//*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. *//*lint !e9087 !e826 Safe cast as allocated memory is aligned. *//*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. *//* Storage area follows. *//*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. *//*lint !e9087 Safe cast as allocated memory is aligned. *//* Structure at the start of the allocated memory. *//*lint !e9079 malloc() only returns void*. *//* A stream buffer requires a StreamBuffer_t structure and a buffer.
         * Both are allocated in a single call to pvPortMalloc().  The
         * StreamBuffer_t structure is placed at the start of the allocated memory
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. *//* Not a message buffer and not statically allocated. *//* Is a message buffer but not statically allocated. *//*
 * Called by both pxStreamBufferCreate() and pxStreamBufferCreateStatic() to
 * initialise the members of the newly created stream buffer structure.
 *//*
 * Copies xCount bytes from the pxStreamBuffer's data storage area to pucData.
 * This function does not update the buffer's xTail pointer, so multiple reads
 * may be chained together "atomically". This is useful for Message Buffers where
 * the length and data bytes are read in two separate chunks, and we don't want
 * the writer to see the buffer as having more free space until after all data is
 * copied over, especially if we have to abort the read due to insufficient receiving space.
 * This function takes a custom xTail value to indicate where to read from (necessary
 * for chaining) and returns the the resulting xTail position.
 * To mark the read as complete, manually set the buffer's xTail field with the
 * returned xTail from this function.
 *//*
 * If the stream buffer is being used as a message buffer, then writes an entire
 * message to the buffer.  If the stream buffer is being used as a stream
 * buffer then write as many bytes as possible to the buffer.
 * prvWriteBytestoBuffer() is called to actually send the bytes to the buffer's
 * data storage area.
 *//*
 * If the stream buffer is being used as a message buffer, then reads an entire
 * message out of the buffer.  If the stream buffer is being used as a stream
 * buffer then read as many bytes as possible from the buffer.
 * prvReadBytesFromBuffer() is called to actually extract the bytes from the
 * buffer's data storage area.
 *//*
 * Add xCount bytes from pucData into the pxStreamBuffer's data storage area.
 * This function does not update the buffer's xHead pointer, so multiple writes
 * may be chained together "atomically". This is useful for Message Buffers where
 * the length and data bytes are written in two separate chunks, and we don't want
 * the reader to see the buffer as having grown until after all data is copied over.
 * This function takes a custom xHead value to indicate where to write to (necessary
 * for chaining) and returns the the resulting xHead position.
 * To mark the write as complete, manually set the buffer's xHead field with the
 * returned xHead from this function.
 *//*
 * The number of bytes available to be read from the buffer.
 *//* Optional callback called on receive complete.  sbRECEIVE_COMPLETED is called if this is NULL. *//* Optional callback called on send complete. sbSEND_COMPLETED is called if this is NULL. *//* Used for tracing purposes. *//* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. *//* Holds the handle of a task waiting to send data to a message buffer that is full. *//* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. *//* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. *//* The length of the buffer pointed to by pucBuffer. *//* Index to the next item to write within the buffer. *//* Index to the next item to read within the buffer. *//*lint !e9058 Style convention uses tag. *//* Structure that hold state information on the buffer. *//* Set if the stream buffer was created using statically allocated memory. *//* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. *//* Bits stored in the ucFlags field of the stream buffer. *//* The number of bytes used to hold the length of a message in the buffer. *//*lint -restore (9026) *//* if ( configUSE_SB_COMPLETED_CALLBACK == 1 ) *//* sbSEND_COMPLETE_FROM_ISR *//* If user has provided a per-instance send completed callback, then
 * invoke the callback else use the send complete macro which is provided by default for all instances.
 *//* sbSEND_COMPLETED *//* If the user has not provided an application specific Tx notification macro,
 * or #defined the notification macro away, then provide a default
 * implementation that uses task notifications.
 *//* sbRECEIVE_COMPLETED_FROM_ISR *//* If user has provided a per-instance receive complete callback, then
 * invoke the callback else use the receive complete macro which is provided by default for all instances.
 *//* sbRECEIVE_COMPLETED *//*lint -save -e9026 Function like macros allowed and needed here so they can be overridden. *//* If the user has not provided application specific Rx notification macros,
 * or #defined the notification macros away, then provide default implementations
 * that uses task notifications. *//* Lint e961, e9021 and e750 are suppressed as a MISRA exception justified
 * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
 * for the header files above, but not in this file, in order to generate the
 * correct privileged Vs unprivileged linkage and placement. *//Users/mac/Downloads/FreeRTOS/Source/include/stack_macros.htaskCHECK_FOR_STACK_OVERFLOW(){ const uint32_t * const pulStack = ( uint32_t * ) pxCurrentTCB->pxStack; const uint32_t ulCheckValue = ( uint32_t ) 0xa5a5a5a5; if( ( pulStack[ 0 ] != ulCheckValue ) || ( pulStack[ 1 ] != ulCheckValue ) || ( pulStack[ 2 ] != ulCheckValue ) || ( pulStack[ 3 ] != ulCheckValue ) ) { vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName ); } }portSTACK_LIMIT_PADDINGSTACK_MACROS_H( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH < 0 ) )( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH > 0 ) )( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH < 0 ) )( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH > 0 ) )taskCHECK_FOR_STACK_OVERFLOW/* STACK_MACROS_H *//* Remove stack overflow macro if not being used. *//* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) *//* Has the extremity of the task stack ever been written over? *//* configCHECK_FOR_STACK_OVERFLOW == 1 *//* Is the currently saved stack pointer within the stack limit? *//* Only the current stack state is to be checked. *//*
 * portSTACK_LIMIT_PADDING is a number of extra words to consider to be in
 * use on the stack.
 *//*
 * Call the stack overflow hook function if the stack of the task being swapped
 * out is currently overflowed, or looks like it might have overflowed in the
 * past.
 *
 * Setting configCHECK_FOR_STACK_OVERFLOW to 1 will cause the macro to check
 * the current stack state only - comparing the current top of stack value to
 * the stack limit.  Setting configCHECK_FOR_STACK_OVERFLOW to greater than 1
 * will also cause the last few stack bytes to be checked to ensure the value
 * to which the bytes were set when the task was created have not been
 * overwritten.  Note this second test does not guarantee that an overflowed
 * stack will always be recognised.
 */525354/Users/mac/Downloads/FreeRTOS/Source/tasks.c"stack_macros.h"prvAddCurrentTaskToDelayedListxTimeToWakexConstTickCountvolatile TickType_tTCB_t *pxCurrentTCB->uxPriorityuxTopReadyPriority&xSuspendedTaskList&( pxCurrentTCB->xStateListItem )( &xSuspendedTaskList )( &( pxCurrentTCB->xStateListItem ) )ulTotalTime100( configRUN_TIME_COUNTER_TYPE ) 100( configRUN_TIME_COUNTER_TYPE ) 0pxTCBvolatile uint32_t[1]uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIESuxIndexToClear < 1volatile uint8_t[1]taskNOTIFICATION_RECEIVEDtaskNOT_WAITING_NOTIFICATIONucOriginalNotifyStateuxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIESuxIndexToNotify < 1listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL( ( &( pxTCB->xEventListItem ) )->pvContainer ) == ((void *)0)&( pxTCB->xEventListItem )&( pxTCB->xStateListItem )( pxTCB )->uxPriority&( pxReadyTasksLists[ ( pxTCB )->uxPriority ] )&( ( pxTCB )->xStateListItem )( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ) )( &( ( pxTCB )->xStateListItem ) )&( xPendingReadyList )( &( xPendingReadyList ) )( &( pxTCB->xEventListItem ) )taskWAITING_NOTIFICATION( UBaseType_t ) pdFALSEList_t[10]xLIST[10]volatile BaseType_txTickCount == ( TickType_t ) 0xCanBlockIndefinitelyuxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIESuxIndexToWait < 1uxIndexToWait( uint32_t ) 1&( pxCurrentTCB->xEventListItem )( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority )( ( TickType_t ) ( 10 ) - ( TickType_t ) pxCurrentTCB->uxPriority )xulStatsAsPercentage( char ) 0x00sizeof( TaskStatus_t )100UL	%u		%u%%
"\t%u\t\t%u%%\r\n"	%u		<1%%
"\t%u\t\t<1%%\r\n"cStatus88tskRUNNING_CHAR82tskREADY_CHAR66tskBLOCKED_CHAR83tskSUSPENDED_CHAR68tskDELETED_CHAR	%c	%u	%u	%u
"\t%c\t%u\t%u\t%u\r\n"char[15]prvWriteNameToBuffer( size_t ) ( configMAX_TASK_NAME_LEN - 1 )' 'TCB_t *constuxPriorityUsedOnEntryuxPriorityToUseuxOnlyOneMutexHeldpxTCB->uxMutexesHeldpxTCB != pxCurrentTCB( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse( TickType_t ) ( 10 ) - ( TickType_t ) uxPriorityToUse&( pxReadyTasksLists[ uxPriorityUsedOnEntry ] )pxTCB->uxPrioritytaskEVENT_LIST_ITEM_VALUE_IN_USEpxTCB == pxCurrentTCBpxTCB->uxBasePriority( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority( TickType_t ) ( 10 ) - ( TickType_t ) pxTCB->uxPrioritypxMutexHolderTCB&( pxMutexHolderTCB->xEventListItem )( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority( TickType_t ) ( 10 ) - ( TickType_t ) pxCurrentTCB->uxPriority&( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] )&( pxMutexHolderTCB->xStateListItem )pxMutexHolderTCB->uxPriority( pxMutexHolderTCB )->uxPriority&( pxReadyTasksLists[ ( pxMutexHolderTCB )->uxPriority ] )&( ( pxMutexHolderTCB )->xStateListItem )( &( pxReadyTasksLists[ ( pxMutexHolderTCB )->uxPriority ] ) )( &( ( pxMutexHolderTCB )->xStateListItem ) )prvResetNextTaskUnblockTimepxDelayedTaskListprvDeleteTCBpxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCBpxTCB->ucStaticallyAllocated == ( ( uint8_t ) 2 )tskDYNAMICALLY_ALLOCATED_STACK_AND_TCBtskSTATICALLY_ALLOCATED_STACK_ONLYpucEndOfStackprvTaskCheckFreeStackSpaceulCount165( uint8_t ) tskSTACK_FILL_BYTEprvListTasksWithinSingleListpxNextTCBpxFirstTCBuxTaskpxConstListchar[10]prvCheckTasksWaitingTermination( &xTasksWaitingTermination )prvInitialiseTaskListspcBufferpucStackByteList_t *volatilexTaskToModifypxTCB != NULLpxTCB != ((void *)0)prvIdleTask&( pxReadyTasksLists[ tskIDLE_PRIORITY ] )&( pxReadyTasksLists[ ( ( UBaseType_t ) 0U ) ] )configMINIMAL_SECURE_STACK_SIZEconst TCB_tconst TCB_t *xElapsedTimepxUnblockedTCBuxSchedulerSuspended != pdFALSEuxSchedulerSuspended != ( ( BaseType_t ) 0 )xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USExItemValue | 0x80000000UL&( pxUnblockedTCB->xStateListItem )( pxUnblockedTCB )->uxPriority&( pxReadyTasksLists[ ( pxUnblockedTCB )->uxPriority ] )&( ( pxUnblockedTCB )->xStateListItem )( &( pxReadyTasksLists[ ( pxUnblockedTCB )->uxPriority ] ) )( &( ( pxUnblockedTCB )->xStateListItem ) )&( pxUnblockedTCB->xEventListItem )( &( pxUnblockedTCB->xEventListItem ) )( pxEventList )( &( pxCurrentTCB->xEventListItem ) )( xTickCount + xTicksToWait )uxSchedulerSuspended != 0&( pxReadyTasksLists[ uxTopPriority ] )uxTopPrioritypxCurrentTCBconst uint32_t *constpulStackulCheckValue2779096485TCB_t *volatilexTCBxSwitchRequired( listLIST_IS_EMPTY( pxDelayedTaskList ) )( ( ( ( pxDelayedTaskList )->uxNumberOfItems == ( UBaseType_t ) 0 ) ? ( ( BaseType_t ) 1 ) : ( ( BaseType_t ) 0 ) ) )( TickType_t ) 1pxTempxTickCountxYieldOccurreduxSchedulerSuspended == 0( xIdleTaskHandle != NULL )( xIdleTaskHandle != ((void *)0) )uxQueue( UBaseType_t ) tskIDLE_PRIORITYstrlen( pcNameToQuery ) < configMAX_TASK_NAME_LENstrlen( pcNameToQuery ) < ( 10 )prvSearchForNameWithinSingleListconst char[]char[]cNextCharxBreakLoop( UBaseType_t ) configMAX_TASK_NAME_LENxTicksuxSchedulerSuspended&xPendingReadyList( &xPendingReadyList )xPendedCountspxIdleTaskTCBBufferpxIdleTaskStackBufferulIdleTaskStackSizeIDLEconfigIDLE_TASK_NAMEchar[5]( void * ) NULLxReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORYxReturn != ( -1 )( TickType_t ) configINITIAL_TICK_COUNTconst volatile UBaseType_tprvTaskIsTaskSuspendedconst TCB_t *constuxCurrentBasePriorityuxNewPriority < configMAX_PRIORITIESuxNewPriority < ( 10 )( UBaseType_t ) 1U( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority )( ( TickType_t ) ( 10 ) - ( TickType_t ) uxNewPriority )uxSavedInterruptStatepxStateListpxDelayedListpxOverflowedDelayedListxShouldDelay( xTimeIncrement > 0U )&xYieldPendingprvAddNewTaskToReadyListpxNewTCB( pxNewTCB )->uxPriority&( pxReadyTasksLists[ ( pxNewTCB )->uxPriority ] )&( ( pxNewTCB )->xStateListItem )( &( pxReadyTasksLists[ ( pxNewTCB )->uxPriority ] ) )( &( ( pxNewTCB )->xStateListItem ) )prvInitialiseNewTask~portPRIVILEGE_BIT( int ) tskSTACK_FILL_BYTEsizeof( StackType_t )( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) )( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL )( ( ( uint32_t ) pxTopOfStack & ( uint32_t ) ( 0x0007 ) ) == 0UL )'\0'uxPriority < configMAX_PRIORITIESuxPriority < ( 10 )&( pxNewTCB->xStateListItem )&( pxNewTCB->xEventListItem )( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority( TickType_t ) ( 10 ) - ( TickType_t ) uxPriorityvolatile StackType_tvolatile StackType_t *pxStack132sizeof( TCB_t )pxTaskDefinition->puxStackBufferpxTaskDefinition->puxStackBuffer != NULLpxTaskDefinition->puxStackBuffer != ((void *)0)pxTaskDefinition->pxTaskBuffer != NULLpxTaskDefinition->pxTaskBuffer != ((void *)0)tskSTATICALLY_ALLOCATED_STACK_AND_TCBpuxStackBuffer != NULLpuxStackBuffer != ((void *)0)pxTaskBuffer != NULLpxTaskBuffer != ((void *)0)sizeof( StaticTask_t )xSize == sizeof( TCB_t )TCB_ttskTCBucDelayAborteducNotifyStateulNotifiedValuepvThreadLocalStoragePointerspxTaskTaguxMutexesHelduxTaskNumberuxTCBNumberxEventListItemxStateListItemulTotalRunTimeulTaskSwitchedInTimeuxTopUsedPriorityxIdleTaskHandlexNextTaskUnblockTimexNumOfOverflows( BaseType_t ) 0xYieldPendingxPendedTicksxSchedulerRunninguxCurrentNumberOfTasksxSuspendedTaskListuxDeletedTasksWaitingCleanUpxTasksWaitingTerminationxPendingReadyListpxOverflowDelayedTaskListxDelayedTaskList2xDelayedTaskList1pxReadyTasksLists0x80000000ULprvGetTCBFromHandle(pxHandle)( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )prvAddTaskToReadyList(pxTCB)traceMOVED_TASK_TO_READY_STATE( pxTCB ); taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority ); listINSERT_END( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )taskSWITCH_DELAYED_LISTS(){ List_t * pxTemp; configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) ); pxTemp = pxDelayedTaskList; pxDelayedTaskList = pxOverflowDelayedTaskList; pxOverflowDelayedTaskList = pxTemp; xNumOfOverflows++; prvResetNextTaskUnblockTime(); }portRESET_READY_PRIORITY(uxPriority,uxTopReadyPriority)taskRESET_READY_PRIORITY(uxPriority)taskSELECT_HIGHEST_PRIORITY_TASK(){ UBaseType_t uxTopPriority = uxTopReadyPriority; while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) ) { configASSERT( uxTopPriority ); --uxTopPriority; } listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); uxTopReadyPriority = uxTopPriority; }taskRECORD_READY_PRIORITY(uxPriority){ if( ( uxPriority ) > uxTopReadyPriority ) { uxTopReadyPriority = ( uxPriority ); } }"IDLE"( 'S' )( 'D' )( 'R' )( 'B' )( 'X' )tskSET_NEW_STACKS_TO_KNOWN_VALUE( ( uint8_t ) 0 )tskSTACK_FILL_BYTE( 0xa5U )taskYIELD_IF_USING_PREEMPTION()( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )portREMOVE_STATIC_QUALIFIER( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )( configUSE_TICKLESS_IDLE != 0 )FREERTOS_TASKS_C_ADDITIONS_INIT( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )( portSTACK_GROWTH > 0 )( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )( portSTACK_GROWTH < 0 )( configRECORD_STACK_HIGH_ADDRESS == 1 )( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )( configUSE_PREEMPTION != 0 )( configUSE_PREEMPTION == 1 )( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )( configUSE_TICK_HOOK == 1 )( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )( configUSE_IDLE_HOOK == 1 )portSTACK_GROWTH < 0( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configUSE_TRACE_FACILITY == 1 ) )portLU_PRINTF_SPECIFIER_REQUIREDFREERTOS_MODULE_TEST( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )/* if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 ) *//* Code below here allows additional code to be inserted into this source file,
 * especially where access to file scope functions and data is needed (for example
 * when performing module tests). *//* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. *//* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. *//* The wake time has not overflowed, so the current block list is used. *//* Wake time has overflowed.  Place this item in the overflow list. *//* The list item will be inserted in wake time order. *//* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. *//* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. *//* The wake time has not overflowed, so the current block list
                 * is used. *//* Wake time has overflowed.  Place this item in the overflow
                 * list. *//* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. *//* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. *//*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. *//* The current task must be in a ready list, so there is no need to
         * check, and the port reset macro can be called directly. *//* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. *//* About to enter a delayed list, so ensure the ucDelayAborted flag is
         * reset to pdFALSE so it can be detected as having been set to pdTRUE
         * when the task leaves the Blocked state. *//* Avoid divide by zero errors. *//* For percentage calculations. *//* configUSE_TASK_NOTIFICATIONS *//* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. *//* If null is passed in here then it is the calling task that is having
         * its notification state cleared. *//* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. *//* The notified task has a priority above the currently
                     * executing task so a yield is required. *//* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. *//* The task should not have been on an event list. *//* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. *//* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. *//* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
         * failure if a FreeRTOS API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html *//* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. *//* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. *//* The task is being notified without its notify value being
                     * updated. *//* The value could not be written to the task. *//* If a task is blocked waiting for a notification then
                     * xNextTaskUnblockTime might be set to the blocked task's time
                     * out time.  If the task is unblocked for a reason other than
                     * a timeout xNextTaskUnblockTime is normally left unchanged,
                     * because it will automatically get reset to a new value when
                     * the tick count equals xNextTaskUnblockTime.  However if
                     * tickless idling is used it might be more important to enter
                     * sleep mode at the earliest possible time - so reset
                     * xNextTaskUnblockTime here to ensure it is updated at the
                     * earliest possible time. *//* A notification was already pending or a notification was
                 * received while the task was waiting. *//* A notification was not received. *//* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. *//* Output the current notification value, which may or may not
                 * have changed. *//* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. *//* Mark this task as waiting for a notification. *//* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. *//* Only block if a notification is not already pending. *//* Only block if the notification count is not already non-zero. *//* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. *//* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. *//* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) *//* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
             * is 0 then vPortFree() will be #defined to nothing. *//*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. *//*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. *//* sizeof( int ) == sizeof( long ) so a smaller
                             * printf() library can be used. *//* If the percentage is zero here then the task has
                         * consumed less than 1% of the total run time. *//* Write the task name to the string, padding with
                     * spaces so it can be printed in tabular form more
                     * easily. *//* What percentage of the total run time has the task used?
                     * This will always be rounded down to the nearest integer.
                     * ulTotalRunTime has already been divided by 100. *//* Create a human readable table from the binary data. *//* Generate the (binary) data. *//*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. *//* Allocate an array index for each task.  NOTE!  If
         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
         * equate to NULL. *//* Take a snapshot of the number of tasks in case it changes while this
         * function is executing. *//* Make sure the write buffer does not contain a string. *//*
         * PLEASE NOTE:
         *
         * This function is provided for convenience only, and is used by many
         * of the demo applications.  Do not consider it to be part of the
         * scheduler.
         *
         * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
         * of the uxTaskGetSystemState() output into a human readable table that
         * displays the amount of time each task has spent in the Running state
         * in both absolute and percentage terms.
         *
         * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
         * function that might bloat the code size, use a lot of stack, and
         * provide different results on different platforms.  An alternative,
         * tiny, third party, and limited functionality implementation of
         * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
         * a file called printf-stdarg.c (note printf-stdarg.c does not provide
         * a full snprintf() implementation!).
         *
         * It is recommended that production systems call uxTaskGetSystemState()
         * directly to get access to raw stats data, rather than indirectly
         * through a call to vTaskGetRunTimeStats().
         *//*----------------------------------------------------------*//* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) *//* Write the rest of the string. *//* Write the task name to the string, padding with spaces so it
                 * can be printed in tabular form more easily. *//* Should not get here, but it is included
                                    * to prevent static checking errors. *//* Fall through. *//* Allocate an array index for each task.  NOTE!  if
         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
         * equate to NULL. *//*
         * PLEASE NOTE:
         *
         * This function is provided for convenience only, and is used by many
         * of the demo applications.  Do not consider it to be part of the
         * scheduler.
         *
         * vTaskList() calls uxTaskGetSystemState(), then formats part of the
         * uxTaskGetSystemState() output into a human readable table that
         * displays task: names, states, priority, stack usage and task number.
         * Stack usage specified as the number of unused StackType_t words stack can hold
         * on top of stack - not the number of bytes.
         *
         * vTaskList() has a dependency on the sprintf() C library function that
         * might bloat the code size, use a lot of stack, and provide different
         * results on different platforms.  An alternative, tiny, third party,
         * and limited functionality implementation of sprintf() is provided in
         * many of the FreeRTOS/Demo sub-directories in a file called
         * printf-stdarg.c (note printf-stdarg.c does not provide a full
         * snprintf() implementation!).
         *
         * It is recommended that production systems call uxTaskGetSystemState()
         * directly to get access to raw stats data, rather than indirectly
         * through a call to vTaskList().
         *//* ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) *//* Return the new end of string. *//* Terminate. *//* Pad the end of the string with spaces to ensure columns line up when
         * printed out. *//* Start by copying the entire string. *//* portCRITICAL_NESTING_IN_TCB *//* This is not the interrupt safe version of the enter critical
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. *//* It is known that the task is in its ready list so
                             * there is no need to check again and the port level
                             * reset macro can be called directly. *//* If the running task is not the task that holds the mutex
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. *//* Only reset the event list item value if the value is not
                     * being used for anything else. *//* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. *//* If a task has timed out because it already holds the
                     * mutex it was trying to obtain then it cannot of inherited
                     * its own priority. *//* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. *//* Does the priority need to change? *//* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. *//* If pxMutexHolder is not NULL then the holder must hold at least
             * one mutex. *//* Return true to indicate that a context switch is required.
                     * This is only actually required in the corner case whereby
                     * multiple mutexes were held and the mutexes were given back
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. *//* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. *//* Disinherit the priority before adding the task into the
                     * new  ready list. *//* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. *//* Only disinherit if no other mutexes are held. *//* Has the holder of the mutex inherited the priority of another
             * task? *//* A task can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. *//* The base priority of the mutex holder is lower than the
                     * priority of the task attempting to take the mutex, but the
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. *//* Inheritance occurred. *//* Just inherit the priority. *//* Inherit the priority before being moved into the new list. *//* It is known that the task is in its ready list so
                         * there is no need to check again and the port level
                         * reset macro can be called directly. *//* If the task being modified is in the ready state it will need
                 * to be moved into a new list. *//* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. *//* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. *//* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? *//* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) *//* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) *//* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. *//* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. *//* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. *//* INCLUDE_vTaskDelete *//* Neither the stack nor the TCB were allocated dynamically, so
                 * nothing needs to be freed. *//* Only the stack was statically allocated, so the TCB is the
                 * only memory that must be freed. *//* Both the stack and TCB were allocated dynamically, so both
                 * must be freed. *//* The task could have been allocated statically or dynamically, so
             * check what was statically allocated before trying to free the
             * memory. *//*lint !e731 !e9029 Macro has been consolidated for readability reasons. *//* The task can only have been allocated dynamically - free both
             * the stack and TCB. *//* Free up the memory allocated for the task's TLS Block. *//* This call is required specifically for the TriCore port.  It must be
         * above the vPortFree() calls.  The call is also used by ports/demos that
         * want to allocate and clean RAM statically. *//* INCLUDE_uxTaskGetStackHighWaterMark *//* INCLUDE_uxTaskGetStackHighWaterMark2 *//* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
         * the same except for their return type.  Using configSTACK_DEPTH_TYPE
         * allows the user to determine the return type.  It gets around the
         * problem of the value overflowing on 8-bit types without breaking
         * backward compatibility for applications that expect an 8-bit return
         * type. *//* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
 * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
 * user to determine the return type.  It gets around the problem of the value
 * overflowing on 8-bit types without breaking backward compatibility for
 * applications that expect an 8-bit return type. *//* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) ) *//*lint !e961 Casting is not redundant on smaller architectures. *//*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. *//* Populate an TaskStatus_t structure within the
             * pxTaskStatusArray array for each task that is referenced from
             * pxList.  See the definition of TaskStatus_t in task.h for the
             * meaning of each TaskStatus_t structure member. *//* Obtaining the stack space takes some time, so the xGetFreeStackSpace
         * parameter is provided to allow it to be skipped. *//* If the task is in the suspended list then there is a
                     *  chance it is actually just blocked indefinitely - so really
                     *  it should be reported as being in the Blocked state. *//* Obtaining the task state is a little fiddly, so is only done if the
         * value of eState passed into this function is eInvalid - otherwise the
         * state is just set to whatever is passed in. *//* xTask is NULL then get the state of the calling task. *//* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. *//** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **//* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. *//* If null is passed in here then we are modifying the MPU settings of
         * the calling task. *//* configNUM_THREAD_LOCAL_STORAGE_POINTERS *//* configUSE_TICKLESS_IDLE *//* If all the tasks are in the suspended list (which might mean they
                 * have an infinite block time rather than actually being suspended)
                 * then it is safe to turn all clocks off and just wait for external
                 * interrupts. *//* A tick interrupt has already occurred but was held pending
             * because the scheduler is suspended. *//* A yield was pended while the scheduler was suspended. *//* A task was made ready while the scheduler was suspended. *//* This function must be called from a critical section. *//* The idle task exists in addition to the application tasks. *//* Define the following macro to set xExpectedIdleTime to 0
                     * if the application does not want
                     * portSUPPRESS_TICKS_AND_SLEEP() to be called. *//* Now the scheduler is suspended, the expected idle
                     * time can be sampled again, and this time its value can
                     * be used. *//* It is not desirable to suspend then resume the scheduler on
             * each iteration of the idle task.  Therefore, a preliminary
             * test of the expected idle time is performed without the
             * scheduler suspended.  The result here is not necessarily
             * valid. *//* This conditional compilation should use inequality to 0, not equality
         * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
         * user defined low power mode  implementations require
         * configUSE_TICKLESS_IDLE to be set to a value other than 1. *//* configUSE_IDLE_HOOK *//* Call the user defined function from within the idle task.  This
             * allows the application designer to add background functionality
             * without the overhead of a separate task.
             * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
             * CALL A FUNCTION THAT MIGHT BLOCK. *//* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) *//* When using preemption tasks of equal priority will be
             * timesliced.  If a task that is sharing the idle priority is ready
             * to run then the idle task should yield before the end of the
             * timeslice.
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. *//* configUSE_PREEMPTION *//* If we are not using preemption we keep forcing a task switch to
             * see if any other task has become available.  If we are using
             * preemption we don't need to do this as any task becoming available
             * will automatically get the processor anyway. *//* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. *//* In case a task that has a secure context deletes itself, in which case
     * the idle task is responsible for deleting the task's secure context, if
     * any. *//** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
     * SCHEDULER IS STARTED. **//* Stop warnings. *//*
 * -----------------------------------------------------------
 * The Idle task.
 * ----------------------------------------------------------
 *
 * The portTASK_FUNCTION() macro is used to allow port/compiler specific
 * language extensions.  The equivalent prototype for this function is:
 *
 * void prvIdleTask( void *pvParameters );
 *
 *//* Not a genuine timeout. Adjust parameters for time remaining. *//*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. *//* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. *//*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. *//* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. *//* The delay was aborted, which is not the same as a time out,
                 * but has the same result. *//* Minor optimisation.  The tick count cannot change in this block. *//* For internal use only as it does not use a critical section. *//* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). *//* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. *//* If a task is blocked on a kernel object then xNextTaskUnblockTime
         * might be set to the blocked task's time out time.  If the task is
         * unblocked for a reason other than a timeout xNextTaskUnblockTime is
         * normally left unchanged, because it is automatically reset to a new
         * value when the tick count equals xNextTaskUnblockTime.  However if
         * tickless idling is used it might be more important to enter sleep mode
         * at the earliest possible time - so reset xNextTaskUnblockTime here to
         * ensure it is updated at the earliest possible time. *//* Remove the event list form the event flag.  Interrupts do not access
     * event flags. *//* Store the new item value in the event list. *//* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. *//* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. *//* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. *//* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. *//* If a task is blocked on a kernel object then xNextTaskUnblockTime
             * might be set to the blocked task's time out time.  If the task is
             * unblocked for a reason other than a timeout xNextTaskUnblockTime is
             * normally left unchanged, because it is automatically reset to a new
             * value when the tick count equals xNextTaskUnblockTime.  However if
             * tickless idling is used it might be more important to enter sleep mode
             * at the earliest possible time - so reset xNextTaskUnblockTime here to
             * ensure it is updated at the earliest possible time. *//* The event list is sorted in priority order, so the first in the list can
     * be removed as it is known to be the highest priority.  Remove the TCB from
     * the delayed list, and add it to the ready list.
     *
     * If an event is for a queue that is locked then this function will never
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. *//* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
     * called from a critical section within an ISR. *//* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. *//* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. *//* This function should not be called by application code hence the
         * 'Restricted' in its name.  It is not part of the public API.  It is
         * designed for use by kernel code, and has special calling requirements -
         * it should be called with the scheduler suspended. *//* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). *//* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. *//* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event groups implementation. *//* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.
     *
     * Note: Lists are sorted in ascending order by ListItem_t.xItemValue.
     * Normally, the xItemValue of a TCB's ListItem_t members is:
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. *//* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
     * SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. *//* Switch C-Runtime's TLS Block to point to the TLS
             * Block specific to this task. *//* After the new task is switched in, update the global errno. *//* Select a new task to run using either the generic C or port
         * optimised asm code. *//* Before the currently running task is switched out, save its errno. *//* Check for stack overflow, if configured. *//* Add the amount of time the task has been running to the
             * accumulated time so far.  The time the task started running was
             * stored in ulTaskSwitchedInTime.  Note that there is no overflow
             * protection here so count values are only valid until the timer
             * overflows.  The guard against negative values is to protect
             * against suspect run time stat counter implementations - which
             * are provided by the application, not the kernel. *//* The scheduler is currently suspended - do not allow a context
         * switch. *//* configUSE_APPLICATION_TASK_TAG *//* If xTask is NULL then we are calling our own task hook. *//* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. *//* If xTask is NULL then set the calling task's hook. *//* If xTask is NULL then it is the task hook of the calling task that is
         * getting set. *//* The tick hook gets called at regular intervals, even if the
         * scheduler is locked. *//* configUSE_TICK_HOOK *//* Guard against the tick hook being called when the pended tick
             * count is being unwound (when the scheduler is being unlocked). *//* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) *//* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. *//* Preemption is on, but a context switch should
                         * only be performed if the unblocked task's
                         * priority is higher than the currently executing
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*//* A task being unblocked cannot cause an immediate
                     * context switch if preemption is turned off. *//* Place the unblocked task into the appropriate ready
                     * list. *//* Is the task waiting on an event also?  If so remove
                     * it from the event list. *//* It is time to remove the item from the Blocked state. *//*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. *//* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. *//* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. *//* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. *//* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. *//*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. *//* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. *//* Minor optimisation.  The tick count cannot change in this
         * block. *//* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. *//* INCLUDE_xTaskAbortDelay *//* Pend the yield to be performed when the scheduler
                         * is unsuspended. *//* Preemption is on, but a context switch should only be
                     * performed if the unblocked task has a priority that is
                     * higher than the currently executing task. *//* A task being unblocked cannot cause an immediate context
                 * switch if preemption is turned off. *//* Place the unblocked task into the appropriate ready list. *//* This lets the task know it was forcibly removed from the
                         * blocked state so it should not re-evaluate its block time and
                         * then block again. *//* Is the task waiting on an event also?  If so remove it from
                 * the event list too.  Interrupts can touch the event list item,
                 * even though the scheduler is suspended, so a critical section
                 * is used. *//* Remove the reference to the task from the blocked list.  An
                 * interrupt won't touch the xStateListItem because the
                 * scheduler is suspended. *//* A task can only be prematurely removed from the Blocked state if
             * it is actually in the Blocked state. *//* Prevent the tick interrupt modifying xPendedTicks simultaneously. *//* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). *//* Must not be called with the scheduler suspended as the implementation
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). *//* Arrange for xTickCount to reach xNextTaskUnblockTime in
             * xTaskIncrementTick() when the scheduler resumes.  This ensures
             * that any delayed tasks are resumed at the correct time. *//* Correct the tick count value after a period during which the tick
         * was suppressed.  Note this does *not* call the tick hook function for
         * each stepped tick. *//* This conditional compilation should use inequality to 0, not equality to 1.
 * This is to ensure vTaskStepTick() is available when user defined low power mode
 * implementations require configUSE_TICKLESS_IDLE to be set to a value other than
 * 1. *//* INCLUDE_xTaskGetIdleTaskHandle *//* If xTaskGetIdleTaskHandle() is called before the scheduler has been
         * started, then xIdleTaskHandle will be NULL. *//* if ( configGENERATE_RUN_TIME_STATS == 1 ) *//* Fill in an TaskStatus_t structure with information on
                     * each task in the Suspended state. *//* Fill in an TaskStatus_t structure with information on
                     * each task that has been deleted but not yet cleaned up. *//* Fill in an TaskStatus_t structure with information on each
                 * task in the Blocked state. *//* Fill in an TaskStatus_t structure with information on each
                 * task in the Ready state. *//* Is there a space in the array for each task in the system? *//* INCLUDE_xTaskGetHandle *//* Search the deleted list. *//* Search the suspended list. *//* Search the delayed lists. *//* Found the handle. *//* Search the ready lists. *//* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. *//* The handle has been found. *//* Both strings terminated, a match must have been
                         * found. *//* Characters didn't match. *//* Check each character in the name looking for a match or
                 * mismatch. *//* This function is called with the scheduler suspended. *//* If null is passed in here then the name of the calling task is being
     * queried. *//* A critical section is not required because the variables are of type
     * BaseType_t. *//* RTOS ports that support interrupt nesting have the concept of a maximum
     * system call (or maximum API call) interrupt priority.  Interrupts that are
     * above the maximum system call priority are kept permanently enabled, even
     * when the RTOS kernel is in a critical section, but cannot make any calls to
     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
     * failure if a FreeRTOS API function is called from an interrupt that has been
     * assigned a priority above the configured maximum system call priority.
     * Only FreeRTOS functions that end in FromISR can be called from interrupts
     * that have been assigned a priority at or (logically) below the maximum
     * system call  interrupt priority.  FreeRTOS maintains a separate interrupt
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html *//* Critical section required if running on a 16 bit processor. *//* Non-volatile copy. *//* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. *//* A task was unblocked while the scheduler was suspended,
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. *//* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. *//* Move any readied tasks from the pending list into the
                 * appropriate ready list. *//* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. *//* If uxSchedulerSuspended is zero then this function does not match a
     * previous call to vTaskSuspendAll(). *//* There are tasks in the Ready state that have a priority above the
             * idle priority.  This path can only be reached if
             * configUSE_PREEMPTION is 0. *//* There are other idle priority tasks in the ready state.  If
             * time slicing is used then the very next tick interrupt must be
             * processed. *//* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 ) *//* When port optimised task selection is used the uxTopReadyPriority
             * variable is used as a bit map.  If bits other than the least
             * significant bit are set then there are tasks that have a priority
             * above the idle priority that are in the Ready state.  This takes
             * care of the case where the co-operative scheduler is in use. *//* uxHigherPriorityReadyTasks takes care of the case where
         * configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
         * task that are in the Ready state, even though the idle task is
         * running. *//* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. *//* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. *//* portSOFTWARE_BARRIER() is only implemented for emulated/simulated ports that
     * do not otherwise exhibit real time behaviour. *//* A critical section is not required as the variable is of type
     * BaseType_t.  Please read Richard Barry's reply in the following link to a
     * post in the FreeRTOS support forum before reporting this as a bug! -
     * https://goo.gl/wu4acr *//* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. *//* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. *//* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
     * meaning xIdleTaskHandle is not used anywhere else. *//* This line will only be reached if the kernel could not be started,
         * because there was not enough FreeRTOS heap to create the idle task
         * or the timer task. *//* In most cases, xPortStartScheduler() will not return. If it
         * returns pdTRUE then there was not enough heap memory available
         * to create either the Idle or the Timer task. If it returned
         * pdFALSE, then the application called xTaskEndScheduler().
         * Most ports don't implement xTaskEndScheduler() as there is
         * nothing to return to. *//* Setting up the timer tick is hardware specific and thus in the
         * portable interface. *//* If configGENERATE_RUN_TIME_STATS is defined then the following
         * macro must be defined to configure the timer/counter used to generate
         * the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
         * is set to 0 and the following line fails to build then ensure you do not
         * have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
         * FreeRTOSConfig.h file. *//* Switch C-Runtime's TLS Block to point to the TLS
             * block specific to the task that will run first. *//* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. *//* freertos_tasks_c_additions_init() should only be called if the user
         * definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
         * the only macro called by the function. *//*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. *//* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. *//* The Idle task is being created using dynamically allocated RAM. *//*lint !e961.  The cast is not redundant for all compilers. *//* The Idle task is created using user provided RAM - obtain the
         * address of the RAM then create the idle task. *//* Add the idle task at the lowest priority. *//* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) *//* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. *//* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. *//* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. *//* Check the ready lists can be accessed. *//* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. *//* A higher priority task may have just been resumed. *//* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. *//* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. *//* It does not make sense to resume the calling task. *//*lint !e818 xTask cannot be a pointer to const because it is a typedef. *//*lint !e961.  The cast is only redundant when NULL is used. *//* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? *//* Has the task already been resumed from within an ISR? *//* Is the task being resumed actually in the suspended list? *//* It does not make sense to check if the calling task is suspended. *//* Accesses xPendingReadyList so must be called from a critical
         * section. *//* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. *//*lint !e931 Right has no side effect, just volatile. *//* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. *//* The current task has just been suspended. *//* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. *//* The task was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. *//* Is the task waiting on an event also? *//* Remove task from the ready/delayed list and place in the
             * suspended list. *//* If null is passed in here then it is the running task that is
             * being suspended. *//* INCLUDE_vTaskPrioritySet *//* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. *//* The task is currently in its ready list - remove before
                     * adding it to its new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. *//* If the task is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. *//* Only reset the event list item value if the value is not
                 * being used for anything else. *//* The base priority gets set whatever. *//* Only change the priority being used if the task is not
                     * currently using an inherited priority. *//* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. *//* Setting the priority of any other task down does not
                     * require a yield as the running task must be above the
                     * new priority of the task being modified. *//* Setting the priority of the running task down means
                     * there may now be another task of higher priority that
                     * is ready to execute. *//* The priority of the running task is being raised,
                         * but the running task must already be the highest
                         * priority task able to run so no yield is required. *//* The priority of a task other than the currently
                         * running task is being raised.  Is the priority being
                         * raised above that of the running task? *//* The priority change may have readied a task of higher
                 * priority than the calling task. *//* If null is passed in here then it is the priority of the calling
             * task that is being changed. *//* Ensure the new priority is valid. *//* INCLUDE_uxTaskPriorityGet *//* If null is passed in here then it is the priority of the calling
             * task that is being queried. *//* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. *//* INCLUDE_eTaskGetState *//* If the task is not in any other state, it must be in the
                 * Ready (including pending ready) state. *//*lint !e525 Negative indentation is intended to make use of pre-processor clearer. *//* The task being queried is referenced from the deleted
                     * tasks list, or it is not referenced from any lists at
                     * all. *//* The task does not appear on the event list item of
                             * and of the RTOS objects, but could still be in the
                             * blocked state if it is waiting on its notification
                             * rather than waiting on an object.  If not, is
                             * suspended. *//* The task being queried is referenced from the suspended
                     * list.  Is it genuinely suspended or is it blocked
                     * indefinitely? *//* The task being queried is referenced from one of the Blocked
                 * lists. *//* The task calling this function is querying its own state. *//* INCLUDE_vTaskDelay *//* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. *//* A task that is removed from the event list while the
                 * scheduler is suspended will not get placed in the ready
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. *//* A delay time of zero just forces a reschedule. *//* INCLUDE_xTaskDelayUntil *//* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. *//* Update the wake time ready for the next call. *//* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. *//* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. *//* Generate the tick time at which the task wants to wake. *//* Minor optimisation.  The tick count cannot change in this
             * block. *//* Force a reschedule if it is the currently running task that has just
         * been deleted. *//* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. *//* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. *//* The pre-delete hook is primarily for the Windows simulator,
                 * in which Windows specific clean up operations are performed,
                 * after which it is not possible to yield away from this task -
                 * hence xYieldPending is used to latch that a context switch is
                 * required. *//* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
                 * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. *//* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. *//* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. *//* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. *//* Remove task from the ready/delayed list. *//* If null is passed in here then it is the calling task that is
             * being deleted. *//* If the created task is of a higher priority than the current task
         * then it should run now. *//* Add a counter into the TCB for tracing only. *//* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. *//* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. *//* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. *//* Ensure interrupts don't access the task lists while the lists are being
     * updated. *//* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*//* portHAS_STACK_OVERFLOW_CHECKING *//* portSTACK_GROWTH *//* If the port has capability to detect stack overflow,
         * pass the stack end address to the stack initialization
         * function as well. *//* Initialize the TCB stack to look as if the task was already running,
     * but had been interrupted by the scheduler.  The return address is set
     * to the start of the task function. Once the stack has been initialised
     * the top of stack variable is updated. *//* Allocate and initialize memory for the task's TLS Block. *//* Avoid compiler warning about unreferenced parameter. *//* Event lists are always in priority order. *//* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. *//* This is used as an array index so must ensure it's not too large. *//* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. *//* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). *//* Store the task name in the TCB. *//* The other extreme of the stack space is required if stack checking is
         * performed. *//* Check the alignment of the stack buffer is correct. *//* configRECORD_STACK_HIGH_ADDRESS *//* Also record the stack's high address, which may assist
             * debugging. *//* Check the alignment of the calculated top of stack is correct. *//*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). *//* Calculate the top of stack address.  This depends on whether the stack
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. *//* tskSET_NEW_STACKS_TO_KNOWN_VALUE *//* Fill the stack with a known value to assist debugging. *//* Avoid dependency on memset() if it is not required. *//* Should the task be created in privileged mode? *//* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE *//* Tasks can be created statically or dynamically, so note this
                 * task was created dynamically in case it is later deleted. *//*lint !e9029 !e731 Macro has been consolidated for readability reasons. *//* The stack cannot be used as the TCB was not created.  Free
                     * it again. *//* Store the stack location in the TCB. *//*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. *//* Allocate space for the TCB. *//*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. *//* Allocate space for the stack used by the task being created. *//* Could not allocate the stack.  Delete the allocated TCB. *//* Allocate space for the stack used by the task being created.
                 * The base of the stack memory stored in the TCB so the task can
                 * be deleted later if required. *//* Allocate space for the TCB.  Where the memory comes from depends on
             * the implementation of the port malloc function and whether or not static
             * allocation is being used. *//* If the stack grows down then allocate the stack then the TCB so the stack
         * does not grow into the TCB.  Likewise if the stack grows up then allocate
         * the TCB then the stack. *//* Tasks can be created statically or dynamically, so note
                     * this task had a statically allocated stack in case it is
                     * later deleted.  The TCB was allocated dynamically. *//* Allocate space for the TCB.  Where the memory comes from depends
             * on the implementation of the port malloc function and whether or
             * not static allocation is being used. *//* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) *//* Tasks can be created statically or dynamically, so note this
                 * task was created statically in case the task is later deleted. *//* SUPPORT_STATIC_ALLOCATION *//* The memory used for the task's TCB and stack are passed into this
             * function - use them. *//* Prevent lint warning when configASSERT() is not used. *//* Sanity check that the size of the structure used to declare a
             * variable of type StaticTask_t equals the size of the real task
             * structure. *//*
 * freertos_tasks_c_additions_init() should only be called if the user definable
 * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 * called by the function.
 *//*
 * Called after a new task has been created and initialised to place the task
 * under the control of the scheduler.
 *//*
 * Called after a Task_t structure has been allocated either statically or
 * dynamically to fill in the structure's members.
 *//*
 * Helper function used to pad task names with spaces when printing out
 * human readable tables of task information.
 *//*
 * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 * will exit the Blocked state.
 *//*
 * Return the amount of time, in ticks, that will pass before the kernel will
 * next move a task from the Blocked state to the Running state.
 *
 * This conditional compilation should use inequality to 0, not equality to 1.
 * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 * set to a value other than 1.
 *//*
 * When a task is created, the stack of the task is filled with a known value.
 * This function determines the 'high water mark' of the task stack by
 * determining how much of the stack remains at the original preset value.
 *//*
 * Searches pxList for a task with name pcNameToQuery - returning a handle to
 * the task if it is found, or NULL if the task is not found.
 *//*
 * Fills an TaskStatus_t structure with information on each task that is
 * referenced from the pxList list (which may be a ready list, a delayed list,
 * a suspended list, etc.).
 *
 * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 * NORMAL APPLICATION CODE.
 *//*
 * The currently executing task is entering the Blocked state.  Add the task to
 * either the current or the overflow delayed task list.
 *//*
 * Used only by the idle task.  This checks to see if anything has been placed
 * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 * and its TCB deleted.
 *//*
 * Utility to free all memory allocated by the scheduler to hold a TCB,
 * including the stack pointed to by the TCB.
 *
 * This does not free memory allocated by the task itself (i.e. memory
 * allocated by calls to pvPortMalloc from within the tasks application code).
 *//*
 * The idle task, which as all tasks is implemented as a never ending loop.
 * The idle task is automatically created and added to the ready lists upon
 * creation of the first user task.
 *
 * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 * language extensions.  The equivalent prototype for this function is:
 *
 * void prvIdleTask( void *pvParameters );
 *
 *//*
 * Utility to ready all the lists used by the scheduler.  This is called
 * automatically upon the creation of the first task.
 *//**
 * Utility task that simply returns pdTRUE if the task referenced by xTask is
 * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 * is in any other state.
 *//* File private functions. --------------------------------*//*< Holds the total amount of execution time as defined by the run time counter clock. *//*< Holds the value of a timer/counter the last time a task was switched in. *//* Do not move these variables to function scope as doing so prevents the
 * code working with debuggers that need to remove the static qualifier. *//* Context switches are held pending while the scheduler is suspended.  Also,
 * interrupts must not manipulate the xStateListItem of a TCB, or any of the
 * lists the xStateListItem can be referenced from, if the scheduler is suspended.
 * If an interrupt needs to unblock a task while the scheduler is suspended then it
 * moves the task's event list item into the xPendingReadyList, ready for the
 * kernel to move the task from the pending ready list into the real ready list
 * when the scheduler is unsuspended.  The pending ready list itself can only be
 * accessed from a critical section. *//* Improve support for OpenOCD. The kernel tracks Ready tasks via priority lists.
 * For tracking the state of remote threads, OpenOCD uses uxTopUsedPriority
 * to determine the number of priority lists to read back from the remote target. *//*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. *//* Initialised to portMAX_DELAY before the scheduler starts. *//* Other file private variables. --------------------------------*//* Global POSIX errno. Its value is changed upon context switching to match
 * the errno of the currently running task. *//*< Tasks that are currently suspended. *//*< Tasks that have been deleted - but their memory not yet freed. *//*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. *//*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. *//*< Points to the delayed task list currently being used. *//*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. *//*< Delayed tasks. *//*< Prioritised ready tasks. *//* Lists for ready and blocked tasks. --------------------
 * xDelayedTaskList1 and xDelayedTaskList2 could be moved to function scope but
 * doing so breaks some kernel aware debuggers and debuggers that rely on removing
 * the static qualifier. *//*lint -save -e956 A manual analysis and inspection has been used to determine
 * which static variables must be declared volatile. *//* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 * below to enable the use of older kernel aware debuggers. *//*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. *//* See the comments in FreeRTOS.h with the definition of
     * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. *//*< Memory block used as Thread Local Storage (TLS) Block for the task. *//*< Stores the amount of time the task has spent in the Running state. *//*< The priority last assigned to the task - used by the priority inheritance mechanism. *//*< Stores a number specifically for use by third party trace code. *//*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. *//*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. *//*< Points to the highest valid address for the stack. *//*< Descriptive name given to the task when created.  Facilitates debugging only. *//*< Points to the start of the stack. *//*< The priority of the task.  0 is the lowest priority. *//*< Used to reference a task from an event list. *//*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). *//*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. *//*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. *//*
 * Task control block.  A task control block (TCB) is allocated for each task,
 * and stores task state information, including a pointer to the task's context
 * (the task's run time environment, including register values)
 *//* The item value of the event list item is normally used to hold the priority
 * of the task to which it belongs (coded to allow it to be held in reverse
 * priority order).  However, it is occasionally borrowed for other purposes.  It
 * is important its value is not updated due to a task priority change while it is
 * being used for another purpose.  The following bit definition is used to inform
 * the scheduler that the value should not be changed - in which case it is the
 * responsibility of whichever module is using the value to ensure it gets set back
 * to its original value when it is released. *//*
 * Several functions take a TaskHandle_t parameter that can optionally be NULL,
 * where NULL is used to indicate that the handle of the currently executing
 * task should be used in place of the parameter.  This macro simply checks to
 * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 *//*
 * Place the task represented by pxTCB into the appropriate ready list for
 * the task.  It is inserted at the end of the list.
 *//* The delayed tasks list should be empty when the lists are switched. *//* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 * count overflows. *//* A port optimised version is provided, call it only if the TCB being reset
 * is being referenced from a ready list.  If it is referenced from a delayed
 * or suspended list then it won't be in a ready list. *//* taskSELECT_HIGHEST_PRIORITY_TASK() *//* Find the highest priority list that contains ready tasks. *//* A port optimised version is provided.  Call the port defined macros. *//* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 * performed in a way that is tailored to the particular microcontroller
 * architecture being used. *//* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 * they are only required when a port optimised method of task selection is
 * being used. *//* taskSELECT_HIGHEST_PRIORITY_TASK *//* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of \
         * the  same priority get an equal share of the processor time. *//* Find the highest priority queue that contains ready tasks. *//* taskRECORD_READY_PRIORITY *//* uxTopReadyPriority holds the priority of the highest priority ready
 * state task. *//* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 * performed in a generic way that is not optimised to any particular
 * microcontroller architecture. *//* The name allocated to the Idle task.  This can be overridden by defining
 * configIDLE_TASK_NAME in FreeRTOSConfig.h. *//*
 * Some kernel aware debuggers require the data the debugger needs access to to
 * be global, rather than file scope.
 *//*
 * Macros used by vListTask to indicate which state a task is in.
 *//* If any of the following are set then task stacks are filled with a known
 * value so the high water mark can be determined.  If none of the following are
 * set then don't fill the stack so there is no unnecessary dependency on memset. *//* Bits used to record how a task's stack and TCB were allocated. *//*
 * The value used to fill the stack of a task when the task is created.  This
 * is used purely for checking the high water mark for tasks.
 *//* Must be zero as it is the initialised value. *//* Values that can be assigned to the ucNotifyState member of the TCB. *//* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) *//* At the bottom of this file are two optional functions that can be used
 * to generate human readable text from the raw data generated by the
 * uxTaskGetSystemState() function.  Note the formatting functions are provided
 * for convenience only, and are NOT considered part of the kernel. *//* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
 * functions but without including stdio.h here. *//Users/mac/Downloads/FreeRTOS/Source/timers.cTimer_t *xMessagexTimerQueue&xMessageDaemonTaskMessage_t *tmrTimerQueueMessage *Timer_t *constpxTimertmrSTATUS_IS_ACTIVEprvCheckForValidListAndQueue( UBaseType_t ) configTIMER_QUEUE_LENGTH( UBaseType_t ) 5( UBaseType_t ) sizeof( DaemonTaskMessage_t )&( ucStaticTimerQueueStorage[ 0 ] )&xStaticTimerQueuexStaticTimerQueueuint8_t[80]unsigned char[80]( size_t ) configTIMER_QUEUE_LENGTHsizeof( DaemonTaskMessage_t )80( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t )ucStaticTimerQueueStorageTmrQ"TmrQ"prvSwitchTimerListsxNextExpireTimepxCurrentTimerListtmrMAX_TIME_BEFORE_OVERFLOWprvProcessReceivedCommandsxTimerListsWereSwitchedxTimeNowpxCallback&( pxTimer->xTimerListItem )xMessage.xMessageIDxMessage.u.xTimerParameters.xMessageValue( pxTimer->xTimerPeriodInTicks > 0 )tmrNO_DELAYconst CallbackParameters_tconst CallbackParameters_t *tmrCallbackParameters *const CallbackParameters_t *constCallbackParameters_t *tmrSTATUS_IS_AUTORELOAD254( uint8_t ) ~tmrSTATUS_IS_ACTIVE( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE )tmrSTATUS_IS_STATICALLY_ALLOCATEDprvInsertTimerInActiveListxProcessTimerNowxNextExpiryTimeprvSampleTimeNowxLastTimexCommandTimepxTimerListsWereSwitchedprvGetNextExpireTimeprvProcessTimerOrBlockTaskpxOverflowTimerListprvTimerTaskxListWasEmptyprvProcessExpiredTimerprvReloadTimer251( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD )( xTimerTaskHandle != NULL )( xTimerTaskHandle != ((void *)0) )prvInitialiseNewTimer( xTimerPeriodInTicks > 0 )pxNewTimersizeof( StaticTimer_t )xSize == sizeof( Timer_t )sizeof( Timer_t )pxTimerTaskTCBBufferpxTimerTaskStackBufferulTimerTaskStackSizeTmr SvcconfigTIMER_SERVICE_TASK_NAME( UBaseType_t ) configTIMER_TASK_PRIORITY( ( UBaseType_t ) configTIMER_TASK_PRIORITY )2147483657( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BITDaemonTaskMessage_ttmrTimerQueueMessageCallbackParameters_ttmrCallbackParametersTimerParameter_ttmrTimerParametersTimer_txTIMERxMessageIDxCallbackParametersxTimerParametersxMessageValueucStatusxTimerListItemxTimerTaskHandlexActiveTimerList2xActiveTimerList1( ( uint8_t ) 0x04 )( ( uint8_t ) 0x02 )( ( uint8_t ) 0x01 )"Tmr Svc"( ( TickType_t ) -1 )( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )( INCLUDE_xTimerPendFunctionCall == 1 )( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )pxListWasEmptyxExpiredTime/* configUSE_TIMERS == 1 *//* This entire source file will be skipped if the application is not configured
 * to include software timer functionality.  If you want to include software timer
 * functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. *//* INCLUDE_xTimerPendFunctionCall *//* Complete the message with the function parameters and post it to the
             * daemon task. *//* This function can only be called after a timer has been created or
             * after the scheduler has been started because, until then, the timer
             * queue does not exist. *//*lint !e818 Can't be pointer to const due to the typedef. *//* Is the timer in the list of active timers? *//*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. *//* The timer queue is allocated statically in case
                     * configSUPPORT_DYNAMIC_ALLOCATION is 0. *//* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. *//* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. *//* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. *//* Don't expect to get here. *//* If dynamic allocation is not enabled, the memory
                             * could not have been dynamically allocated. So there is
                             * no need to free the memory - just mark the timer as
                             * "not active". *//* The timer has already been removed from the active list,
                             * just free up the memory if the memory was dynamically
                             * allocated. *//* The new period does not really have a reference, and can
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. *//* The timer has already been removed from the active list. *//* Call the timer callback. *//* The timer expired before it was added to the active
                             * timer list.  Process it now. *//* Start or restart a timer. *//* In this case the xTimerListsWereSwitched parameter is not used, but
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). *//* The timer is in a list, remove it. *//*lint !e961. The cast is only redundant when NULL is passed into the macro. *//* The messages uses the xTimerParameters member to work on a
                 * software timer. *//* Commands that are positive are timer commands rather than pended
             * function calls. *//* Call the function. *//* The timer uses the xCallbackParameters member to request a
                     * callback be executed.  Check the callback is not NULL. *//* Negative commands are pended function calls rather than timer
                 * commands. *//*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. *//* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. *//* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  *//* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? *//*lint !e956 Variable is only accessible to one task. *//* Ensure the task unblocks when the tick count rolls over. *//* Timers are listed in expiry time order, with the head of the list
         * referencing the task that will expire first.  Obtain the time at which
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  *//* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. *//* The current timer list is empty - is the overflow list
                         * also empty? *//* The tick count has not overflowed, and the next expire
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. *//* The tick count has not overflowed, has the timer expired? *//* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. *//* Empty the command queue. *//* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. *//* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. *//* configUSE_DAEMON_TASK_STARTUP_HOOK *//* Allow the application writer to execute some code in the context of
             * this task at the point the task starts executing.  This is useful if the
             * application includes initialisation code that would benefit from
             * executing after the scheduler has been started. *//* Just to avoid compiler warnings. *//* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. *//* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. *//*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. *//* Advance the expiry time. *//* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. *//* Is an auto-reload timer. *//* Not an auto-reload timer. *//* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. *//* Send a command to the timer service task to start the xTimer timer. *//* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. *//* Initialise the timer structure members using the function
         * parameters. *//* Ensure the infrastructure used by the timer service task has been
         * created/initialised. *//* 0 is not a valid value for xTimerPeriodInTicks. *//* Timers can be created statically or dynamically so note this
                 * timer was created statically in case it is later deleted.  The
                 * auto-reload bit may get set in prvInitialiseNewTimer(). *//*lint !e740 !e9087 StaticTimer_t is a pointer to a Timer_t, so guaranteed to be aligned and sized correctly (checked by an assert()), so this is safe. *//* A pointer to a StaticTimer_t structure MUST be provided, use it. *//* Sanity check that the size of the structure used to declare a
                 * variable of type StaticTimer_t equals the size of the real timer
                 * structure. *//* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. *//*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. *//* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. *//*
 * Called after a Timer_t structure has been allocated either statically or
 * dynamically to fill in the structure's members.
 *//*
 * If a timer has expired, process it.  Otherwise, block the timer service task
 * until either a timer does expire or a command is received.
 *//*
 * If the timer list contains any active timers then return the expire time of
 * the timer that will expire first and set *pxListWasEmpty to false.  If the
 * timer list does not contain any timers then return 0 and set *pxListWasEmpty
 * to pdTRUE.
 *//*
 * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
 * if a tick count overflow occurred since prvSampleTimeNow() was last called.
 *//*
 * The tick count has overflowed.  Switch the timer lists after ensuring the
 * current timer list does not still reference some timers.
 *//*
 * An active timer has reached its expire time.  Reload the timer if it is an
 * auto-reload timer, then call its callback.
 *//*
 * Reload the specified auto-reload timer.  If the reloading is backlogged,
 * clear the backlog, calling the callback for each additional reload.  When
 * this function returns, the next expiry time is after xTimeNow.
 *//*
 * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
 * depending on if the expire time causes a timer counter overflow.
 *//*
 * Called by the timer service task to interpret and process a command it
 * received on the timer queue.
 *//*
 * The timer service task (daemon).  Timer functionality is controlled by this
 * task.  Other tasks communicate with the timer service task using the
 * xTimerQueue queue.
 *//*
 * Initialise the infrastructure used by the timer service task if it has not
 * been initialised already.
 *//* A queue that is used to send commands to the timer service task. *//* The list in which active timers are stored.  Timers are referenced in expire
 * time order, with the nearest expiry time at the front of the list.  Only the
 * timer service task is allowed to access these lists.
 * xActiveTimerList1 and xActiveTimerList2 could be at function scope but that
 * breaks some kernel aware debuggers, and debuggers that reply on removing the
 * static qualifier. *//* Don't include xCallbackParameters if it is not going to be used as
             * it makes the structure (and therefore the timer queue) larger. *//*<< The command being sent to the timer service task. *//* The structure that contains the two message types, along with an identifier
 * that is used to determine which message type is valid. *//* << The value that will be used as the callback functions second parameter. *//* << The value that will be used as the callback functions first parameter. *//* << The callback function to execute. *//*<< The timer to which the command will be applied. *//*<< An optional value used by a subset of commands, for example, when changing the period of a timer. *//* The definition of messages that can be sent and received on the timer queue.
 * Two types of message can be queued - messages that manipulate a software timer,
 * and messages that request the execution of a non-timer related callback.  The
 * two message types are defined in two separate structures, xTimerParametersType
 * and xCallbackParametersType respectively. *//* The old xTIMER name is maintained above then typedefed to the new Timer_t
 * name below to enable the use of older kernel aware debuggers. *//*<< Holds bits to say if the timer was statically allocated or not, and if it is active or not. *//*<< An ID assigned by trace tools such as FreeRTOS+Trace *//*<< The function that will be called when the timer expires. *//*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. *//*<< How quickly and often the timer expires. *//*<< Standard linked list item as used by all kernel features for event management. *//*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. *//* The definition of the timers themselves. *//* Bit definitions used in the ucStatus member of a timer structure. *//* The name assigned to the timer service task.  This can be overridden by
 * defining trmTIMER_SERVICE_TASK_NAME in FreeRTOSConfig.h. *//* Misc definitions. *//* This entire source file will be skipped if the application is not configured
 * to include software timer functionality.  This #if is closed at the very bottom
 * of this file.  If you want to include software timer functionality then ensure
 * configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. *//*lint !e9021 !e961 !e750. *//Users/mac/codeqlCL/codeql/cpp/tools/osx64/extractor--mimic/users/mac/downloads/gcc-arm-none-eabi-10.3-2021.10/lib/gcc/arm-none-eabi/10.3.1/cc1-quiet-I-imultilibthumb/v7-m/nofp-iprefix/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/bin/../lib/gcc/arm-none-eabi/10.3.1/-isysroot/Users/mac/Downloads/gcc-arm-none-eabi-10.3-2021.10/bin/../arm-none-eabi-MMDbuild//Users/mac/Downloads/FreeRTOS/Source/portable/Common/mpu_wrappers.d-MQbuild//Users/mac/Downloads/FreeRTOS/Source/portable/Common/mpu_wrappers.o-D__USES_INITFINI__-DHEAP4-dumpbasempu_wrappers.c-mcpu=cortex-m3-mfloat-abi=soft-mthumb-mlibarch=armv7-m-march=armv7-m-auxbase-strip-O3-Wno-error=implicit-function-declaration-Wno-builtin-declaration-mismatch-Werror-Wall-Wextra-Wstrict-aliasing-Wno-error=address-of-packed-member-fstrict-aliasing-o/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccVC4zO1.sbuild//Users/mac/Downloads/FreeRTOS/Source/queue.dbuild//Users/mac/Downloads/FreeRTOS/Source/queue.oqueue.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccMd9JmO.sbuild//Users/mac/Downloads/FreeRTOS/Source/list.dbuild//Users/mac/Downloads/FreeRTOS/Source/list.olist.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccyiGuHV.sbuild/app_main.dbuild/app_main.oapp_main.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//cc0j8qWd.sbuild//Users/mac/Downloads/FreeRTOS/Source/timers.dbuild//Users/mac/Downloads/FreeRTOS/Source/timers.otimers.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//cc9YdLGz.sbuild//Users/mac/Downloads/FreeRTOS/Source/portable/MemMang/heap_4.dbuild//Users/mac/Downloads/FreeRTOS/Source/portable/MemMang/heap_4.oheap_4.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccJQSsIJ.sbuild//Users/mac/Downloads/FreeRTOS/Source/stream_buffer.dbuild//Users/mac/Downloads/FreeRTOS/Source/stream_buffer.ostream_buffer.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//cc4bOP8l.sbuild//Users/mac/Downloads/FreeRTOS/Source/portable/GCC/ARM_CM3_MPU/port.dbuild//Users/mac/Downloads/FreeRTOS/Source/portable/GCC/ARM_CM3_MPU/port.oport.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccNkhEKp.sbuild/init/startup.dbuild/init/startup.oinit/startup.cstartup.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccDU5jin.sbuild/mpu_demo.dbuild/mpu_demo.ompu_demo.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccTW8EUC.sbuild//Users/mac/Downloads/FreeRTOS/Source/tasks.dbuild//Users/mac/Downloads/FreeRTOS/Source/tasks.otasks.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccipcUHU.sbuild//Users/mac/Downloads/FreeRTOS/Source/event_groups.dbuild//Users/mac/Downloads/FreeRTOS/Source/event_groups.oevent_groups.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//cc4XUgaQ.sbuild/main.dbuild/main.omain.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccjui66Y.sbuild/syscall.dbuild/syscall.osyscall.c/var/folders/_1/lsjnbw4j0rs20phttfmcsmyh0000gn/T//ccuK8t2P.s/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/build/RTOSDemo.axf/Users/mac/Downloads/FreeRTOS/Demo/CORTEX_MPU_M3_MPS2_QEMU_GCC/build                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             s)       